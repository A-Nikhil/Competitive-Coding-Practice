

KnightTour.java


package Algorithms.Backtracking;

import java.util.Arrays;

public class KnightTour {
	private static final int[] xMove = {2, 1, -1, -2, -2, -1, 1, 2};
	private static final int[] yMove = {1, 2, 2, 1, -1, -2, -2, -1};
	private static int N;

	private static boolean solveKT(int n) {
		N = n;
		int[][] sol = new int[n][n];
		for (int[] arr : sol) {
			Arrays.fill(arr, -1);
		}
		sol[0][0] = 0;
		return solveKTUtil(0, 0, 1, sol);
	}

	private static boolean solveKTUtil(int x, int y, int move, int[][] sol) {
		int k, nextX, nextY;
		if (move == N * N) {
			return true;
		}
		for (k = 0; k < 8; k++) {
			nextX = x + xMove[k];
			nextY = y + yMove[k];
			if (isValid(nextX, nextY, sol)) {
				sol[nextX][nextY] = move;
				if (solveKTUtil(nextX, nextY, move + 1, sol)) {
					return true;
				} else {
					sol[nextX][nextY] = -1;
				}
			}
		}
		return false;
	}

	private static boolean isValid(int x, int y, int[][] sol) {
		return ((x >= 0) && (y >= 0) && (x < N) && (y < N) && (sol[x][y] == -1));
	}

	public static void main(String[] args) {
		int n = 8;
		System.out.println(solveKT(n));
	}
}


 ===================================================== 


PermutationsOfAString.java


package Algorithms.Backtracking;

public class PermutationsOfAString {
	private static String swap(String x, int a, int b) {
		char temp;
		char[] ch = x.toCharArray();
		temp = ch[a];
		ch[a] = ch[b];
		ch[b] = temp;
		return String.valueOf(ch);
	}

	private static void permute(String s, int l, int r) {
		if (l == r) {
			System.out.println(s);
		} else {
			for (int i = l; i <= r; i++) {
				s = swap(s, l, i);
				permute(s, l + 1, r);
				s = swap(s, l, i);
			}
		}
	}

	public static void main(String[] args) {
		permute("ABCD", 0, 4 - 1);
	}
}


 ===================================================== 


RatInAMaze.java


package Algorithms.Backtracking;

public class RatInAMaze {
	private static int R, C;

	private static boolean solveMaze(int[][] mat, int r, int c) {
		R = r;
		C = c;
		int[][] sol = new int[R][C];
		return solveMazeUtil(mat, 0, 0, sol);

	}

	private static boolean solveMazeUtil(int[][] mat, int i, int j, int[][] sol) {
		if (i == R - 1 && j == C - 1 && mat[i][j] == 1) {
			sol[i][j] = 1;
			return true;
		}

		if (isValid(mat, i, j)) {
			sol[i][j] = 1;
			if (solveMazeUtil(mat, i + 1, j, sol)) {
				return true;
			}

			if (solveMazeUtil(mat, i, j + 1, sol)) {
				return true;
			}
			sol[i][j] = 0;
			return false;
		}

		return false;
	}

	private static boolean isValid(int[][] mat, int i, int j) {
		return ((i >= 0) && (j >= 0) && (i < R) && (j < C) && mat[i][j] == 1);
	}


	public static void main(String[] args) {
		int[][] maze = {
				{1, 0, 0, 0},
				{1, 1, 0, 1},
				{0, 1, 0, 0},
				{1, 1, 1, 1}
		};
		System.out.println(solveMaze(maze, maze.length, maze[0].length));
	}
}


 ===================================================== 


DistributeMAmongN.java


package Algorithms.Counting;

public class DistributeMAmongN {
	public static void main(String[] args) {
		int n = 2, m = 3;
		distribute(n, m);
	}

	private static void distribute(int n, int m) {
		// (n+m-1)C(n-1)
		System.out.println("m identical mangoes amongst n identical people => "
				+ binomialCoefficient(n + m - 1, n - 1));
	}

	private static int binomialCoefficient(int n, int m) {
		int res = 1;
		if (m > n - m) {
			m = n - m;
		}
		for (int i = 0; i < m; i++) {
			res *= (n - i);
			res /= (i + 1);
		}
		return res;
	}
}


 ===================================================== 


DivideNInGroupsOfK.java


package Algorithms.Counting;

import java.util.Arrays;

public class DivideNInGroupsOfK {
	private static int[][][] dp = new int[500][500][500];

	private static int calculate(int pos, int prev, int left, int k) {
		if (pos == k) {
			if (left == 0) {
				return 1;
			} else {
				return 0;
			}
		}

		if (left == 0) {
			return 0;
		}

		if (dp[pos][prev][left] != -1) {
			return dp[pos][prev][left];
		}
		int ans = 0;
		for (int i = prev; i <= left; i++) {
			ans += calculate(pos + 1, i, left - i, k);
		}
		dp[pos][prev][left] = ans;
		return ans;
	}

	private static int getWays(int n, int k) {
		for (int[][] arr1 : dp) {
			for (int[] arr2 : arr1) {
				Arrays.fill(arr2, -1);
			}
		}
		return calculate(0, 1, n, k);
	}

	public static void main(String[] args) {
		int n = 24, k = 5;
		System.out.println(getWays(n, k));
	}
}


 ===================================================== 


NumberOfWaysToClimbStairs.java


package Algorithms.Counting;

public class NumberOfWaysToClimbStairs {
	public static void main(String[] args) {
		int n = 4;
		System.out.println(waysToClimb(n));
	}

	private static int waysToClimb(int n) {
		int[] dp = new int[n + 1];
		dp[0] = 1;
		dp[1] = 1;
		dp[2] = 2;
		for (int i = 3; i <= n; i++) {
			dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
		}
		return dp[n];
	}
}


 ===================================================== 


ReachAGivenScoreInMatrix.java


package Algorithms.Counting;

import java.util.Arrays;

public class ReachAGivenScoreInMatrix {
	private static int[][][] dp;

	private static int numberOfPaths(int[][] mat, int i, int j, int m) {
		if (i == 0 && j == 0) {
			if (m == mat[0][0]) {
				return 1;
			} else {
				return 0;
			}
		}

		// Sum becomes negative
		if (m < 0) {
			return 0;
		}

		if (i < 0 || j < 0) {
			return 0;
		}

		if (dp[i][j][m] != -1) {
			return dp[i][j][m];
		}

		dp[i][j][m] = numberOfPaths(mat, i - 1, j, m - mat[i][j])
				+ numberOfPaths(mat, i, j - 1, m - mat[i][j]);

		return dp[i][j][m];
	}

	public static void main(String[] args) {
		int[][] mat = {{1, 1, 1},
				{1, 1, 1},
				{1, 1, 1}};
		int m = 5, n = 3;
		dp = new int[n][n][30];
		for (int[][] arr1 : dp) {
			for (int[] arr2 : arr1) {
				Arrays.fill(arr2, -1);
			}
		}
		System.out.println(numberOfPaths(mat, n - 1, n - 1, m));
	}
}


 ===================================================== 


WaysToGenerateSum.java


package Algorithms.Counting;

public class WaysToGenerateSum {
	public static void main(String[] args) {
		int[] arr = {1, 3, 4};
		int sum = 5;
		System.out.println(generateSum(arr, arr.length, sum));
	}

	private static int generateSum(int[] arr, int n, int sum) {
		int[] dp = new int[sum + 1];
		dp[0] = 0;
		for (int i = 1; i <= sum; i++) {
			for (int j = 0; j < n; j++) {
				dp[j] += dp[j - arr[j]];
			}
		}
		return dp[sum];
	}
}


 ===================================================== 


ArrayInversion.java


/*
Formally speaking, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j
 */

package Algorithms.DivideAndConquer;

public class ArrayInversion {

}


 ===================================================== 


XRaisedToN.java


package Algorithms.DivideAndConquer;

public class XRaisedToN {
	private static int power(int x, int n) {
		int temp;
		if (n == 0) {
			return 1;
		}
		temp = power(x, n / 2);
		if (n % 2 == 0) {
			return temp * temp;
		} else {
			return x * temp * temp;
		}
	}

	public static void main(String[] args) {
		System.out.println(power(5, 3));
	}
}


 ===================================================== 


BinaryStringWithoutConsecutiveOnes.java


/*
Approach =>
The approach here is to find Fibonacci on n
 */

package Algorithms.DynamicProgramming;

public class BinaryStringWithoutConsecutiveOnes {
	public static void main(String[] args) {
		int n = 5;
		System.out.println(getAnswer(n));
	}

	private static int getAnswer(int n) {
		int[] fibonacci = new int[n + 3];
		fibonacci[0] = 0;
		fibonacci[1] = 1;
		for (int i = 2; i <= n + 2; i++) {
			fibonacci[i] = fibonacci[i - 1] + fibonacci[i - 2];
		}
		return fibonacci[n + 2];
	}
}


 ===================================================== 


binomialCoeff.java


package Algorithms.DynamicProgramming;

public class binomialCoeff {
	public static void main(String[] args) {
		System.out.println(returnCoeff(4, 2));
	}

	private static int returnCoeff(int n, int k) {
		int[][] c = new int[n + 1][k + 1];
		for (int i = 0; i <= n; i++) {
			for (int j = 0; j <= Math.min(i, k); j++) {
				if (i == 0 || j == 0) {
					c[i][j] = 1;
				} else {
					c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
				}
			}
		}
		return c[n][k];
	}
}


 ===================================================== 


BoxStackingProblem.java


package Algorithms.DynamicProgramming;

import java.util.Arrays;

public class BoxStackingProblem {
	public static void main(String[] args) {
		Box[] arr = new Box[4];
		arr[0] = new Box(4, 6, 7);
		arr[1] = new Box(1, 2, 3);
		arr[2] = new Box(4, 5, 6);
		arr[3] = new Box(10, 12, 32);
		System.out.println(getMaxHeight(arr, arr.length));
	}

	private static int getMaxHeight(Box[] arr, int n) {
		Box[] rot = new Box[3 * n];
		int i;
		for (i = 0; i < n; i++) {
			Box box = arr[i];
			rot[3 * i] = new Box(box.h, Math.min(box.w, box.d), Math.max(box.w, box.d));
			rot[3 * i + 1] = new Box(box.w, Math.min(box.h, box.d), Math.max(box.h, box.d));
			rot[3 * i + 2] = new Box(box.d, Math.min(box.w, box.h), Math.max(box.w, box.h));
		}
		for (i = 0; i < 3 * n; i++) {
			rot[i].area = rot[i].w * rot[i].d;
		}
		Arrays.sort(rot);

		int count = 3 * n;
		int[] msh = new int[count];
		for (i = 0; i < count; i++) {
			msh[i] = rot[i].h;
		}
		int j, val;
		Box box, prevBox;
		for (i = 0; i < count; i++) {
			msh[i] = 0;
			box = rot[i];
			val = 0;
			for (j = 0; j < i; j++) {
				prevBox = rot[j];
				if (box.w < prevBox.w && box.d < prevBox.d) {
					val = Math.max(val, msh[j]);
				}
			}
			msh[i] = val + box.h;
		}
		int max = -1;
		for (i = 0; i < count; i++) {
			max = Math.max(max, msh[i]);
		}

		return max;
	}

	static class Box implements Comparable<Box> {
		int h, w, d, area;

		public Box(int h, int w, int d) {
			this.h = h;
			this.w = w;
			this.d = d;
		}

		@Override
		public int compareTo(Box o) {
			return o.area - this.area;
		}
	}
}


 ===================================================== 


ChainProblem.java


package Algorithms.DynamicProgramming;

import java.util.Arrays;
import java.util.Map;
import java.util.TreeMap;

public class ChainProblem {
	public static void main(String[] args) {
		int[][] arr = {
				{5, 24}, {39, 60}, {15, 28}, {27, 40}, {50, 90}
		};
		System.out.println(chains(arr, arr.length));
	}

	private static int chains(int[][] arr, int n) {
		TreeMap<Integer, Integer> map = new TreeMap<>();
		for (int[] i : arr) {
			map.put(i[0], i[1]);
		}
		Pair[] vals = new Pair[n];
		int index = 0;
		for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
			vals[index++] = new Pair(entry.getKey(), entry.getValue());
		}
		int max = 0;
		int[] lis = new int[n];
		Arrays.fill(lis, 1);
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				if (vals[j].b < vals[i].a && lis[i] < lis[j] + 1) {
					lis[i] = lis[j] + 1;
				}
			}
			max = Math.max(lis[i], max);
		}
		return max;
	}

	static class Pair {
		int a, b;

		public Pair(int a, int b) {
			this.a = a;
			this.b = b;
		}
	}
}


 ===================================================== 


CuttingARod.java


package Algorithms.DynamicProgramming;

public class CuttingARod {
	public static void main(String[] args) {
		int[] arr = {1, 5, 8, 9, 10, 17, 17, 20};
		System.out.println(maxProfit(arr, arr.length));
	}

	private static int maxProfit(int[] price, int length) {
		int[] val = new int[length + 1];
		val[0] = 0;
		for (int i = 1; i <= length; i++) {
			int max = Integer.MIN_VALUE;
			for (int j = 0; j < i; j++) {
				max = Math.max(price[j] + val[i - j - 1], max);
			}
			val[i] = max;
		}
		return val[length];
	}
}


 ===================================================== 


editDistance.java


package Algorithms.DynamicProgramming;

public class editDistance {
	public static void main(String[] args) {
		String a = "CART", b = "MARCH";
		System.out.println(findEditDistance(a, b, a.length(), b.length()));
	}

	private static int findEditDistance(String s1, String s2, int m, int n) {
		int[][] dp = new int[m + 1][n + 1];
		for (int i = 0; i <= m; i++) {
			for (int j = 0; j <= n; j++) {
				if (i == 0) {
					dp[i][j] = j;
				} else if (j == 0) {
					dp[i][j] = i;
				} else {
					if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
						dp[i][j] = dp[i - 1][j - 1];
					} else {
						dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]),
								dp[i - 1][j - 1]) + 1;
					}
				}
			}
		}
		return dp[m][n];
	}
}


 ===================================================== 


EggDropping.java


package Algorithms.DynamicProgramming;

public class EggDropping {
	public static void main(String[] args) {
		System.out.println(minAttempts(2, 36));
	}

	private static int minAttempts(int n, int k) {
		int[][] egg = new int[n + 1][k + 1];
		int res;
		for (int i = 1; i <= n; i++) {
			egg[i][1] = 1;
			egg[i][0] = 0;
		}
		for (int i = 1; i <= k; i++) {
			egg[1][i] = i;
		}

		for (int i = 2; i <= n; i++) {
			for (int j = 2; j <= k; j++) {
				egg[i][j] = Integer.MAX_VALUE;
				for (int x = 1; x <= j; x++) {
					res = 1 + Math.max(egg[i - 1][x - 1], egg[i][j - x]);
					if (res < egg[i][j]) {
						egg[i][j] = res;
					}
				}
			}
		}
		return egg[n][k];
	}
}


 ===================================================== 


Knapsack01.java


package Algorithms.DynamicProgramming;

public class Knapsack01 {
	public static void main(String[] args) {
		int[] val = {60, 100, 120};
		int[] wt = {10, 20, 30};
		int W = 50;
		int n = val.length;
		System.out.println(knapsack(W, wt, val, n));
	}

	private static int knapsack(int W, int[] wt, int[] val, int items) {
		int[][] kp = new int[items + 1][W + 1];
		int i, j;
		for (i = 0; i <= items; i++) {
			for (j = 0; j <= W; j++) {
				if (i == 0 || j == 0) {
					kp[i][j] = 0;
				} else if (wt[i - 1] <= j) {
					kp[i][j] = Math.max(
							kp[i - 1][j],
							val[i - 1] + kp[i - 1][j - wt[i - 1]]
					);
				} else {
					kp[i][j] = kp[i - 1][j];
				}
			}
		}
		return kp[items][W];
	}
}


 ===================================================== 


LongestBitonicSubsequence.java


package Algorithms.DynamicProgramming;

import java.util.Arrays;

public class LongestBitonicSubsequence {
	public static void main(String[] args) {
//		int[] arr = {80, 60, 30, 40, 20, 10};
		int[] arr = {0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5,
				13, 3, 11, 7, 15};
		System.out.println(bitonic(arr, arr.length));
	}

	private static int bitonic(int[] arr, int n) {
		int[] lis = lis(arr, n), lds = lds(arr, n);
		int max = lis[0] + lds[0] - 1;
		for (int i = 1; i < n; i++) {
			max = Math.max(max, lis[i] + lds[i] - 1);
		}
		return max;
	}

	private static int[] lis(int[] arr, int n) {
		int[] lis = new int[n];
		Arrays.fill(lis, 1);
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				if (arr[j] < arr[i] && lis[i] < lis[j] + 1) {
					lis[i] = lis[j] + 1;
				}
			}
		}
		return lis;
	}

	private static int[] lds(int[] arr, int n) {
		int[] lds = new int[n];
		Arrays.fill(lds, 1);
		for (int i = n - 2; i >= 0; i--) {
			for (int j = n - 1; j > i; j--) {
				if (arr[j] < arr[i] && lds[i] < lds[j] + 1) {
					lds[i] = lds[j] + 1;
				}
			}
		}
		return lds;
	}
}


 ===================================================== 


longestCommonSubsequence.java


package Algorithms.DynamicProgramming;

public class longestCommonSubsequence {
	private static int[][] table;

	public static void main(String[] args) {
//		String X = "AGGTAB";
//		String Y = "GXTXAYB";
//		int m = X.length();
//		int n = Y.length();
		String X = "ABCDGH";
		String Y = "ACDGHR";
		int m = X.length();
		int n = Y.length();
		System.out.println(lengthOfLCS(X, Y, m, n));
		System.out.println(findLCS(X, Y, m, n));
	}

	private static int lengthOfLCS(String a, String b, int m, int n) {
		table = new int[m + 1][n + 1];
		for (int i = 1; i <= m; i++) {
			for (int j = 1; j <= n; j++) {
				if (i == 0 || j == 0) {
					table[i][j] = 0;
				}
				if (a.charAt(i - 1) == b.charAt(j - 1)) {
					table[i][j] = table[i - 1][j - 1] + 1;
				} else {
					table[i][j] = Math.max(table[i - 1][j], table[i][j - 1]);
				}
			}
		}
		return table[m][n];
	}

	private static String findLCS(String a, String b, int m, int n) {
		String lcs = "";
		int i = m, j = n;
		while (i > 0 && j > 0) {
			if (a.charAt(i - 1) == b.charAt(j - 1)) {
				lcs = a.charAt(i - 1) + lcs;
				i--;
				j--;
			} else if (table[i - 1][j] > table[i][j - 1]) {
				i--;
			} else {
				j--;
			}
		}
		return lcs;
	}
}


 ===================================================== 


LongestConsecutivePath.java


package Algorithms.DynamicProgramming;

import java.util.Arrays;

public class LongestConsecutivePath {
	private static final int[] rowMod = {0, 1, 1, -1, 1, 0, -1, -1},
			colMod = {1, 0, 1, 1, -1, -1, 0, -1};
	private static int R, C;
	private static int[][] dp;

	private static boolean isAdjacent(char prev, char curr) {
		return ((curr - prev) == 1);
	}

	private static boolean isValid(int i, int j) {
		return i >= 0 && j >= 0 && i < R && j < C;
	}

	private static int lengthRecur(char[][] mat, int i, int j, char prev) {
		if (!isValid(i, j) || !isAdjacent(prev, mat[i][j])) {
			return 0;
		}

		if (dp[i][j] != -1) {
			return dp[i][j];
		}

		int ans = 0;
		for (int k = 0; k < 8; k++) {
			ans = Math.max(ans, 1 + lengthRecur(mat, i + rowMod[k],
					j + colMod[k], mat[i][j]));
		}
		dp[i][j] = ans;
		return ans;
	}

	private static int getLength(char[][] mat, char s, int m, int n) {
		R = m;
		C = n;
		dp = new int[R][C];
		int ans = 0;
		for (int i = 0; i < R; i++) {
			Arrays.fill(dp[i], -1);
		}
		for (int i = 0; i < R; i++) {
			for (int j = 0; j < C; j++) {
				if (mat[i][j] == s) {
					for (int k = 0; k < 8; k++) {
						ans = Math.max(ans, 1 + lengthRecur(mat, i + rowMod[k],
								j + colMod[k], s));
					}
				}
			}
		}
		return ans;
	}

	public static void main(String[] args) {
		char[][] mat = {{'a', 'c', 'd'},
				{'h', 'b', 'a'},
				{'i', 'g', 'f'}};

		int r = 3, c = 3;
		System.out.println(getLength(mat, 'a', r, c));
		System.out.println(getLength(mat, 'e', r, c));
		System.out.println(getLength(mat, 'b', r, c));
		System.out.println(getLength(mat, 'f', r, c));
	}
}


 ===================================================== 


longestIncreasingSubsequence.java


package Algorithms.DynamicProgramming;

import java.util.Arrays;

public class longestIncreasingSubsequence {
	public static void main(String[] args) {
		int[] arr = {10, 22, 9, 33, 21, 50, 41, 60};
		System.out.println(lis(arr, arr.length));
	}

	private static int lis(int[] arr, int n) {
		int[] lis = new int[n];
		int max = 1;
		Arrays.fill(lis, 1);
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				if (arr[j] < arr[i] && lis[i] < lis[j] + 1) {
					lis[i] = lis[j] + 1;
				}
				if (max < lis[i]) {
					max = lis[i];
				}
			}
		}
		return max;
	}
}


 ===================================================== 


LongestPalindromicString.java


package Algorithms.DynamicProgramming;

public class LongestPalindromicString {
	public static void main(String[] args) {
		System.out.println(longestPalindromic("forgeeksskeegfor"));
	}

	private static int longestPalindromic(String str) {
		int n = str.length();
		boolean[][] table = new boolean[n][n];
		for (int i = 0; i < n; i++) {
			table[i][i] = true;
		}
		int maxlength = 0, start = 0;

		for (int i = 0; i < n - 1; ++i) {
			if (str.charAt(i) == str.charAt(i + 1)) {
				table[i][i + 1] = true;
				start = i;
				maxlength = 2;
			}
		}
		for (int k = 3; k <= n; k++) {
			for (int i = 0; i < n - k + 1; i++) {
				int j = i + k - 1;
				if (table[i + 1][j - 1] && str.charAt(i) == str.charAt(j)) {
					table[i][j] = true;
					if (maxlength < k) {
						start = i;
						maxlength = k;
					}
				}
			}
		}
		System.out.println(str.substring(start, start + maxlength));
		return maxlength;
	}
}


 ===================================================== 


MatrixChainMultiplication.java


package Algorithms.DynamicProgramming;

public class MatrixChainMultiplication {
	public static void main(String[] args) {
		int[] arr = {10, 20, 30, 40, 30};
		System.out.println(matrixChain(arr, arr.length));
	}

	private static int matrixChain(int[] p, int n) {
		int[][] dp = new int[n][n];
		int i, l;
		for (i = 0; i < n; i++)
			dp[i][i] = 0;
		for (l = 1; l < n - 1; l++)
			for (i = 1; i < n - l; i++)
				dp[i][i + l] = Math.min(
						dp[i + 1][i + l] + p[i - 1] * p[i] * p[i + l],
						dp[i][i + l - 1] + p[i - 1] * p[i + l - 1] * p[i + l]
				);

		return dp[1][n - 1];
	}
}


 ===================================================== 


MaxProfitByBuyingAndSellingShares.java


package Algorithms.DynamicProgramming;

public class MaxProfitByBuyingAndSellingShares {
	public static void main(String[] args) {
//		int[] price = {2, 30, 15, 10, 8, 25, 80};
		int[] price = {100, 30, 15, 10, 8, 25, 80};
		System.out.println(maxProfit(price, price.length));
	}

	private static int maxProfit(int[] price, int n) {
		int[] profit = new int[n];
		int max, min, i;
		max = price[n - 1];
		for (i = n - 2; i >= 0; i--) {
			if (price[i] > max) {
				max = price[i];
			}
			profit[i] = Math.max(profit[i + 1], max - price[i]);
		}
		min = price[0];
		for (i = 1; i < n; i++) {
			if (price[i] < min) {
				min = price[i];
			}
			profit[i] = Math.max(profit[i - 1], profit[i] + (price[i] - min));
		}
		return profit[n - 1];
	}
}


 ===================================================== 


MinCostToReachDestination.java


package Algorithms.DynamicProgramming;

import java.util.Arrays;

public class MinCostToReachDestination {
	private static final int INF = 99999;

	public static void main(String[] args) {
		int[][] cost = {
				{0, 15, 80, 90},
				{INF, 0, 40, 50},
				{INF, INF, 0, 70},
				{INF, INF, INF, 0}
		};
		System.out.println(getMinCost(cost, cost.length));
	}

	private static int getMinCost(int[][] cost, int n) {
		int[] dist = new int[n];
		Arrays.fill(dist, INF);
		dist[0] = 0;
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				if (dist[j] > dist[i] + cost[i][j])
					dist[j] = dist[i] + cost[i][j];
			}
		}
		return dist[n - 1];
	}
}


 ===================================================== 


MinimumCostPath.java


package Algorithms.DynamicProgramming;

public class MinimumCostPath {
	public static void main(String[] args) {
		int[][] cost = {
				{1, 2, 3},
				{4, 8, 2},
				{1, 5, 3}
		};
		System.out.println(minimumCostPath(cost, 3, 3));
	}

	private static int minimumCostPath(int[][] arr, int m, int n) {
		int[][] cost = new int[m + 1][n + 1];
		int i, j;
		for (i = 1; i <= m; i++) {
			cost[i][0] = arr[i - 1][0];
		}
		for (j = 1; j < n; j++) {
			cost[0][j] = arr[0][j - 1];
		}
		cost[0][0] = 0;
		for (i = 1; i <= m; i++) {
			for (j = 1; j <= n; j++) {
				cost[i][j] = arr[i - 1][j - 1] +
						Math.min(
								Math.min(cost[i - 1][j - 1], cost[i - 1][j]),
								cost[i][j - 1]);
			}
		}
		return cost[m][n];
	}
}


 ===================================================== 


MinJumpsTillEnd.java


package Algorithms.DynamicProgramming;

import java.util.Arrays;

public class MinJumpsTillEnd {
	public static void main(String[] args) {
//		int[] arr = {1, 3, 6, 1, 0, 9};
//		int[] arr = {3, 2, 1, 0, 4};
		int[] arr = {2, 3, 1, 1, 4};
		System.out.println(minJump(arr, arr.length));
	}

	private static int minJump(int[] arr, int n) {
		int[] jumps = new int[n + 1];
		int maxer = 99999999;
		Arrays.fill(jumps, maxer);
		jumps[0] = 0;
		for (int i = 1; i < n; i++) {
			for (int j = 0; j < i; j++) {
				if (i <= j + arr[j] && jumps[j] != maxer) {
					jumps[i] = Math.min(jumps[i], jumps[j] + 1);
					break;
				}
			}
		}
		return jumps[n - 1];
	}
}


 ===================================================== 


MinNumberOfSquaresForGivenSum.java


package Algorithms.DynamicProgramming;

public class MinNumberOfSquaresForGivenSum {
	public static void main(String[] args) {
		int n = 6;
		System.out.println(getSquares(n));
	}

	private static int getSquares(int n) {
		if (n <= 3) {
			return n;
		}

		int[] dp = new int[n + 1];
		dp[0] = 0;
		dp[1] = 1;
		dp[2] = 2;
		dp[3] = 3;
		int temp;
		for (int i = 4; i <= n; i++) {
			dp[i] = i;
			for (int x = 1; x <= Math.ceil(Math.sqrt(i)); x++) {
				temp = x * x;
				if (temp > i) {
					break;
				} else {
					dp[i] = Math.min(dp[i], dp[i - temp] + 1);
				}
			}
		}
		return dp[n];
	}
}


 ===================================================== 


NumberOfNonDecreasingNumbers.java


package Algorithms.DynamicProgramming;

public class NumberOfNonDecreasingNumbers {
	public static void main(String[] args) {
		System.out.println(getNumber(1));
		System.out.println(getNumber(2));
		System.out.println(getNumber(3));
	}

	private static long getNumber(int n) {
		if (n == 1) {
			return 10L;
		}

		long count = 1L, N = 10;
		for (int i = 1; i <= n; i++) {
			count *= (N + i - 1);
			count /= i;
		}
		return count;
	}
}


 ===================================================== 


PartitionProblem.java


package Algorithms.DynamicProgramming;

public class PartitionProblem {
	public static void main(String[] args) {
		int[] arr = {3, 1, 1, 2, 2, 1};
		int n = arr.length;
		System.out.println(partition(arr, n));
	}

	private static boolean partition(int[] arr, int n) {
		int sum = 0;
		int i, j;
		for (int x : arr) {
			sum += x;
		}
		if (sum % 2 != 0) {
			return false;
		}

		boolean[][] part = new boolean[sum / 2 + 1][n + 1];
		for (i = 0; i <= n; i++) {
			part[0][i] = true;
		}
		for (j = 1; j <= sum / 2; j++) {
			part[j][0] = false;
		}
		for (i = 1; i <= sum / 2; i++) {
			for (j = 1; j <= n; j++) {
				part[i][j] = part[i][j - 1];
				if (i >= arr[j - 1]) {
					part[i][j] = part[i][j - 1] ||
							part[i - arr[j - 1]][j - 1];
				}
			}
		}
		return part[sum / 2][n];
	}
}


 ===================================================== 


SameSumTwoHalvesSubstring.java


package Algorithms.DynamicProgramming;

public class SameSumTwoHalvesSubstring {
	public static void main(String[] args) {
		String str = "153803";
		System.out.println(findLength(str, str.length()));
	}

	private static int findLength(String str, int n) {
		int[] sum = new int[n + 1];
		int ans = 0, i, j, len;
		sum[0] = 0;
		for (i = 1; i <= n; i++) {
			sum[i] = sum[i - 1] + (str.charAt(i - 1) - '0');
		}
		for (len = 2; len <= n; len++) { // length of substring
			for (i = 0; i <= n - len; i++) {
				if ((sum[i + len / 2] - sum[i]) == (sum[i + len] - sum[i + len / 2])) {
					ans = Math.max(ans, len);
				}
			}
		}
		return ans;
	}
}


 ===================================================== 


UglyNumber.java


package Algorithms.DynamicProgramming;

public class UglyNumber {
	public static void main(String[] args) {
		int[] arr = {7, 10, 15, 150};
		for (int i : arr) {
			System.out.println(getUgly(i));
		}
	}

	private static int getUgly(int n) {
		int[] ugly = new int[n];
		int i2, i3, i5;
		i2 = i3 = i5 = 0;
		ugly[0] = 1;
		int m2 = ugly[i2] * 2,
				m3 = ugly[i3] * 3,
				m5 = ugly[i5] * 5;
		int next = 0;
		for (int i = 1; i < n; i++) {
			next = Math.min(Math.min(m2, m3), m5);
			ugly[i] = next;
			if (m2 == next) {
				i2++;
				m2 = ugly[i2] * 2;
			}
			if (m3 == next) {
				i3++;
				m3 = ugly[i3] * 3;
			}
			if (m5 == next) {
				i5++;
				m5 = ugly[i5] * 5;
			}
		}
		return next;
	}
}


 ===================================================== 


WeightedJobScheduling.java


package Algorithms.DynamicProgramming;

import java.util.Arrays;

public class WeightedJobScheduling {
	public static void main(String[] args) {
		Job[] jobs = {
				new Job(1, 2, 50),
				new Job(3, 5, 20),
				new Job(6, 19, 100),
				new Job(2, 100, 200)
		};
		System.out.println(getMaxProfit(jobs, jobs.length));
	}

	private static int getMaxProfit(Job[] jobs, int n) {
		Arrays.sort(jobs);
		int[] table = new int[n];
		table[0] = jobs[0].profit;
		int inclProfit, l;
		for (int i = 1; i < n; i++) {
			inclProfit = jobs[i].profit;
			l = findNonConflict(jobs, i);
			if (l != -1) {
				inclProfit += table[l];
			}
			table[i] = Math.max(inclProfit, table[i - 1]);
		}
		return table[n - 1];
	}

	private static int findNonConflict(Job[] jobs, int i) {
		int l = 0, h = i - 1, mid;
		while (l <= h) {
			mid = (l + h) / 2;
			if (jobs[mid].finish <= jobs[i].start) {
				if (jobs[mid + 1].finish <= jobs[i].start) {
					l = mid + 1;
				} else {
					return mid;
				}
			} else {
				h = mid - 1;
			}
		}
		return -1;
	}

	static class Job implements Comparable<Job> {
		int start, finish, profit;

		public Job(int start, int finish, int profit) {
			this.start = start;
			this.finish = finish;
			this.profit = profit;
		}

		@Override
		public int compareTo(Job o) {
			return this.finish - o.finish;
		}
	}
}


 ===================================================== 


ActivitySelection.java


package Algorithms.Greedy;

import java.util.Arrays;

public class ActivitySelection {
	public static void main(String[] args) {
		int[] s = {1, 3, 0, 5, 8, 5};
		int[] f = {2, 4, 6, 7, 9, 9};
		int[][] arr = new int[s.length][s.length];
		for (int i = 0; i < s.length; i++) {
			arr[i][0] = s[i];
			arr[i][1] = f[i];
		}
		printJobs(arr, s.length);
	}

	private static void printJobs(int[][] arr, int n) {
		Job[] jobs = new Job[n];
		for (int i = 0; i < n; i++) {
			jobs[i] = new Job(arr[i][0], arr[i][1], i + 1);
		}
		Arrays.sort(jobs);
		int[] result = new int[n];
		result[0] = jobs[0].id;
		int i = 0, index = 1;
		for (int j = 1; j < n; j++) {
			if (jobs[j].start >= jobs[i].finish) {
				i = j;
				result[index++] = jobs[j].id;
			}
		}

		System.out.println("Total Number of Jobs done = " + index);
		System.out.print("Jobs Done => ");
		for (i = 0; i < index; i++) {
			System.out.print(result[i] + " ");
		}
	}

	static class Job implements Comparable<Job> {
		int start, finish, id;

		public Job(int start, int finish, int id) {
			this.start = start;
			this.finish = finish;
			this.id = id;
		}

		@Override
		public int compareTo(Job j) {
			return this.finish - j.finish; // this - o => Ascending
		}
	}
}


 ===================================================== 


JobSelectionMaxProfitDeadline.java


package Algorithms.Greedy;

import java.util.Arrays;

public class JobSelectionMaxProfitDeadline {
	public static void main(String[] args) {
		int[][] arr = {{1, 2, 100}, {2, 1, 19}, {3, 2, 27},
				{4, 1, 25}, {5, 3, 15}};
		doJobs(arr, arr.length);
	}

	private static void doJobs(int[][] jobList, int n) {
		int i;
		Job[] jobs = new Job[n];
		for (i = 0; i < n; i++) {
			jobs[i] = new Job(jobList[i][0], jobList[i][1], jobList[i][2]);
		}
		int[] result = new int[n];
		boolean[] slot = new boolean[n];
		Arrays.sort(jobs);

		for (i = 0; i < n; i++) { // for all jobs
			for (int j = Math.min(n, jobs[i].dead) - 1;
				 j >= 0; j--) { // assign the farthest slot
				if (!slot[j]) {
					slot[j] = true;
					result[j] = i; // farthest slot is assigned.. now check for another
					break;
				}
			}
		}

		int maxProfit = 0;
		System.out.print("Job Sequence => ");
		for (i = 0; i < n; i++) {
			if (slot[i]) {
				System.out.print(jobs[result[i]].id + " ");
				maxProfit += jobs[result[i]].profit;
			}
		}
		System.out.print("\nMaximum Profit = " + maxProfit);
	}

	static class Job implements Comparable<Job> {
		int id, dead, profit;

		public Job(int id, int dead, int profit) {
			this.id = id;
			this.dead = dead;
			this.profit = profit;
		}

		@Override
		public int compareTo(Job o) {
			return o.profit - this.profit;
		}
	}
}


 ===================================================== 


BinarySearch.java


package Algorithms.Searching;

import java.util.Arrays;

@SuppressWarnings("Duplicates")
public class BinarySearch {
	public static void main(String[] args) {
		int[] arr = {10, 15, 19, 23, 48, 26, 54};
		int element = 26;
		System.out.println(binarySearch(arr, arr.length, element));
	}

	private static int binarySearch(int[] arr, int n, int element) {
		Arrays.sort(arr);
		int low = 0, high = n - 1, mid;
		while (low <= high) {
			mid = (low + high) / 2;
			if (arr[mid] == element) {
				return mid + 1;
			} else if (element < arr[mid]) {
				high = mid - 1;
			} else {
				low = mid + 1;
			}
		}
		return -1;
	}
}


 ===================================================== 


InterpolationSearch.java


package Algorithms.Searching;

@SuppressWarnings("Duplicates")
public class InterpolationSearch {
	public static void main(String[] args) {
		int[] arr = {10, 15, 19, 23, 26, 48, 54, 60};
		int element = 60;
		System.out.println(interpolation(arr, arr.length, element));
	}

	private static int interpolation(int[] arr, int n, int element) {
		int pos, lo = 0, hi = n - 1;
		while (lo <= hi) {
			if (lo == hi) {
				if (arr[lo] == element) {
					return lo;
				} else {
					return -1;
				}
			}
			pos = lo + (element - arr[lo]) * (hi - lo) / (arr[hi] - arr[lo]);
			if (arr[pos] == element) {
				return pos;
			}
			if (element > arr[pos]) {
				lo = pos + 1;
			} else {
				hi = pos - 1;
			}
		}
		return -1;
	}
}


 ===================================================== 


JumpSearch.java


package Algorithms.Searching;

import java.util.Arrays;

@SuppressWarnings("Duplicates")
public class JumpSearch {
	public static void main(String[] args) {
		int[] arr = {10, 15, 19, 23, 26, 48, 54, 60};
		int element = 60;
		System.out.println(jumpSearch(arr, arr.length, element));
	}

	private static int jumpSearch(int[] arr, int n, int element) {
		Arrays.sort(arr);
		int m = (int) Math.floor(Math.sqrt(n));
		for (int i = 1; i <= n / m + 1; i++) {
			if ((i * m) < n && element <= arr[i * m]) {
				if (element == arr[i * m]) {
					return i * m + 1;
				}
				for (int j = (i - 1) * m; j < Math.min(i * m, n); j++) {
					if (arr[j] == element) {
						return j + 1;
					}
				}
			}
		}
		return -1;
	}
}


 ===================================================== 


LinearSearch.java


package Algorithms.Searching;

@SuppressWarnings("Duplicates")
public class LinearSearch {
	public static void main(String[] args) {
		int[] arr = {10, 23, 19, 15, 48, 26, 54};
		int element = 26;
		System.out.println(linearSearch(arr, arr.length, element));
	}

	private static int linearSearch(int[] arr, int n, int element) {
		for (int i = 0; i < n; i++) {
			if (arr[i] == element) {
				return i + 1;
			}
		}
		return -1;
	}
}


 ===================================================== 


TernarySearch.java


package Algorithms.Searching;

public class TernarySearch {
	public static void main(String[] args) {
		int[] arr = {10, 15, 19, 23, 26, 48, 54, 60};
		int element = 60;
		System.out.println(ternary(arr, arr.length, element, 0, arr.length - 1));
	}

	private static int ternary(int[] arr, int n, int element, int l, int r) {
		if (r >= l) {
			int mid1 = l + (r - l) / 3;
			int mid2 = mid1 + (r - l) / 3;
			if (arr[mid1] == element)
				return mid1;
			if (arr[mid2] == element)
				return mid2;
			if (element < mid1) {
				return ternary(arr, n, element, l, mid1 - 1);
			}
			if (element > mid2) {
				return ternary(arr, n, element, mid2 + 1, r);
			}
			return ternary(arr, n, element, mid1 + 1, mid1 - 1);
		}
		return -1;
	}
}


 ===================================================== 


BinarySearchInAlmostSortedArray.java


package Algorithms.Sorting;

public class BinarySearchInAlmostSortedArray {
	public static void main(String[] args) {
		int[] arr = {10, 3, 40, 20, 50, 80, 70};
		int key = 40;
		System.out.println(findElement(arr, arr.length, key));
	}

	private static int findElement(int[] arr, int n, int ele) {
		int lo = 0, hi = n - 1, mid;
		while (lo <= hi) {
			mid = (lo + hi) / 2;
			if (arr[mid] == ele) {
				return mid;
			}
			if (mid + 1 < n && arr[mid + 1] == ele) {
				return mid + 1;
			}
			if (mid - 1 > 0 && arr[mid - 1] == ele) {
				return mid - 1;
			}
			if (ele < arr[mid]) {
				hi = mid - 1;
			}
			if (ele > arr[mid]) {
				lo = mid + 1;
			}
		}
		return -1;
	}
}


 ===================================================== 


BubbleSort.java


package Algorithms.Sorting;

import Commons.ArrayPrinter;

public class BubbleSort {
	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		int[] arr = {10, 23, 19, 15, 48, 26, 54};
		new ArrayPrinter().printArray(bubbleSort(arr, arr.length), arr.length);
	}

	private static int[] bubbleSort(int[] arr, int n) {
		int temp;
		for (int i = 0; i < n - 1; i++) {
			for (int j = 0; j < n - i - 1; j++) {
				if (arr[j] > arr[j + 1]) {
					temp = arr[j + 1];
					arr[j + 1] = arr[j];
					arr[j] = temp;
				}
			}
		}
		return arr;
	}
}


 ===================================================== 


ClosestPairSum.java


package Algorithms.Sorting;

public class ClosestPairSum {
	public static void main(String[] args) {
		int[] ar1 = {1, 4, 5, 7};
		int[] ar2 = {10, 20, 30, 40};
		int m = ar1.length;
		int x = 38;
		showPair(ar1, ar2, m, x);
	}

	private static void showPair(int[] arr1, int[] arr2, int n, int sum) {
		int a1 = 0, a2 = n - 1, diff = Integer.MAX_VALUE;
		int r1 = 0, r2 = 0;
		while (a1 < n && a2 >= 0) {
			if (arr1[a1] + arr2[a2] - sum < diff) {
				diff = arr1[a1] + arr2[a2] - sum;
				r1 = a1;
				r2 = a2;
			}
			if (arr1[a1] + arr2[a2] < sum) {
				a1++;
			} else {
				a2--;
			}
		}
		System.out.println("Pair => (" + arr1[r1] + "," + arr2[r2] + ")");
	}
}


 ===================================================== 


CommonElementInSortedArrays.java


package Algorithms.Sorting;

public class CommonElementInSortedArrays {
	public static void main(String[] args) {
		int[] ar1 = {1, 5, 10, 20, 40, 80};
		int[] ar2 = {6, 7, 20, 80, 100};
		int[] ar3 = {3, 4, 15, 20, 30, 70, 80, 120};
		printCommon(ar1, ar2, ar3, ar1.length, ar2.length, ar3.length);
	}

	private static void printCommon(int[] arr1, int[] arr2, int[] arr3,
									int l1, int l2, int l3) {
		int i, j, k;
		i = j = k = 0;
		while (i < l1 && j < l2 && k < l3) {
			if (arr1[i] == arr2[j] && arr2[j] == arr3[k]) {
				System.out.println(arr1[i]);
				i++;
				j++;
				k++;
			} else if (arr1[i] < arr2[j]) {
				i++;
			} else if (arr1[i] > arr3[k] && arr2[j] > arr3[k]) {
				k++;
			} else {
				j++;
			}
		}
	}
}


 ===================================================== 


FindKClosestElements.java


package Algorithms.Sorting;

public class FindKClosestElements {
	private static int findCrossOver(int[] arr, int l, int h, int x) {
		if (x >= arr[h]) {
			return h;
		}
		if (x < arr[l]) {
			return l;
		}
		int mid = (l + h) / 2;
		if (arr[mid] <= x && arr[mid + 1] > x) {
			return mid;
		}
		if (x <= arr[mid]) {
			return findCrossOver(arr, l, mid - 1, x);
		} else {
			return findCrossOver(arr, mid + 1, h, x);
		}
	}

	private static void printKClosest(int[] arr, int n, int k, int x) {
		int l = findCrossOver(arr, 0, n - 1, x), r = l + 1, count = 0;
		if (arr[l] == x) {
			l--;
		}
		while (l >= 0 && count < k && r < n) {
			if (x - arr[l] < arr[r] - x) {
				System.out.print(arr[l] + " ");
				l--;
			} else {
				System.out.print(arr[r] + " ");
				r++;
			}
			count++;
		}
		while (count < k && l >= 0) {
			System.out.print(arr[l] + " ");
			l--;
			count++;
		}
		while (count < k && r < n) {
			System.out.print(arr[r] + " ");
			r++;
			count++;
		}
	}

	public static void main(String[] args) {
		int[] arr = {12, 16, 22, 30, 35, 39, 42,
				45, 48, 50, 53, 55, 56};
		int n = arr.length;
		int x = 35, k = 4;
		printKClosest(arr, n, k, x);
	}
}


 ===================================================== 


HeapSort.java


package Algorithms.Sorting;

import Commons.ArrayPrinter;

public class HeapSort {
	private static void heapify(int[] arr, int n, int i) {
		int largest = i, left = 2 * i + 1, right = 2 * i + 2;
		if (left < n && arr[left] > arr[largest]) {
			largest = left;
		}
		if (right < n && arr[right] > arr[largest]) {
			largest = right;
		}
		if (largest != i) {
			int swap = arr[largest];
			arr[largest] = arr[i];
			arr[i] = swap;
			heapify(arr, n, largest);
		}
	}

	private static void sort(int[] arr, int n) {
		for (int i = n / 2 - 1; i >= 0; i--) {
			heapify(arr, n, i);
		}
		for (int i = n - 1; i >= 0; i--) {
			int temp = arr[0];
			arr[0] = arr[i];
			arr[i] = temp;
			heapify(arr, n, 0);
		}
		new ArrayPrinter().printArray(arr, n);
	}

	public static void main(String[] args) {
		int[] arr = {10, 23, 19, 15, 48, 26, 54};
		sort(arr, arr.length);
	}
}


 ===================================================== 


InsertionSort.java


package Algorithms.Sorting;

import Commons.ArrayPrinter;

public class InsertionSort {
	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		int[] arr = {10, 23, 19, 15, 48, 26, 54};
		new ArrayPrinter().printArray(insertionSort(arr, arr.length), arr.length);
	}

	private static int[] insertionSort(int[] arr, int n) {
		int key, j;
		for (int i = 1; i < n; i++) {
			key = arr[i];
			j = i - 1;
			/* Move elements of arr[0..i-1], that are
               greater than key, to one position ahead
               of their current position */
			while (j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j--;
			}
			arr[j + 1] = key;
		}
		return arr;
	}
}


 ===================================================== 


IterativeQuickSort.java


package Algorithms.Sorting;

import Commons.ArrayPrinter;

import java.util.Stack;

public class IterativeQuickSort {
	public static void main(String[] args) {
		int[] arr = {4, 3, 5, 2, 1, 3, 2, 3};
		int n = 8;
		quickSort(arr, 0, n - 1);
	}

	private static void quickSort(int[] arr, int l, int h) {
		Stack<Integer> stack = new Stack<>();
		stack.push(l);
		stack.push(h);
		while (!stack.isEmpty()) {
			h = stack.pop();
			l = stack.pop();
			int p = partition(arr, l, h);
			if (p - 1 > l) {
				stack.push(l);
				stack.push(p - 1);
			}
			if (p + 1 < h) {
				stack.push(p + 1);
				stack.push(h);
			}
		}
		new ArrayPrinter().printArray(arr, arr.length);
	}

	private static int partition(int[] arr, int low, int high) {
		int pivot = arr[high];
		int i = low - 1, temp;
		for (int j = low; j < high; j++) {
			if (arr[j] <= pivot) {
				i++;
				temp = arr[i];
				arr[i] = arr[j];
				arr[j] = temp;
			}
		}
		temp = arr[i + 1];
		arr[i + 1] = arr[high];
		arr[high] = temp;
		return i + 1;
	}
}


 ===================================================== 


KthSmallest.java


package Algorithms.Sorting;

public class KthSmallest {
	private static int partition(int[] arr, int lo, int hi) {
		int pivot = arr[hi];
		int i = lo - 1, temp;
		for (int j = lo; j <= hi - 1; j++) {
			if (arr[j] <= pivot) {
				i++;
				temp = arr[j];
				arr[j] = arr[i];
				arr[i] = temp;
			}
		}
		temp = arr[i + 1];
		arr[i + 1] = arr[hi];
		arr[hi] = temp;
		return i + 1;
	}

	private static int returnKth(int[] arr, int l, int r, int k) {
		if (l <= r) {
			int pi = partition(arr, l, r);
			if (pi - l == k - 1) {
				return arr[pi];
			}
			if (pi - l > k - 1) {
				return returnKth(arr, l, pi - 1, k);
			}
			return returnKth(arr, pi + 1, r, k - pi + l - 1);
		}
		return -1;
	}

	public static void main(String[] args) {
		int[] arr = {12, 3, 5, 7, 4, 19, 26};
		int k = 3;
		System.out.println(returnKth(arr, 0, arr.length - 1, k));
	}
}


 ===================================================== 


KthSmallestUsingHeap.java


package Algorithms.Sorting;

import Commons.ArrayPrinter;

public class KthSmallestUsingHeap {
	private static void heapify(int[] arr, int n, int i) {
		int largest = i, left = 2 * i + 1, right = 2 * i + 2;
		if (left < n && arr[left] > arr[largest]) {
			largest = left;
		}
		if (right < n && arr[right] > arr[largest]) {
			largest = right;
		}
		if (largest != i) {
			int swap = arr[largest];
			arr[largest] = arr[i];
			arr[i] = swap;
			heapify(arr, n, largest);
		}
	}

	private static void sort(int[] arr, int n, int k) {
		for (int i = n / 2 - 1; i >= 0; i--) {
			heapify(arr, n, i);
		}
		for (int i = n - 1; i >= 0; i--) {
			int temp = arr[0];
			arr[0] = arr[i];
			arr[i] = temp;
			heapify(arr, n, 0);
		}
		new ArrayPrinter().printArray(arr, n);
//		System.out.println(arr[n-k]);
	}

	public static void main(String[] args) {
		int[] arr = {10, 23, 19, 15, 48, 26, 54};
		int k = 1;
		sort(arr, arr.length, k);
	}
}


 ===================================================== 


MergeSort.java


/*
MergeSort(arr[], l,  r)
If r > l
     1. Find the middle point to divide the array into two halves:
             middle m = (l+r)/2
     2. Call mergeSort for first half:
             Call mergeSort(arr, l, m)
     3. Call mergeSort for second half:
             Call mergeSort(arr, m+1, r)
     4. Merge the two halves sorted in step 2 and 3:
             Call merge(arr, l, m, r)
 */

package Algorithms.Sorting;

import Commons.ArrayPrinter;

public class MergeSort {
	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		int[] arr = {10, 23, 19, 15, 48, 26, 54};
		new ArrayPrinter().printArray(driver(arr, arr.length), arr.length);
	}

	private static int[] driver(int[] arr, int n) {
		mergeSort(arr, 0, n - 1);
		return arr;
	}

	private static void mergeSort(int[] arr, int l, int r) {
		if (l < r) {
			int mid = (l + r) / 2;
			mergeSort(arr, l, mid);
			mergeSort(arr, mid + 1, r);
			merge(arr, l, mid, r);
		}
	}

	private static void merge(int[] arr, int l, int mid, int r) {
		int n1 = mid - l + 1, n2 = r - mid, i, j;
		int[] L = new int[n1];
		int[] R = new int[n2];
		for (i = 0; i < n1; i++) {
			L[i] = arr[i + l];
		}
		for (j = 0; j < n2; j++) {
			R[j] = arr[mid + 1 + j];
		}
		i = j = 0;
		int k = l;
		while (i < n1 && j < n2) {
			if (L[i] <= R[j]) {
				arr[k] = L[i];
				i++;
			} else {
				arr[k] = R[j];
				j++;
			}
			k++;
		}
		/* Copy remaining elements of L[] if any */
		while (i < n1) {
			arr[k] = L[i];
			i++;
			k++;
		}

		/* Copy remaining elements of R[] if any */
		while (j < n2) {
			arr[k] = R[j];
			j++;
			k++;
		}
	}
}


 ===================================================== 


MergeSortLinkedList.java


package Algorithms.Sorting;

import Commons.ListNode;

public class MergeSortLinkedList {
	private static ListNode mergeSort(ListNode head) {
		if (head == null || head.next == null) {
			return head;
		}
		ListNode middle = getMiddle(head);
		ListNode nextMiddle = middle.next;
		middle.next = null;
		ListNode left = mergeSort(head);
		ListNode right = mergeSort(nextMiddle);

		return sortedMerge(left, right);
	}

	private static ListNode getMiddle(ListNode head) {
		if (head == null) {
			return head;
		}
		ListNode slow = head, fast = head;
		while (fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		return slow;
	}

	private static ListNode sortedMerge(ListNode left, ListNode right) {
		ListNode result;
		if (left == null) {
			return right;
		}
		if (right == null) {
			return left;
		}
		if (left.data <= right.data) {
			result = left;
			result.next = sortedMerge(left.next, right);
		} else {
			result = right;
			result.next = sortedMerge(left, right.next);
		}
		return result;
	}

	public static void main(String[] args) {
		ListNode li = new ListNode();
		li.push(15);
		li.push(10);
		li.push(5);
		li.push(20);
		li.push(3);
		li.push(2);
		li.head = mergeSort(li.head);
		li.printList();
	}
}


 ===================================================== 


MinLengthUnsortedArray.java


package Algorithms.Sorting;

import Commons.ArrayPrinter;

public class MinLengthUnsortedArray {
	public static void main(String[] args) {
		int[] arr = {10, 12, 20, 30, 25, 40, 32, 31, 35, 50, 60};
		int arr_size = arr.length;
		getMinUnsorted(arr, arr_size);
	}

	private static void getMinUnsorted(int[] arr, int n) {
		int s = 0, e = 0, i;
		for (i = 0; i < n - 1; i++) {
			if (arr[i] > arr[i + 1]) {
				s = i;
				break;
			}
		}
		for (i = n - 1; i > 0; i--) {
			if (arr[i] < arr[i - 1]) {
				e = i;
				break;
			}
		}
		int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
		for (i = s; i <= e; i++) {
			if (arr[i] < min) {
				min = arr[i];
			}
			if (arr[i] > max) {
				max = arr[i];
			}
		}
		for (i = 0; i < s; i++) {
			if (arr[i] > min) {
				s = i;
				min = arr[i];
			}
		}
		for (i = e + 1; i < n; i++) {
			if (arr[i] < max) {
				e = i;
				max = arr[i];
			}
		}
		new ArrayPrinter().printArray(arr, s, e);
	}
}


 ===================================================== 


QuickSort.java


/*
quickSort(arr[], low, high)
{
    if (low < high)
    {
        pi is partitioning index, arr[pi] is now
           at right place
        pi = partition(arr, low, high);

		quickSort(arr, low, pi - 1);  // Before pi
		quickSort(arr, pi + 1, high); // After pi
	}
}

/*
This function takes last element as pivot, places

   the pivot element at its correct position in sorted
    array, and places all smaller (smaller than pivot)
   to left of pivot and all greater elements to right
   of pivot
partition (arr[], low, high)
		{
		// pivot (Element to be placed at right position)
		pivot = arr[high];

		i = (low - 1)  // Index of smaller element

		for (j = low; j <= high- 1; j++)
		{
		// If current element is smaller than the pivot
		if (arr[j] < pivot)
		{
		i++;    // increment index of smaller element
		swap arr[i] and arr[j]
		}
		}
		swap arr[i + 1] and arr[high])
		return (i + 1)
		}
 */

package Algorithms.Sorting;

import Commons.ArrayPrinter;

public class QuickSort {
	private static void quickSort(int[] arr, int low, int high) {
		if (low < high) {
			int pi = partition(arr, low, high);
			quickSort(arr, low, pi - 1);
			quickSort(arr, pi + 1, high);
		}
	}

	private static int partition(int[] arr, int low, int high) {
		int pivot = arr[high], i = low - 1, temp;
		for (int j = low; j <= high - 1; j++) {
			if (arr[j] < pivot) {
				i++;
				temp = arr[j];
				arr[j] = arr[i];
				arr[i] = temp;
			}
		}
		temp = arr[high];
		arr[high] = arr[i + 1];
		arr[i + 1] = temp;
		return i + 1;
	}

	public static void main(String[] args) {
		int[] arr = {10, 23, 19, 15, 48, 26, 54};
		quickSort(arr, 0, arr.length - 1);
		new ArrayPrinter().printArray(arr, arr.length);
	}
}


 ===================================================== 


SelectionSort.java


package Algorithms.Sorting;

import Commons.ArrayPrinter;

public class SelectionSort {
	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		int[] arr = {10, 23, 19, 15, 48, 26, 54};
		new ArrayPrinter().printArray(selectionSort(arr, arr.length), arr.length);
	}

	private static int[] selectionSort(int[] arr, int n) {
		int pos, temp, small;
		for (int i = 0; i < n; i++) {
			small = arr[i];
			pos = i;
			for (int j = i; j < n; j++) {
				if (small > arr[j]) {
					small = arr[j];
					pos = j;
				}
			}
			temp = arr[i];
			arr[i] = arr[pos];
			arr[pos] = temp;
		}
		return arr;
	}
}



 ===================================================== 


SortInWave.java


package Algorithms.Sorting;

import Commons.ArrayPrinter;

public class SortInWave {
	public static void main(String[] args) {
		int[] arr = {10, 90, 49, 2, 1, 5, 23};
		waveSort(arr, arr.length);
	}

	private static void waveSort(int[] arr, int n) {
		int temp;
		for (int i = 0; i < n; i += 2) {
			if (i > 0 && arr[i] < arr[i - 1]) {
				temp = arr[i - 1];
				arr[i - 1] = arr[i];
				arr[i] = temp;
			}
			if (i < n - 1 && arr[i] < arr[i + 1]) {
				temp = arr[i + 1];
				arr[i + 1] = arr[i];
				arr[i] = temp;
			}
		}
		new ArrayPrinter().printArray(arr, arr.length);
	}
}


 ===================================================== 


ArrayPrinter.java


package Commons;

public class ArrayPrinter {
	public void printArray(int[] arr) {
		printArray(arr, arr.length);
	}

	public void printArray(int[] arr, int end) {
		for (int i = 0; i < end; i++) {
			System.out.print(arr[i] + " ");
		}
	}

	public void printArray(int[] arr, int start, int end) {
		for (int i = start; i < end; i++) {
			System.out.print(arr[i] + " ");
		}
	}

	public void printArray(String[] arr, int end) {
		for (int i = 0; i < end; i++) {
			System.out.print(arr[i] + " ");
		}
	}

	public void printArray(boolean[] arr, int end) {
		for (int i = 0; i < end; i++) {
			System.out.print(arr[i] + " ");
		}
	}
}


 ===================================================== 


BinarySearchTree.java


package Commons;

public class BinarySearchTree {
	public Node root;

	public BinarySearchTree() {
		root = null;
	}

	public Node getRoot() {
		return root;
	}

	public Node insert(Node root, int element) {
		// Creating root of the tree
		if (root == null) {
			return new Node(element, null, null);
		}

		if (element < root.data) {
			root.left = insert(root.left, element);
		} else if (element > root.data) {
			root.right = insert(root.right, element);
		}

		return root;
	}
}


 ===================================================== 


GlobalVar.java


/*
Utility class that maintains an object with a parameter inside to be used in many recursive calls
 */

package Commons;

public class GlobalVar {
	public int var;

	public GlobalVar(int var) {
		this.var = var;
	}
}


 ===================================================== 


GraphList.java


package Commons;

import java.util.ArrayList;

@SuppressWarnings("unchecked")
public class GraphList {
	private final ArrayList<Integer>[] graph;
	private final boolean isDirected;
	private final boolean isZeroIndexed;

	public GraphList(int V, boolean isDirected, boolean isZeroIndexed) {
		this.graph = new ArrayList[V];
		for (int i = 0; i < V; i++) {
			this.graph[i] = new ArrayList<>();
		}
		this.isDirected = isDirected;
		this.isZeroIndexed = isZeroIndexed;
	}

	public void addEdge(int source, int destination) {
		if (!isZeroIndexed) {
			source--;
			destination--;
		}
		this.graph[source].add(destination);
		if (!isDirected) {
			this.graph[destination].add(source);
		}
	}

	public ArrayList<Integer>[] getGraph() {
		return graph;
	}
}


 ===================================================== 


GraphMatrix.java


/*
Utility class to return an adjacency matrix from given connections
 */

package Commons;

public class GraphMatrix {
	private final int[][] graph;
	private final boolean isDirected;
	private final boolean isZeroIndexed;

	public GraphMatrix(int V, boolean isDirected, boolean isZeroIndexed) {
		graph = new int[V][V];
		this.isDirected = isDirected;
		this.isZeroIndexed = isZeroIndexed;
	}

	public void addEdge(int source, int destination) {
		if (!isZeroIndexed) {
			source--;
			destination--;
		}
		this.graph[source][destination] = 1;
		if (!isDirected) {
			this.graph[destination][source] = 1;
		}
	}

	public void addEdge(int source, int destination, int weight) {
		if (!isZeroIndexed) {
			source--;
			destination--;
		}
		this.graph[source][destination] = weight;
		if (!isDirected) {
			this.graph[destination][source] = weight;
		}
	}

	public int[][] getGraph() {
		return this.graph;
	}

	public void printGraphMatrix(int[][] graph) {
		for (int i = 0; i < graph[0].length; i++) {
			System.out.print(i + " => ");
			for (int j = 0; j < graph[0].length; j++) {
				System.out.print(graph[i][j] + ", ");
			}
			System.out.println();
		}
	}
}


 ===================================================== 


ListNode.java


package Commons;

public class ListNode<T> {
	public T data;
	public ListNode<T> next;
	public ListNode<T> head = null;

	public ListNode(T data) {
		this.data = data;
		this.next = null;
	}

	public ListNode() {
		this.head = null;
	}

	public void push(T data) {
		ListNode<T> newNode = new ListNode(data);
		newNode.next = head;
		this.head = newNode;
	}

	public void printList() {
		ListNode<T> node = this.head;
		while (node != null) {
			System.out.print(node.data + " ");
			node = node.next;
		}
	}

	public void printList(ListNode<T> head) {
		while (head != null) {
			System.out.print(head.data + " ");
			head = head.next;
		}
	}

	public void convertCircular() {
		ListNode<T> node = this.head;
		while (node.next != null) {
			node = node.next;
		}
		node.next = this.head;
	}

	public void printCircularList() {
		ListNode<T> node = this.head;
		while (this.head.next != node) {
			System.out.print(this.head.data + " ");
			this.head = this.head.next;
		}
		System.out.println(this.head.data);
		this.head = node;
	}

	public void printCircularList(ListNode<T> head) {
		ListNode<T> node = head;
		while (head.next != node) {
			System.out.print(head.data + " ");
			head = head.next;
		}
		System.out.println(head.data);
	}
}


 ===================================================== 


Node.java


package Commons;

public class Node {
	public Node left, right;
	public int data;

	public Node(int item) {
		data = item;
		left = right = null;
	}

	public Node(int data, Node left, Node right) {
		this.left = left;
		this.right = right;
		this.data = data;
	}
}


 ===================================================== 


ContainerWithMostWater.java


package DataStructures.Arrays;

public class ContainerWithMostWater {
	public static void main(String[] args) {
		int[] arr = {1, 8, 6, 2, 5, 4, 8, 3, 7};
		System.out.println(maxArea(arr));
	}

	private static int maxArea(int[] arr) {
		int l = 0, h = arr.length - 1;
		int area, maxArea = 0;
		while (l < h) {
			area = Math.min(arr[l], arr[h]) * (h - l);
			maxArea = Math.max(area, maxArea);
			if (l + 1 < h && arr[l + 1] > arr[l]) {
				l++;
			}
			if (h - 1 > l && arr[h - 1] > arr[h]) {
				h--;
			}
			if (l == h - 1) {
				break;
			}
		}
		return maxArea;
	}
}


 ===================================================== 


SegregateOddEven.java


package DataStructures.Arrays.MinSwaps;

import Commons.ArrayPrinter;

public class SegregateOddEven {
	public static void main(String[] args) {
		int[] arr = {12, 34, 45, 9, 8, 90, 3};
		System.out.println("\n" + segregate(arr, arr.length));
	}

	private static int segregate(int[] arr, int n) {
		int l = 0, r = n - 1;
		int count = 0;
		while (l < r) {
			while (arr[l] % 2 == 0 && l < r) {
				l++;
			}
			while (arr[r] % 2 == 1 && l < r) {
				r--;
			}
			if (l < r) {
				int temp = arr[l];
				arr[l] = arr[r];
				arr[r] = temp;
				count++;
				l++;
				r--;
			}
		}
		new ArrayPrinter().printArray(arr);
		return count;
	}
}


 ===================================================== 


SortAnArrayTillN_NaturalNumbers.java


package DataStructures.Arrays.MinSwaps;

public class SortAnArrayTillN_NaturalNumbers {
	public static void main(String[] args) {
		int[] arr = {2, 3, 4, 1, 5};
		System.out.println(minSwaps(arr, arr.length));
	}

	private static int minSwaps(int[] arr, int n) {
		int count = 0, x, y;
		for (int i = 0; i < n; i++) {
			while (arr[i] != i + 1) {
				x = arr[arr[i] - 1];
				arr[arr[i] - 1] = arr[i];
				arr[i] = x;
				count++;
			}
		}
		return count;
	}
}


 ===================================================== 


ToBringPairsTogether.java


package DataStructures.Arrays.MinSwaps;

public class ToBringPairsTogether {
	private static void updateIndex(int[] arr, int a, int ai, int b, int bi) {
		arr[a] = ai;
		arr[b] = bi;
	}

	private static int minSwapsUtil(int[] arr, int[] pairs, int[] index, int i, int n) {
		// If all pairs processed so
		// no swapping needed return 0
		if (i > n) {
			return 0;
		}

		// If current pair is valid so
		// DO NOT DISTURB this pair
		// and move ahead.
		if (pairs[arr[i]] == arr[i + 1]) {
			return minSwapsUtil(arr, pairs, index, i + 2, n);
		}

		// If we reach here, then arr[i] and
		// arr[i+1] don't form a pair

		// Swap pair of arr[i] with arr[i+1]
		// and recursively compute minimum swap
		// required if this move is made.
		int one = arr[i];
		int indexTwo = arr[i + 1];
		int indexOne = index[pairs[arr[i]]];
		int two = arr[index[pairs[arr[i]]]];
		updateIndex(arr, one, indexOne, two, indexTwo);
		int a = minSwapsUtil(arr, pairs, index, i + 2, n);

		// Backtrack to previous configuration.
		// Also restore the previous
		// indices, of one and two
		arr[i + 1] = arr[i + 1] ^ arr[indexOne] ^
				(arr[indexOne] = arr[i + 1]);
		updateIndex(index, one, indexTwo, two, indexOne);
		one = arr[i];
		indexOne = index[pairs[arr[i + 1]]];

		// Now swap arr[i] with pair of arr[i+1]
		// and recursively compute minimum swaps
		// required for the subproblem
		// after this move
		two = arr[index[pairs[arr[i + 1]]]];
		indexTwo = i;
		arr[i] = arr[i] ^ arr[indexOne] ^ (arr[indexOne] = arr[i]);
		updateIndex(index, one, indexOne, two, indexTwo);
		int b = minSwapsUtil(arr, pairs, index, i + 2, n);

		// Backtrack to previous configuration. Also restore
		// the previous indices, of one and two
		arr[i] = arr[i] ^ arr[indexOne] ^ (arr[indexOne] = arr[i]);
		updateIndex(index, one, indexTwo, two, indexOne);

		// Return minimum of two cases
		return 1 + Math.min(a, b);
	}

	private static int minSwaps(int[] arr, int n, int[] pairs) {
		int[] index = new int[2 * n + 1];
		for (int i = 1; i <= 2 * n; i++) {
			index[arr[i]] = i;
		}

		return minSwapsUtil(arr, pairs, index, 1, 2 * n);
	}

	public static void main(String[] args) {
		int[] arr = {0, 3, 5, 6, 4, 1, 2};

		// if (a, b) is pair than we have assigned elements
		// in array such that pairs[a] = b and pairs[b] = a
		int[] pairs = {0, 3, 6, 1, 5, 4, 2};
		int m = pairs.length;

		// Number of pairs n is half of total elements
		int n = m / 2;
		System.out.println(minSwaps(arr, n, pairs));
	}
}


 ===================================================== 


ToMakeEveryElementEqual.java


package DataStructures.Arrays.MinSwaps;

import java.util.HashMap;

public class ToMakeEveryElementEqual {
	public static void main(String[] args) {
//		int[] arr = {2, 3, 3, 4};
		int[] arr = {1, 2, 3, 4};
		int n = arr.length;
		System.out.println(minChanges(arr, n));
	}

	private static int minChanges(int[] arr, int n) {
		HashMap<Integer, Integer> map = new HashMap<>();
		int maxCount = 0, max = arr[0];
		for (int i : arr) {
			if (map.containsKey(i)) {
				map.put(i, map.get(i) + 1);
			} else {
				map.put(i, 1);
			}
			if (map.get(i) > maxCount) {
				maxCount = map.get(i);
				max = i;
			}
		}

		return n - map.get(max);
	}
}


 ===================================================== 


ToMakeSumK.java


package DataStructures.Arrays.MinSwaps;

public class ToMakeSumK {
	public static void main(String[] args) {
		int[] arr = {1, 3, 2, 5, 6};
		int n = arr.length;
		int k = 5;
		System.out.println(minChanges(arr, n, k));
	}

	private static int minChanges(int[] arr, int n, int k) {
		int min = n + 1, sum = 0, j = 0;
		boolean found = false;
		for (int i = 0; i < n; i++) {
			sum += arr[i];
			if (sum >= k) {
				if (sum == k) {
					min = Math.min(n - (i + 1) + j, min);
					found = true;
				}
				while (sum > k) {
					sum = sum - arr[j];
					j++;
				}
				if (sum == k) {
					min = Math.min(n - (i + 1) + j, min);
					found = true;
				}
			}
		}
		if (found) {
			return min;
		} else {
			return -1;
		}
	}
}


 ===================================================== 


ElementsWhichHaveAtleast2ElementsGreater.java


package DataStructures.Arrays.OrderStatistics;

public class ElementsWhichHaveAtleast2ElementsGreater {
	public static void main(String[] args) {
		int[] arr = {2, -6, 3, 5, 1};
		printNumbers(arr, arr.length);
	}

	private static void printNumbers(int[] arr, int n) {
		int first = Integer.MIN_VALUE, second = Integer.MIN_VALUE;
		for (int i : arr) {
			if (i > first) {
				second = first;
				first = i;
			} else if (i > second) {
				second = i;
			}
		}
		for (int i : arr) {
			if (i <= second) {
				System.out.print(i + " ");
			}
		}
	}
}


 ===================================================== 


KMaxSumCombinations.java


package DataStructures.Arrays.OrderStatistics;

import java.util.Arrays;

public class KMaxSumCombinations {
	public static void main(String[] args) {
		int[] a = {4, 2, 5, 1};
//		int[] a = {4, 2};
		int[] b = {8, 0, 3, 5};
//		int[] b = {8, 0};
		int k = 3;
//		int k = 2;
		KMaxSumCombos(a, b, a.length, b.length, k);
	}

	private static void KMaxSumCombos(int[] a, int[] b, int n, int m, int k) {
		Arrays.sort(a);
		Arrays.sort(b);
		int i = n - 1, j = m - 1, count = 0;
		while (count < k && i >= 0 && j >= 0) {
			System.out.println(a[i] + b[j]);
			count++;
			if (i > 0 && j > 0 && a[i - 1] > b[j - 1]) {
				j--;
			} else {
				i--;
			}
		}
	}
}


 ===================================================== 


KNumbersWithMostOccurrences.java


package DataStructures.Arrays.OrderStatistics;

import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

public class KNumbersWithMostOccurrences {
	public static void main(String[] args) {
		int[] arr = {3, 1, 4, 4, 5, 2, 6, 1};
		int k = 2;
		kThOccurrence(arr, k);
	}

	private static void kThOccurrence(int[] arr, int k) {
		HashMap<Integer, Integer> map = new HashMap<>();
		for (int i : arr) {
			map.put(i, map.getOrDefault(i, 0) + 1);
		}
		PriorityQueue<Map.Entry<Integer, Integer>> queue =
				new PriorityQueue<>(
						(a, b) -> a.getValue().equals(b.getValue()) ?
								Integer.compare(b.getKey(), a.getKey()) :
								Integer.compare(b.getValue(), a.getValue()));
		queue.addAll(map.entrySet());
		for (int i = 0; i < k; i++) {
			System.out.print(queue.poll().getKey() + " ");
		}
	}
}


 ===================================================== 


KSmallestUsingConstantSpace.java


package DataStructures.Arrays.OrderStatistics;

public class KSmallestUsingConstantSpace {
}


 ===================================================== 


KthLargestSumContiguousSubArray.java


package DataStructures.Arrays.OrderStatistics;

import java.util.PriorityQueue;

public class KthLargestSumContiguousSubArray {
	public static void main(String[] args) {
		int[] arr = new int[]{10, -10, 20, -40};
		int n = arr.length;
		int k = 6;
		System.out.println(kthLargestSum(arr, n, k));
	}

	private static int kthLargestSum(int[] arr, int n, int k) {
		int[] sum = new int[n + 1];
		sum[0] = 0;
		sum[1] = arr[0];
		for (int i = 2; i <= n; i++) {
			sum[i] = arr[i - 1] + sum[i - 1];
		}
		PriorityQueue<Integer> queue = new PriorityQueue<>();
		for (int i = 1; i <= n; i++) {
			for (int j = i; j <= n; j++) {
				int x = sum[j] - sum[i - 1];
				if (queue.size() < k) {
					queue.add(x);
				} else {
					if (queue.peek() < x) {
						queue.poll();
						queue.add(x);
					}
				}
			}
		}
		return queue.poll();
	}
}


 ===================================================== 


KthSmallestAbsoluteDifference.java


package DataStructures.Arrays.OrderStatistics;

import java.util.Arrays;

public class KthSmallestAbsoluteDifference {
	public static void main(String[] args) {
		int k = 3;
		int[] a = {1, 2, 3, 4};
		int n = a.length;
		System.out.println(kthDiff(a, n, k));
	}

	private static int kthDiff(int[] arr, int n, int k) {
		Arrays.sort(arr);
		int low = arr[1] - arr[0];
		for (int i = 1; i <= n - 2; i++) {
			low = Math.min(low, arr[i + 1] - arr[i]);
		}
		int high = arr[n - 1] - arr[0];
		while (low < high) {
			int mid = (low + high) / 2;
			if (countPairs(arr, n, mid) < k) {
				low = mid + 1;
			} else {
				high = mid;
			}
		}
		return low;
	}

	private static int countPairs(int[] arr, int n, int mid) {
		int res = 0;
		for (int i = 0; i < n; i++) {
			// Upper bound returns pointer to position
			// of next higher number than a[i]+mid in
			// a[i..n-1]. We subtract (ub + i + 1) from
			// this position to count
			int ub = upperbound(arr, n, arr[i] + mid);
			res += (ub - (i - 1));
		}
		return res;
	}

	private static int upperbound(int[] arr, int n, int value) {
		int low = 0, high = n - 1;
		while (low <= high) {
			int mid = (low + high) / 2;
			if (value >= arr[mid]) {
				low = mid + 1;
			} else {
				high = mid;
			}
		}
		return low;
	}
}


 ===================================================== 


LargestThreeElements.java


package DataStructures.Arrays.OrderStatistics;

public class LargestThreeElements {
	public static void main(String[] args) {
		int[] arr = {12, 13, 1, 10, 34, 1};
		int n = arr.length;
		findThree(arr, n);
	}

	private static void findThree(int[] arr, int n) {
		int first, second, third;
		first = second = third = Integer.MIN_VALUE;
		for (int i : arr) {
			if (i > first) {
				third = second;
				second = first;
				first = i;
			} else if (i > second) {
				third = second;
				second = i;
			} else if (i > third) {
				third = i;
			}
		}
		System.out.println(first + " " + second + " " + third);
	}
}


 ===================================================== 


MajorityElement.java


package DataStructures.Arrays.OrderStatistics;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

public class MajorityElement {
	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		int tc = Integer.parseInt(in.readLine());
		String[] arr;
// 		HashMap<Integer, Integer> map = new HasMap<>();
		int count, n;
		boolean found;
		for (int x = 0; x < tc; x++) {
			count = 1;
			found = false;
			n = Integer.parseInt(in.readLine());
			arr = in.readLine().split(" ");
			Arrays.sort(arr);
			for (int i = 0; i < n-1; i++) {
				if (arr[i].equals(arr[i + 1])) {
					count++;
				} else {
					count = 1;
				}
				if (count > n / 2) {
					System.out.println(arr[i]);
					found = true;
					break;
				}
			}
			if (!found) {
				System.out.println(-1);
			}
		}
	}
}


 ===================================================== 


MaximumJ_Minus_I.java


// https://www.geeksforgeeks.org/given-an-array-arr-find-the-maximum-j-i-such-that-arrj-arri/

package DataStructures.Arrays.OrderStatistics;

public class MaximumJ_Minus_I {
	public static void main(String[] args) {
		int[] arr = {9, 2, 3, 4, 5, 6, 7, 8, 18, 0};
		int n = arr.length;
		System.out.println(getMaxDifference(arr, n));
	}

	private static int getMaxDifference(int[] arr, int n) {
		int maxDiff, i, j;
		int[] LMin = new int[n];
		int[] RMax = new int[n];
		LMin[0] = arr[0];
		for (i = 1; i < n; i++) {
			LMin[i] = Math.min(arr[i], LMin[i - 1]);
		}
		RMax[n - 1] = arr[n - 1];
		for (j = n - 2; j >= 0; j--) {
			RMax[j] = Math.max(arr[j], RMax[j + 1]);
		}
		i = j = 0;
		maxDiff = -1;
		while (j < n && i < n) {
			if (LMin[i] < RMax[j]) {
				maxDiff = Math.max(maxDiff, j - i);
				j++;
			} else {
				i++;
			}
		}
		return maxDiff;
	}
}


 ===================================================== 


MaxRepeatingNumberInOK.java


// https://www.geeksforgeeks.org/find-the-maximum-repeating-number-in-ok-time/

package DataStructures.Arrays.OrderStatistics;

public class MaxRepeatingNumberInOK {
	public static void main(String[] args) {
		int[] arr = {2, 3, 3, 5, 3, 4, 1, 7};
		int n = arr.length;
		int k = 8;
		System.out.println(getNumber(arr, n, k));
	}

	private static int getNumber(int[] arr, int n, int k) {
		int i;
		for (i = 0; i < n; i++) {
			arr[arr[i] % k] += k;
		}
		int max = arr[0], result = 0;
		for (i = 1; i < n; i++) {
			if (max < arr[i]) {
				max = arr[i];
				result = i;
			}
		}

		// The maximum repeating number would be the index
		// and not arr[result]
		return result;
	}
}


 ===================================================== 


MaxSumNoAdjacentElements.java


package DataStructures.Arrays.OrderStatistics;

public class MaxSumNoAdjacentElements {
	public static void main(String[] args) {
		int[] arr = {5, 5, 10, 100, 10, 5};
		System.out.println(findMaxSum(arr, arr.length));
	}

	private static int findMaxSum(int[] arr, int n) {
		int incl = arr[0], excl = 0, excl_new, i;
		for (i = 1; i < n; i++) {
			excl_new = Math.max(incl, excl);
			incl = excl + arr[i];
			excl = excl_new;
		}
		return Math.max(incl, excl);
	}
}


 ===================================================== 


MaxSumPath.java


package DataStructures.Arrays.OrderStatistics;

public class MaxSumPath {
	public static void main(String[] args) {
		int[] ar1 = {2, 3, 7, 10, 12, 15, 30, 34};
		int[] ar2 = {1, 5, 7, 8, 10, 15, 16, 19};
		int m = ar1.length;
		int n = ar2.length;
		System.out.println(maxSumPath(ar1, ar2, m, n));
	}

	private static int maxSumPath(int[] ar1, int[] ar2, int m, int n) {
		int i = 0, j = 0, result = 0, sum1 = 0, sum2 = 0;
		while (i < m && j < n) {
			if (ar1[i] < ar2[j]) {
				sum1 += ar1[i];
				i++;
			} else if (ar1[i] > ar2[j]) {
				sum2 += ar2[j];
				j++;
			} else {
				result += Math.max(sum1, sum2);
				sum1 = sum2 = 0;
				while (i < m && j < n && ar1[i] == ar2[j]) {
					result += ar1[i];
					i++;
					j++;
				}
			}
		}

		while (i < m) {
			sum1 += ar1[i];
			i++;
		}

		while (j < n) {
			sum2 += ar2[j];
			j++;
		}

		result += Math.max(sum1, sum2);

		return result;
	}
}


 ===================================================== 


AlternatePositiveAndNegative.java


package DataStructures.Arrays.Rearrangement;

import Commons.ArrayPrinter;

public class AlternatePositiveAndNegative {
	public static void main(String[] args) {
		int[] arr = {-5, -2, 5, 2, 4, 7, 1, 8, 0, -8};
		alternate(arr, arr.length);
	}

	private static void alternate(int[] arr, int n) {
		int out = -1;
		for (int index = 0; index < n; index++) {
			if (out >= 0) {
				// find the item which must be moved into the out-of-place
				// entry if out-of-place entry is positive and current
				// entry is negative OR if out-of-place entry is negative
				// and current entry is negative then right rotate
				//
				// [...-3, -4, -5, 6...] -->   [...6, -3, -4, -5...]
				//      ^                          ^
				//      |                          |
				//     outofplace      -->      outofplace
				if (((arr[index] >= 0) && (arr[out] < 0)) || ((arr[index] < 0) && (arr[out] >= 0))) {
					rightRotate(arr, out, index);
					if (index - out > 2) {
						out = out + 2;
					} else {
						out = -1;
					}
				}
			}

			if (out == -1) {
				if (((arr[index] >= 0) && ((index % 2) != 0)) || ((arr[index] < 0) && ((index % 2) == 0))) {
					out = index;
				}
			}
		}
		new ArrayPrinter().printArray(arr);
	}

	private static void rightRotate(int[] arr, int out, int cur) {
		int temp = arr[cur];
		for (int i = cur; i > out; i--) {
			arr[i] = arr[i - 1];
		}
		arr[out] = temp;
	}
}


 ===================================================== 


AlternatePositiveNegativeWithConstantSpace.java


package DataStructures.Arrays.Rearrangement;

import Commons.ArrayPrinter;

public class AlternatePositiveNegativeWithConstantSpace {
	public static void main(String[] args) {
		int[] arr = {12, 11, -13, -5, 6, -7, 5, -3, -6};
		rearrange(arr, arr.length);
	}

	private static void rearrange(int[] arr, int n) {
		int key, j;
		for (int i = 1; i < n; i++) {
			key = arr[i];
			if (key > 0) {
				continue;
			}
			j = i - 1;
			while (j >= 0 && arr[j] > 0) {
				arr[j + 1] = arr[j];
				j--;
			}
			arr[j + 1] = key;
		}
		new ArrayPrinter().printArray(arr);
	}
}


 ===================================================== 


MinimumSwapsToBringElementsLTKTogether.java


package DataStructures.Arrays.Rearrangement;

public class MinimumSwapsToBringElementsLTKTogether {
	public static void main(String[] args) {
		int[] arr = {2, 1, 5, 6, 3};
		int n = arr.length;
		int k = 3;
		System.out.println(minSwaps(arr, n, k));
	}

	private static int minSwaps(int[] arr, int n, int k) {
		int ans, count, bad, i, j;
		count = bad = 0;
		for (i = 0; i < n; i++) {
			if (arr[i] <= k) {
				count++;
			}
		}

		for (i = 0; i < count; i++) {
			if (arr[i] > k) {
				bad++;
			}
		}

		ans = bad;
		for (i = 0, j = count; j < n; i++, j++) {
			if (arr[i] > k) {
				bad--;
			}
			if (arr[j] > k) {
				bad++;
			}
			ans = Math.min(ans, bad);
		}
		return ans;
	}
}


 ===================================================== 


MoveZeroesToEndInSingleTraversal.java


package DataStructures.Arrays.Rearrangement;

import Commons.ArrayPrinter;

public class MoveZeroesToEndInSingleTraversal {
	public static void main(String[] args) {
		int[] arr = {0, 1, 9, 8, 4, 0, 0, 2, 7, 0, 6, 0, 9};
		moveZeroes(arr, arr.length);
	}

	private static void moveZeroes(int[] arr, int n) {
		int temp, count = 0;
		for (int i = 0; i < n; i++) {
			if (arr[i] != 0) {
				temp = arr[count];
				arr[count] = arr[i];
				arr[i] = temp;
				count++;
			}
		}
		new ArrayPrinter().printArray(arr);
	}
}


 ===================================================== 


RearrangeArrayInOrder.java


/*
Rearrange an array in order  smallest, largest, 2nd smallest, 2nd largest, ..
 */

package DataStructures.Arrays.Rearrangement;

import Commons.ArrayPrinter;

import java.util.Arrays;

public class RearrangeArrayInOrder {
	public static void main(String[] args) {
		int[] arr = {5, 8, 1, 4, 2, 9, 3, 7, 6};
		new ArrayPrinter().printArray(rearrange(arr, arr.length));
	}

	private static int[] rearrange(int[] arr, int n) {
		Arrays.sort(arr);
		int[] temp = new int[n];
		int i = 0, j = n - 1;
		int count = 0;
		while (count < n) {
			if (count % 2 == 0) {
				temp[count] = arr[i];
				i++;
			} else {
				temp[count] = arr[j];
				j--;
			}
			count++;
		}
		return temp;
	}
}


 ===================================================== 


RearrangeEvenAndOdd.java


// Rearrange array such that arr[i] >= arr[j] if i is even and arr[i]<=arr[j] if i is odd and j < i

package DataStructures.Arrays.Rearrangement;

import Commons.ArrayPrinter;

import java.util.Arrays;

public class RearrangeEvenAndOdd {
	public static void main(String[] args) {
		int[] arr = new int[]{1, 2, 3, 4, 5, 6, 7};
		rearrangeArray(arr, arr.length);
	}

	private static void rearrangeArray(int[] arr, int n) {
		int even = n / 2;
		int odd = n - even;
		int[] temp = arr.clone();
		Arrays.sort(temp);
		int j = odd - 1;

		// fill up odd positions in arr
		for (int i = 0; i < n; i += 2) {
			arr[i] = temp[j];
			j--;
		}
		j = odd;

		// full up even positions
		for (int i = 1; i < n; i += 2) {
			arr[i] = temp[j];
			j++;
		}

		new ArrayPrinter().printArray(arr);
	}
}


 ===================================================== 


RearrangeMaxMinWithoutExtraSpace.java


package DataStructures.Arrays.Rearrangement;

import Commons.ArrayPrinter;

public class RearrangeMaxMinWithoutExtraSpace {
	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4, 5, 6};
		rearrange(arr, arr.length);
	}

	private static void rearrange(int[] arr, int n) {
		int max = n - 1;
		int min = 0;
		int maxElem = arr[n - 1] + 1;
		for (int i = 0; i < n; i++) {
			if (i % 2 == 0) {
				arr[i] += (arr[max] % maxElem) * maxElem;
				max--;
			} else {
				arr[i] += (arr[min] % maxElem) * maxElem;
				min++;
			}
		}
		for (int i = 0; i < n; i++) {
			arr[i] = arr[i] / maxElem;
		}
		new ArrayPrinter().printArray(arr);
	}
}


 ===================================================== 


RearrangeSuchThatAiEQi.java


package DataStructures.Arrays.Rearrangement;

import Commons.ArrayPrinter;

public class RearrangeSuchThatAiEQi {
	public static void main(String[] args) {
		int[] A = {-1, -1, 6, 1, 9, 3, 2, -1, 4, -1};
		fix(A, A.length);
	}

	private static void fix(int[] arr, int n) {
		int x, y;
		for (int i = 0; i < n; i++) {
			if (arr[i] != -1 && arr[i] != i) {
				x = arr[i];
				while (arr[x] != -1 && arr[x] != x) {
					y = arr[x];
					arr[x] = x;
					x = y;
				}
				arr[x] = x;
				if (arr[i] != i) {
					arr[i] = -1;
				}
			}
		}
		new ArrayPrinter().printArray(arr);
	}
}


 ===================================================== 


RearrangeWithRule.java


// Rearrange an array such that arr[j] becomes i if arr[i] is j

package DataStructures.Arrays.Rearrangement;

import Commons.ArrayPrinter;

public class RearrangeWithRule {
	public static void main(String[] args) {
		int[] arr = {2, 0, 1, 4, 5, 3};
		rearrange(arr, arr.length);
	}

	private static void rearrange(int[] arr, int n) {
		for (int i = 0; i < n; i++) {
			arr[arr[i] % n] += i * n;
		}
		for (int i = 0; i < n; i++) {
			arr[i] = arr[i] / n;
		}
		new ArrayPrinter().printArray(arr);
	}
}


 ===================================================== 


ArrayRotationByGCD.java


package DataStructures.Arrays.Rotations;

import Commons.ArrayPrinter;

public class ArrayRotationByGCD {
	private static int gcd(int a, int b) {
		if (b == 0) {
			return a;
		} else {
			return gcd(b, a % b);
		}
	}

	private static void leftRotate(int[] arr, int n, int d) {
		// to handle d > n
		d = d % n;
		int i, j, k, temp;
//		int gcd = gcd(d, n);
		int gcd = gcd(n, d);
		for (i = 0; i < gcd; i++) {
			temp = arr[i];
			j = i;
			while (true) {
				k = j + d;
				if (k >= n) {
					k = k - n;
				}
				if (k == i) {
					break;
				}
				arr[j] = arr[k];
				j = k;
			}
			arr[j] = temp;
		}
		new ArrayPrinter().printArray(arr, arr.length);
	}

	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4, 5, 6, 7};
		int d = 2;
		leftRotate(arr, arr.length, d);
	}
}


 ===================================================== 


FindElementAtPositionAfterRotations.java


package DataStructures.Arrays.Rotations;

public class FindElementAtPositionAfterRotations {
	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4, 5};

		// No. of rotations
		int rotations = 2;

		// Ranges according to 0-based indexing
		int[][] ranges = {{0, 2}, {0, 3}};

		int index = 1;

		System.out.println(returnElement(arr, ranges, rotations, index));
	}

	private static int returnElement(int[] arr, int[][] ranges, int rotations, int index) {
		int left, right, i;
		for (i = rotations - 1; i >= 0; i--) {
			left = ranges[i][0];
			right = ranges[i][1];
			if (left <= index && right >= index) {
				if (index == left) {
					index = right;
				} else {
					index--;
				}
			}
		}
		return arr[index];
	}
}


 ===================================================== 


MaxHammingDistance.java


package DataStructures.Arrays.Rotations;

public class MaxHammingDistance {
	public static void main(String[] args) {
		int[] arr = {2, 4, 6, 8};
		int n = arr.length;
		System.out.print(returnMaxHammingDistance(arr, n));
	}

	private static int returnMaxHammingDistance(int[] arr, int n) {
		int[] temp = new int[2 * n];
		for (int i = 0; i < n; i++) {
			temp[n + i] = temp[i] = arr[i];
		}
		int maxHam = 0, currHam;
		for (int i = 1; i < n; i++) {
			currHam = 0;
			for (int j = i, k = 0; j < (i + n); j++, k++) {
				if (temp[j] != temp[k]) {
					currHam++;
				}
			}
			if (currHam == n) {
				return n;
			}

			maxHam = Math.max(currHam, maxHam);
		}
		return maxHam;
	}
}


 ===================================================== 


MaxSumOfArrayValueIntoIndex.java


package DataStructures.Arrays.Rotations;

public class MaxSumOfArrayValueIntoIndex {
	public static void main(String[] args) {
		int[] arr = {10, 1, 2, 3, 4, 5, 6, 7, 8, 9};
		System.out.println(getMax(arr, arr.length));
	}

	// Max of arr[i] * i among all rotations
	private static int getMax(int[] arr, int n) {
		int arrSum = 0, i, r0 = 0;
		for (i = 0; i < n; i++) {
			arrSum += arr[i];
			r0 += (i * arr[i]);
		}

		// R(j) - R(j-1) = arrSum - n * arr[n-j]
		// => R(j) = arrSum - n * arr[n-j] +R(j-1)
		int maxSum = r0, current, prev = r0;
		for (i = 1; i < n; i++) {
			current = arrSum - (n * arr[n - i]) + prev;
			if (maxSum < current) {
				maxSum = current;
			}
			prev = current;
		}
		return maxSum;
	}
}


 ===================================================== 


PairWithSumXInSortedRotatedArray.java


package DataStructures.Arrays.Rotations;

public class PairWithSumXInSortedRotatedArray {
	public static void main(String[] args) {
		int[] arr = {11, 15, 6, 8, 9, 10};
		int sum = 16;
		printPair(arr, arr.length, sum);
	}

	private static void printPair(int[] arr, int n, int sum) {
		int i;
		for (i = 0; i < n - 1; i++) {
			if (arr[i] > arr[i + 1]) {
				break;
			}
		}
		int r = i, l = (r + 1) % n;
		while (l != r) {
			if (arr[l] + arr[r] == sum) {
				System.out.println(arr[l] + "," + arr[r]);
				return;
			}
			if (arr[l] + arr[r] < sum) {
				l = (l + 1) % n;
			} else {
				r = (n + r - 1) % n;
			}
		}
		System.out.println("NO Pair");
	}
}


 ===================================================== 


ReversalAlgorithm.java


/*
rotate(arr[], d, n)
  reverse(arr[], 1, d) ;
  reverse(arr[], d + 1, n);
  reverse(arr[], 1, n);
 */

package DataStructures.Arrays.Rotations;

import Commons.ArrayPrinter;

public class ReversalAlgorithm {
	public static void main(String[] args) {
		int[] arr = {1, 2, 3, 4, 5, 6, 7};
		int n = arr.length;
		int d = 2;
		leftRotate(arr, n, d);
	}

	private static void leftRotate(int[] arr, int n, int d) {
		d = d % n;
		if (d == 0) {
			return;
		}
		reverseArray(arr, 0, d - 1);
		reverseArray(arr, d, n - 1);
		reverseArray(arr, 0, n - 1);
		new ArrayPrinter().printArray(arr, arr.length);
	}

	private static void reverseArray(int[] arr, int start, int end) {
		int temp;
		while (start < end) {
			temp = arr[start];
			arr[start] = arr[end];
			arr[end] = temp;
			start++;
			end--;
		}
	}
}


 ===================================================== 


SearchingInSortedRotatedArray.java


/*
1) Find middle point mid = (l + h)/2
2) If key is present at middle point, return mid.
3) Else If arr[l..mid] is sorted
    a) If key to be searched lies in range from arr[l]
       to arr[mid], recur for arr[l..mid].
    b) Else recur for arr[mid+1..h]
4) Else (arr[mid+1..h] must be sorted)
    a) If key to be searched lies in range from arr[mid+1]
       to arr[h], recur for arr[mid+1..h].
    b) Else recur for arr[l..mid]
 */

package DataStructures.Arrays.Rotations;

public class SearchingInSortedRotatedArray {
	private static int search(int[] arr, int l, int h, int key) {
		if (l > h) {
			return -1;
		}
		int mid = (l + h) / 2;
		if (arr[mid] == key) {
			return mid;
		}
		if (arr[l] <= arr[mid]) {
			/* As this subarray is sorted, we
               can quickly check if key lies in
               half or other half */
			if (key >= arr[l] && key <= arr[mid]) {
				return search(arr, l, mid - 1, key);
			}
			/*If key not lies in first half subarray,
           Divide other half  into two subarrays,
           such that we can quickly check if key lies
           in other half */
			return search(arr, mid + 1, h, key);
		}

		/* If arr[l..mid] first subarray is not sorted,
           then arr[mid... h] must be sorted subarry*/
		if (key >= arr[mid] && key <= arr[h]) {
			return search(arr, mid + 1, h, key);
		}
		return search(arr, l, mid - 1, key);
	}

	private static void findElement(int[] arr, int n, int key) {
		System.out.println(search(arr, 0, n - 1, key));
	}

	public static void main(String[] args) {
		int[] arr = {4, 5, 6, 7, 8, 9, 1, 2, 3};
		int key = 6;
		findElement(arr, arr.length, key);
	}
}


 ===================================================== 


ArrayLevelOrderTraversal.java


/*
Check if the given array can represent Level Order Traversal of Binary Search Tree

Given an array of size n.
The problem is to check whether the given array can represent the level order traversal
of a Binary Search Tree or not.

Examples:

Input : arr[] = {7, 4, 12, 3, 6, 8, 1, 5, 10}
Output : Yes
For the given arr[] the Binary Search Tree is:
         7
       /    \
      4     12
     / \    /
    3   6  8
   /   /    \
  1   5     10

Input : arr[] = {11, 6, 13, 5, 12, 10}
Output : No
The given arr[] do not represent the level
order traversal of a BST.

Approach =>
The idea is to use a queue data structure.
Every element of queue has a structure say NodeDetails which stores details of a tree node.
The details are nodes data, and two variables min and max where min stores the lower limit
for the node values which can be a part of the left subtree and max stores the upper limit
for the node values which can be a part of the right subtree for the specified node in
NodeDetails structure variable. For the 1st array value arr[0], create a NodeDetails
structure having arr[0] as nodes data and min = INT_MIN and max = INT_MAX.
Add this structure variable to the queue. This Node will be the root of the tree.

Move to 2nd element in arr[] and then perform the following steps:
	Pop NodeDetails from the queue in temp.
	Check whether the current array element can be a left child of the node in temp
		with the help of min and temp.data values. If it can, then create a new
		NodeDetails structure for this new array element value with its proper min and max
		values and push it to the queue, and move to next element in arr[].
	Check whether the current array element can be a right child of the node in temp with
		the help of max and temp.data values. If it can, then create a new NodeDetails
		structure for this new array element value with its proper min and max
		values and push it to the queue, and move to next element in arr[].
	Repeat steps 1, 2 and 3 until there are no more elements in arr[] or there are
		no more elements in the queue.

https://www.geeksforgeeks.org/check-given-array-can-represent-level-order-traversal-binary-search-tree/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import java.util.LinkedList;
import java.util.Queue;

public class ArrayLevelOrderTraversal {
	public static void main(String[] args) {
		int[] arr = {7, 4, 12, 3, 6, 8, 1, 5, 10};
		System.out.println(checkRepresentation(arr, arr.length));
		int[] arr2 = {11, 6, 13, 5, 12, 10};
		System.out.println(checkRepresentation(arr2, arr2.length));
	}

	private static boolean checkRepresentation(int[] arr, int V) {
		Queue<NodeDetails> queue = new LinkedList<>();
		queue.add(new NodeDetails(arr[0], -99999, 99999));
		NodeDetails current;
		int index = 1;
		while (!queue.isEmpty() && (index < V)) {
			current = queue.poll();
			if (arr[index] < current.data && arr[index] > current.min) {
				queue.add(new NodeDetails(arr[index], current.min, current.data));
				index++;
			}

			if (arr[index] > current.data && arr[index] < current.max) {
				queue.add(new NodeDetails(arr[index], current.data, current.max));
				index++;
			}
		}

		return index == V;
	}

	static class NodeDetails {
		int data, min, max;

		public NodeDetails(int data, int min, int max) {
			this.data = data;
			this.min = min;
			this.max = max;
		}
	}
}


 ===================================================== 


ArrayPreorderTraversal.java


/*
Check if a given array can represent Preorder Traversal of Binary Search Tree

Given an array of numbers, return true if given array can represent preorder traversal
of a Binary Search Tree, else return false. Expected time complexity is O(n).

Examples:

Input:  pre[] = {2, 4, 3}
Output: true
Given array can represent preorder traversal
of below tree
    2
     \
      4
     /
    3

Input:  pre[] = {2, 4, 1}
Output: false
Given array cannot represent preorder traversal
of a Binary Search Tree.

Input:  pre[] = {40, 30, 35, 80, 100}
Output: true
Given array can represent preorder traversal
of below tree
     40
   /   \
 30    80
  \      \
  35     100


Input:  pre[] = {40, 30, 35, 20, 80, 100}
Output: false
Given array cannot represent preorder traversal
of a Binary Search Tree.

Approach =>
An Efficient Solution can solve this problem in O(n) time. The idea is to use a stack.
This problem is similar to Next (or closest) Greater Element problem.
Here we find the next greater element and after finding next greater,
if we find a smaller element, then return false.

1) Create an empty stack.
2) Initialize root as INT_MIN.
3) Do following for every element pre[i]
     a) If pre[i] is smaller than current root, return false.
     b) Keep removing elements from stack while pre[i] is greater
        then stack top. Make the last removed item as new root (to
        be compared next).
        At this point, pre[i] is greater than the removed root
        (That is why if we see a smaller element in step a), we
        return false)
     c) push pre[i] to stack (All elements in stack are in decreasing
        order)


https://www.geeksforgeeks.org/check-if-a-given-array-can-represent-preorder-traversal-of-binary-search-tree/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import java.util.Stack;

public class ArrayPreorderTraversal {
	public static void main(String[] args) {
		int[] pre1 = {2, 4, 3};
		int[] pre2 = {2, 4, 1};
		int[] pre3 = {40, 30, 35, 80, 100};
		int[] pre4 = {40, 30, 35, 20, 80, 100};
		System.out.println(checkIfPreorder(pre1, pre1.length));
		System.out.println(checkIfPreorder(pre2, pre2.length));
		System.out.println(checkIfPreorder(pre3, pre3.length));
		System.out.println(checkIfPreorder(pre4, pre4.length));
	}

	private static boolean checkIfPreorder(int[] preorder, int n) {
		Stack<Integer> stack = new Stack<>();
		int root = Integer.MIN_VALUE;
		for (int i = 0; i < n; i++) {
			if (preorder[i] < root) {
				return false;
			}

			while (!stack.isEmpty() && preorder[i] > stack.peek()) {
				root = stack.pop();
			}
			stack.push(preorder[i]);
		}
		return true;
	}
}


 ===================================================== 


BinaryTreeIsBST.java


/*
A program to check if a binary tree is BST or not

A better solution looks at each node only once.
The trick is to write a utility helper function isBSTUtil(struct node* node, int min, int max)
that traverses down the tree keeping track of the narrowing min and max allowed values as it goes,
looking at each node only once.
The initial values for min and max should be INT_MIN and INT_MAX  they narrow from there.

https://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.Node;

public class BinaryTreeIsBST {
	private static boolean traverseBST(Node root, int min, int max) {
		if (root == null) {
			return true;
		}

		if (root.data < min || root.data > max) {
			return false;
		}

		// if left => min = min, max = current data-1
		// if right => min = current data+1, max = max
		return traverseBST(root.left, min, root.data - 1)
				&& traverseBST(root.right, root.data + 1, max);
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(4);
		root.left = new Node(2);
		root.right = new Node(5);
		root.left.left = new Node(1);
		root.left.right = new Node(3);
		System.out.println(traverseBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE));
	}
}


 ===================================================== 


ClosestElementToN.java


/*
Largest number in BST which is less than or equal to N

We follow recursive approach for solving this problem.
We start searching for element from root node. If we reach a leaf and its value is greater than N,
element does not exist so return -1. Else if nodes value is less than or equal to N and
right value is NULL or greater than N, then return the node value as it will be the answer.
Otherwise if nodes value is greater than N, then search for the element in the left
subtree else search for the element in the right subtree by calling the same function
by passing the left or right values accordingly.

https://www.geeksforgeeks.org/largest-number-bst-less-equal-n/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.BinarySearchTree;
import Commons.Node;

public class ClosestElementToN {
	private static int findElement(Node root, int N) {
		if (root == null) {
			return -1;
		}

		if (root.data <= N &&
				(root.right == null || root.right.data > N)) {
			return root.data;
		}

		if (root.data > N) {
			return findElement(root.left, N);
		} else if (root.data < N) {
			return findElement(root.right, N);
		}

		return -1;
	}

	public static void main(String[] args) {
		BinarySearchTree bst = new BinarySearchTree();
		Node root = bst.insert(null, 25);
		bst.insert(root, 2);
		bst.insert(root, 1);
		bst.insert(root, 3);
		bst.insert(root, 12);
		bst.insert(root, 9);
		bst.insert(root, 21);
		bst.insert(root, 19);
		bst.insert(root, 5);
		int N = 22;
		System.out.println(findElement(root, N));
	}
}


 ===================================================== 


DeadEnd.java


/*
Simple Recursive solution to check whether BST contains dead end
Given a Binary Search Tree that contains positive integer values greater than 0.
The task is to check whether the BST contains a dead end or not.
Here Dead End means, we are not able to insert any integer element after that node.

Examples:

Input :        8
             /   \
           5      9
         /   \
        2     7
       /
      1
Output : Yes
Explanation : Node "1" is the dead End because
         after that we cant insert any element.

Input :       8
            /   \
           7     10
         /      /   \
        2      9     13

Output :Yes
Explanation : We can't insert any element at
              node 9.

First of all, it is given that it is a BST and nodes are greater than zero, root node can be
in the range [1, ] and if root val is say, val, then left sub-tree can have the value in the
range [1, val-1] and right sub-tree the value in range [val+1, ].
we need to traverse recursively and when the the min and max value of range coincided
it means that we cannot add any node further in the tree.
Hence we encounter a dead end.

https://www.geeksforgeeks.org/simple-recursive-solution-check-whether-bst-contains-dead-end/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.BinarySearchTree;
import Commons.Node;

public class DeadEnd {
	private static boolean deadEndExists(Node root, int min, int max) {
		if (root == null) {
			return false;
		}

		if (min == max) {
			return true;
		}

		return deadEndExists(root.left, min, root.data - 1)
				|| deadEndExists(root.right, root.data + 1, max);
	}

	public static void main(String[] args) {
		BinarySearchTree tree = new BinarySearchTree();
		Node root;

        /*       8
               /   \
              5    11
             /  \
            2    7
             \
              3
               \
                4 */
		root = tree.insert(null, 8);
		tree.insert(root, 5);
		tree.insert(root, 2);
		tree.insert(root, 3);
		tree.insert(root, 7);
		tree.insert(root, 11);
		tree.insert(root, 4);
		System.out.println(deadEndExists(root, Integer.MIN_VALUE, Integer.MAX_VALUE));
	}
}


 ===================================================== 


FixBST.java


/*
Remove BST keys outside the given range

There are two possible cases for every node.
1) Nodes key is outside the given range. This case has two sub-cases.
.a) Nodes key is smaller than the min value.
.b) Nodes key is greater that the max value.
2) Nodes key is in range.

We dont need to do anything for case 2.
In case 1, we need to remove the node and change root of sub-tree rooted with this node.
The idea is to fix the tree in Postorder fashion. When we visit a node,
we make sure that its left and right sub-trees are already fixed.
In case 1.a), we simply remove root and return right sub-tree as new root.
In case 1.b), we remove root and return left sub-tree as new root.

https://www.geeksforgeeks.org/remove-bst-keys-outside-the-given-range/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.BinarySearchTree;
import Commons.Node;
import DataStructures.BinaryTree.Traversals.TreeTraversalBasics;

public class FixBST {
	private static Node fixBST(Node root, int min, int max) {
		if (root == null) {
			return null;
		}

		root.left = fixBST(root.left, min, max);
		root.right = fixBST(root.right, min, max);

		if (root.data < min) {
			root = root.right;
		}

		if (root.data > max) {
			root = root.left;
		}

		return root;
	}

	public static void main(String[] args) {
		BinarySearchTree bst = new BinarySearchTree();
		Node root = bst.insert(null, 6);
		bst.insert(root, -13);
		bst.insert(root, 14);
		bst.insert(root, -8);
		bst.insert(root, 15);
		bst.insert(root, 13);
		bst.insert(root, 7);

		TreeTraversalBasics.inOrder(root);
		System.out.println();
		int min = -10, max = 13;
		root = fixBST(root, min, max);
		TreeTraversalBasics.inOrder(root);
		System.out.println();
	}
}


 ===================================================== 


InorderPredAndSucc.java


package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.BinarySearchTree;
import Commons.Node;

public class InorderPredAndSucc {
	private static Node max = new Node(0),
			min = new Node(0);

	private static void findLimit(Node node, boolean findMax) {
		if (node == null) {
			return;
		}
		if (findMax) {
			if (node.data > max.data) {
				max = node;
			}
		} else {
			if (node.data < min.data) {
				min = node;
			}
		}
		findLimit(node.left, findMax);
		findLimit(node.right, findMax);
	}

	private static void findPredAndSucc(Node root, int element) {
		if (root == null) {
			return;
		}

		if (root.data == element) {
			if (root.left != null) {
				max = new Node(Integer.MIN_VALUE);
				findLimit(root.left, true);
			}
			if (root.right != null) {
				min = new Node(Integer.MAX_VALUE);
				findLimit(root.right, false);
			}
			return;
		}

		if (root.data > element) {
			min = root;
			findPredAndSucc(root.left, element);
		} else {
			max = root;
			findPredAndSucc(root.right, element);
		}
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		min = new Node(Integer.MAX_VALUE, null, null);
		BinarySearchTree tree = new BinarySearchTree();
		Node root = tree.insert(null, 20);
		tree.insert(root, 8);
		tree.insert(root, 22);
		tree.insert(root, 4);
		tree.insert(root, 12);
		tree.insert(root, 10);
		tree.insert(root, 14);
		int n = 10;
		findPredAndSucc(root, n);
		System.out.println("pred => " + max.data);
		System.out.println("succ => " + min.data);
	}
}


 ===================================================== 


InorderSuccessor.java


/*
Inorder Successor in Binary Search Tree

If right subtree of node is not NULL, then succ lies in right subtree. Do the following.
Go to right subtree and return the node with minimum key value in the right subtree.
If right subtree of node is NULL, then start from the root and use search like technique.
Do the following.
Travel down the tree, if a nodes data is greater than roots data then go right side,
otherwise, go to left side.

https://www.geeksforgeeks.org/inorder-successor-in-binary-search-tree/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.BinarySearchTree;
import Commons.Node;

public class InorderSuccessor {
	private static Node min;

	private static Node findSuccessor(Node node, Node element) {
		if (node == null) {
			return null;
		}

		if (element.right != null) {
			return findMinimum(node.right);
		}

		Node succ = null;
		while (node != null) {
			if (element.data < node.data) {
				succ = node;
				node = node.left;
			} else if (element.data > node.data) {
				node = node.right;
			} else {
				break;
			}
		}
		return succ;
	}

	private static Node findMinimum(Node node) {
		if (node == null) {
			return null;
		}
		if (min.data > node.data) {
			min = node;
		}
		findMinimum(node.left);
		findMinimum(node.right);
		return min;
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		min = new Node(Integer.MAX_VALUE, null, null);
		BinarySearchTree tree = new BinarySearchTree();
		Node root = tree.insert(null, 20);
		tree.insert(root, 8);
		tree.insert(root, 22);
		tree.insert(root, 4);
		tree.insert(root, 12);
		tree.insert(root, 10);
		tree.insert(root, 14);
		Node n = root.left.right.right;
		System.out.println(findSuccessor(root, n).data);
	}
}


 ===================================================== 


KthSmallestElement.java


/*
Kth Largest Element in BST when modification to BST is not allowed

In this post, a method is discussed that takes O(h + k) time.
This method doesnt require any change to BST.
h => height of the tree, k => kth element

The idea is to do reverse inorder traversal of BST.
The reverse inorder traversal traverses all nodes in decreasing order.
While doing the traversal, we keep track of count of nodes visited so far.
When the count becomes equal to k, we stop the traversal and print the key.

https://www.geeksforgeeks.org/kth-largest-element-in-bst-when-modification-to-bst-is-not-allowed/
*/
package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.BinarySearchTree;
import Commons.Node;

public class KthSmallestElement {
	public static void main(String[] args) {
		BinarySearchTree bst = new BinarySearchTree();
		Node root = bst.insert(null, 50);
		bst.insert(root, 30);
		bst.insert(root, 20);
		bst.insert(root, 40);
		bst.insert(root, 70);
		bst.insert(root, 60);
		bst.insert(root, 80);

		for (int k = 1; k <= 7; k++)
			System.out.print(kthSmallest(root, k) + " ");
	}

	private static int kthSmallest(Node root, int k) {
		int kSmall = 0, count = 0;
		Node pre, current = root;
		while (current != null) {
			if (current.left == null) {
				count++;
				if (count == k) {
					kSmall = current.data;
				}
				current = current.right;
			} else {
				pre = current.left;
				while (pre.right != null && pre.right != current) {
					pre = pre.right;
				}

				if (pre.right == null) {
					pre.right = current;
					current = current.left;
				} else {
					pre.right = null;
					count++;
					if (count == k) {
						kSmall = current.data;
					}
					current = current.right;
				}
			}
		}
		return kSmall;
	}
}


 ===================================================== 


ReplaceWithLeastGreatestOnRight.java


/*
Replace every element with the least greater element on its right
Given an array of integers, replace every element with the least greater element on its
right side in the array. If there are no greater element on right side, replace it with -1.

Examples:

Input: [8, 58, 71, 18, 31, 32, 63, 92,
         43, 3, 91, 93, 25, 80, 28]
Output: [18, 63, 80, 25, 32, 43, 80, 93,
         80, 25, 93, -1, 28, -1, -1]

A tricky solution would be to use Binary Search Trees.
We start scanning the array from right to left and insert each element into the BST.
For each inserted element, we replace it in the array by its inorder successor in BST.
If the element inserted is the maximum so far (i.e. its inorder successor doesnt exists),
we replace it by -1.
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.ArrayPrinter;
import Commons.BinarySearchTree;
import Commons.Node;

import java.util.ArrayList;

public class ReplaceWithLeastGreatestOnRight {
	private static ArrayList<Integer> list;

	private static void inorder(Node root) {
		if (root == null) {
			return;
		}
		inorder(root.left);
		list.add(root.data);
		inorder(root.right);
	}

	private static int[] replace(int[] arr, int n) {
		BinarySearchTree tree = new BinarySearchTree();
		int[] newArray = new int[n];
		Node root = null;
		int index;
		for (int i = 0; i < n; i++) {
			tree.insert(root, arr[i]);
			list = new ArrayList<>();
			inorder(root);
			index = list.indexOf(arr[i]);
			if (index < list.size() - 1) {
				newArray[i] = list.get(index + 1);
			} else {
				newArray[i] = -1;
			}
		}

		return newArray;
	}

	public static void main(String[] args) {
		int[] arr = {8, 58, 71, 18, 31, 32, 63, 92,
				43, 3, 91, 93, 25, 80, 28};
		new ArrayPrinter().printArray(arr, arr.length);
		System.out.println("\nAfter => ");
		new ArrayPrinter().printArray(replace(arr, arr.length), arr.length);
	}
}


 ===================================================== 


ShortestDistanceBetweenNodes.java


/*
Shortest distance between two nodes in BST
Given a Binary Search Tree and two keys in it.
Find the distance between two nodes with given two keys.
It may be assumed that both keys exist in BST.

In the case of BST, we can find the distance faster. We start from the root and for every node,
we do following.
	If both keys are greater than the current node, we move to the right child of the current node.
	If both keys are smaller than current node, we move to left child of current node.
	If one keys is smaller and other key is greater, current node is Lowest Common Ancestor (LCA)
		of two nodes. We find distances of current node from two keys and return sum of the distances.


https://www.geeksforgeeks.org/shortest-distance-between-two-nodes-in-bst/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.BinarySearchTree;
import Commons.Node;

public class ShortestDistanceBetweenNodes {
	private static int distance(Node root, int element) {
		if (root == null || root.data == element) {
			return 0;
		}

		if (root.data > element) {
			return 1 + distance(root.left, element);
		} else {
			return 1 + distance(root.right, element);
		}
	}

	private static int getShortestDistance(Node root, int n1, int n2) {
		if (root == null) {
			return 0;
		}

		if (n1 > root.data && n2 > root.data) {
			return getShortestDistance(root.right, n1, n2);
		}

		if (n1 < root.data && n2 < root.data) {
			return getShortestDistance(root.left, n1, n2);
		}

		if (n1 <= root.data && n2 >= root.data) {
			return distance(root, n1) +
					distance(root, n2);
		}

		return 0;
	}

	public static void main(String[] args) {
		BinarySearchTree bst = new BinarySearchTree();
		Node root = bst.insert(null, 20);
		bst.insert(root, 10);
		bst.insert(root, 5);
		bst.insert(root, 15);
		bst.insert(root, 30);
		bst.insert(root, 25);
		bst.insert(root, 35);
		System.out.println(getShortestDistance(root, 5, 35));
	}
}


 ===================================================== 


SortedSubsequenceExists.java


/*
Check if given sorted sub-sequence exists in binary search tree

An efficient solution is to match elements of sub-sequence while we are traversing BST
in inorder fashion. We take index as a iterator for given sorted sub-sequence and
start inorder traversal of given bst, if current node matches with seq[index]
then move index in forward direction by incrementing 1 and after complete traversal of BST
if index==n that means all elements of given sub-sequence have been matched and exist as a
sorted sub-sequence in given BST.

https://www.geeksforgeeks.org/check-if-given-sorted-sub-sequence-exists-in-binary-search-tree/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.BinarySearchTree;
import Commons.GlobalVar;
import Commons.Node;

public class SortedSubsequenceExists {
	private static void traverseAndCheck(Node root, int[] arr, GlobalVar index) {
		if (root == null) {
			return;
		}
		traverseAndCheck(root.left, arr, index);
		if (root.data == arr[index.var]) {
			index.var++;
		}
		traverseAndCheck(root.right, arr, index);
	}

	private static boolean subsequenceExists(Node root, int[] arr, int n) {
		GlobalVar index = new GlobalVar(0);
		traverseAndCheck(root, arr, index);
		return index.var == n;
	}

	public static void main(String[] args) {
		BinarySearchTree bst = new BinarySearchTree();
		Node root;
		root = bst.insert(null, 8);
		bst.insert(root, 10);
		bst.insert(root, 3);
		bst.insert(root, 6);
		bst.insert(root, 1);
		bst.insert(root, 4);
		bst.insert(root, 7);
		bst.insert(root, 14);
		bst.insert(root, 13);

		int[] seq1 = {4, 6, 8, 14};
		int[] seq2 = {4, 6, 8, 12, 13};

		System.out.println(subsequenceExists(root, seq1, seq1.length));
		System.out.println(subsequenceExists(root, seq2, seq2.length));
	}
}


 ===================================================== 


SumOfKSmallestElements.java


/*
Input :  K = 3
              8
            /   \
           7     10
         /      /   \
        2      9     13
Output : 17
Explanation : Kth smallest element is 8 so sum of all
              element smaller then or equal to 8 are
              2 + 7 + 8

Approach =>
The idea is to traverse BST in inorder traversal.
Note that Inorder traversal of BST accesses elements in sorted (or increasing) order.
While traversing, we keep track of count of visited Nodes and keep adding Nodes
until the count becomes k.
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import Commons.BinarySearchTree;
import Commons.Node;

import java.util.ArrayList;

@SuppressWarnings("Duplicates")
public class SumOfKSmallestElements {
	private static ArrayList<Integer> list;

	public static void main(String[] args) {
		/*    20
			/    \
		   8     22
		 /   \
		4     12
			 /   \
			10    14
          */
		BinarySearchTree bst = new BinarySearchTree();
		Node root = bst.insert(null, 20);
		bst.insert(root, 8);
		bst.insert(root, 4);
		bst.insert(root, 12);
		bst.insert(root, 10);
		bst.insert(root, 14);
		bst.insert(root, 22);
		int k = 3;
		list = new ArrayList<>();
		inorderTraversal(root);
		int sum = 0;
		for (int i = 0; i < k; i++) {
			sum += list.get(i);
		}
		System.out.println(sum);
	}

	private static void inorderTraversal(Node root) {
		if (root == null) {
			return;
		}
		inorderTraversal(root.left);
		list.add(root.data);
		inorderTraversal(root.right);
	}
}


 ===================================================== 


UniqueNumberInSubSequence.java


/*
Maximum Unique Element in every subarray of size K
Given an array and an integer K.
We need to find the maximum of every segment of length K which has no duplicates in that segment.

Examples:

Input : a[] = {1, 2, 2, 3, 3},
          K = 3.
Output : 1 3 2
For segment (1, 2, 2), Maximum = 1.
For segment (2, 2, 3), Maximum = 3.
For segment (2, 3, 3), Maximum = 2.

Input : a[] = {3, 3, 3, 4, 4, 2},
          K = 4.
Output : 4 Nothing 3

An efficient solution is to use sliding window technique. We maintain two structures in every window.
1) A hash table to store counts of all elements in current window.
2) A self balancing BST (implemented using set in C++ STL and TreeSet in Java).
The idea is to quickly find maximum element and update maximum element.

We process first K-1 elements and store their counts in hash table.
We also store unique elements in set. Now we one by one process last element of every window.
If current element is unique, we add it to set. We also increase its count.
After processing last element, we print maximum from set. Before starting next iteration,
we remove first element of previous window.

https://www.geeksforgeeks.org/maximum-unique-element-every-subarray-size-k/
 */

package DataStructures.BinarySearchTree.CheckingAndPrinting;

import java.util.HashMap;
import java.util.Map;
import java.util.TreeSet;

public class UniqueNumberInSubSequence {
	public static void main(String[] args) {
		int[] a = {3, 3, 3, 4, 4, 2},
				b = {1, 2, 2, 3, 3};
		int Ka = 4,
				Kb = 3;
		findMaxUnique(a, a.length, Ka);
		System.out.println();
		findMaxUnique(b, b.length, Kb);
	}

	private static void findMaxUnique(int[] arr, int n, int k) {
		TreeSet<Integer> set = new TreeSet<>();
		HashMap<Integer, Integer> map = new HashMap<>();
		for (int i = 0; i < k - 1; i++) {
			if (map.containsKey(arr[i])) {
				map.put(arr[i], map.get(arr[i]) + 1);
			} else {
				map.put(arr[i], 1);
			}
		}

		for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
			if (entry.getValue() == 1) {
				set.add(entry.getKey());
			}
		}

		for (int i = k - 1; i < n; i++) {
			if (map.containsKey(arr[i])) {
				map.put(arr[i], map.get(arr[i]) + 1);
			} else {
				map.put(arr[i], 1);
			}

			if (map.get(arr[i]) == 1) {
				set.add(arr[i]);
			} else {
				set.remove(arr[i]);
			}

			// Set is empty => No element is unique
			if (set.size() == 0) {
				System.out.print("Nothing ");
			} else {
				System.out.print(set.last() + " ");
			}

			// Remove first element of current
			// window before next iteration.
			int x = arr[i - k + 1];
			map.put(x, map.get(x) - 1);
			if (map.get(x) == 1) {
				set.add(x);
			} else {
				set.remove(x);
			}
		}
	}
}


 ===================================================== 


BinarySumTree.java


/*
Check if a given Binary Tree is SumTree
A SumTree is a Binary Tree where the value of a node is equal to sum of the nodes present in its
left subtree and right subtree. An empty tree is SumTree and sum of an empty tree can be considered as 0.
A leaf node is also considered as SumTree.

Following is an example of SumTree.
          26
        /   \
      10     3
    /    \     \
  4      6      3

This method uses following rules to get the sum directly.
1) If the node is a leaf node then sum of subtree rooted with this node is equal to value of this node.
2) If the node is not a leaf node then sum of subtree rooted with this node is twice the value of this node
(Assuming that the tree rooted with this node is SumTree).
 */

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

@SuppressWarnings("Duplicates")
public class BinarySumTree {
	private static boolean isLeaf(Node root) {
		if (root == null) {
			return false;
		}
		return root.left == null && root.right == null;
	}

	private static boolean isSumTree(Node root) {
		int left = 0, right = 0;
		if (root == null || isLeaf(root)) {
			return true;
		}
		if (isSumTree(root.left) && isSumTree(root.right)) {
			if (root.left != null) {
				if (isLeaf(root.left)) {
					left = root.left.data;
				} else {
					left = 2 * root.left.data;
				}
			}
			if (root.right != null) {
				if (isLeaf(root.right)) {
					right = root.right.data;
				} else {
					right = 2 * root.right.data;
				}
			}
			return (root.data == (left + right));
		}
		return false;
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(26);
		root.left = new Node(10);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(6);
		root.right.right = new Node(3);
		System.out.println(isSumTree(root));
	}
}


 ===================================================== 


ChildSumProperty.java


/*
Check for Children Sum Property in a Binary Tree

Given a binary tree, write a function that returns true if the tree satisfies below property.
For every node, data value must be equal to sum of data values in left and right children.
Consider data value as 0 for NULL children. Below tree is an example

https://www.geeksforgeeks.org/check-for-children-sum-property-in-a-binary-tree/
 */

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

public class ChildSumProperty {
	private static boolean childSum(Node root) {
		int sum = 0;
		if (root == null ||
				(root.left == null && root.right == null)) {
			return true;
		}
		if (root.left != null) {
			sum += root.left.data;
		}
		if (root.right != null) {
			sum += root.right.data;
		}
		return (sum == root.data) &&
				childSum(root.left) &&
				childSum(root.right);
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(10);
		root.left = new Node(8);
		root.right = new Node(2);
		root.left.left = new Node(3);
		root.left.right = new Node(5);
		root.right.right = new Node(2);
		System.out.println(childSum(root));
	}
}


 ===================================================== 


FullBinaryTree.java


/*
Full Binary Tree

To check whether a binary tree is a full binary tree we need to test the following cases:-

1) If a binary tree node is NULL then it is a full binary tree.
2) If a binary tree node does have empty left and right sub-trees, then
	it is a full binary tree by definition.
3) If a binary tree node has left and right sub-trees, then it is a
	part of a full binary tree by definition.
	In this case recursively check if the left and right sub-trees are also binary trees themselves.
4) In all other combinations of right and left sub-trees, the binary tree is not a full binary tree.

https://www.geeksforgeeks.org/check-whether-binary-tree-full-binary-tree-not/
 */
package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

public class FullBinaryTree {
	private static boolean isFull(Node root) {
		if (root == null) {
			return true;
		}
		if (root.left == null && root.right == null) {
			return true;
		}
		if (root.left != null && root.right != null) {
			return isFull(root.left) && isFull(root.right);
		} else {
			return false;
		}
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(10);
		root.left = new Node(20);
		root.right = new Node(30);
		root.left.right = new Node(40);
		root.left.left = new Node(50);
		root.right.left = new Node(60);
		root.left.left.left = new Node(80);
		root.right.right = new Node(70);
		root.left.left.right = new Node(90);
		root.left.right.left = new Node(80);
		root.left.right.right = new Node(90);
		root.right.left.left = new Node(80);
		root.right.left.right = new Node(90);
		root.right.right.left = new Node(80);
		root.right.right.right = new Node(90);

		System.out.println(isFull(root));
	}
}


 ===================================================== 


GraphIsATree.java


/*
Check whether the given graph is a Tree or not

An undirected graph is tree if it has following properties.
1) There is no cycle.
2) The graph is connected.

How to detect cycle in an undirected graph?
We can either use BFS or DFS. For every visited vertex v, if there is an adjacent u
such that u is already visited and u is not parent of v, then there is a cycle in graph.
If we dont find such an adjacent for any vertex, we say that there is no cycle

How to check for connectivity?
Since the graph is undirected, we can start BFS or DFS from any vertex and check
if all vertices are reachable or not. If all vertices are reachable, then graph is connected,
otherwise not.

https://www.geeksforgeeks.org/check-given-graph-tree/
 */

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.GraphMatrix;

public class GraphIsATree {
	private static boolean checkCycle(int[][] graph, int V, int node, int parent, boolean[] visited) {
		visited[node] = true;

		for (int v = 0; v < V; v++) {
			if (graph[node][v] == 1) {
				if (!visited[v]) {
					if (checkCycle(graph, V, v, node, visited)) {
						return true;
					}
				} else if (v != parent) {
					return true;
				}
			}
		}
		return false;
	}

	private static boolean isTree(int[][] graph, int V) {
		boolean[] visited = new boolean[V];
		if (checkCycle(graph, V, 0, -1, visited)) {
			return false;
		}
		for (int v = 0; v < V; v++) {
			if (!visited[v]) {
				return false;
			}
		}
		return true;
	}

	public static void main(String[] args) {
		GraphMatrix g1 = new GraphMatrix(5, false, true);
		g1.addEdge(1, 0);
		g1.addEdge(0, 2);
		g1.addEdge(0, 3);
		g1.addEdge(3, 4);

		GraphMatrix g2 = new GraphMatrix(5, false, true);
		g2.addEdge(1, 0);
		g2.addEdge(0, 2);
		g2.addEdge(2, 1);
		g2.addEdge(0, 3);
		g2.addEdge(3, 4);

		System.out.println(isTree(g1.getGraph(), g1.getGraph().length));
		System.out.println(isTree(g2.getGraph(), g2.getGraph().length));
	}
}


 ===================================================== 


LeavesAtSameLevel.java


/*
Check if all leaves are at same level

          12
        /    \
      5       7
    /          \
   3            1
  Leaves are at same level

          12
        /    \
      5       7
    /
   3
   Leaves are Not at same level


          12
        /
      5
    /   \
   3     9
  /      /
 1      2
 Leaves are at same level

Approach =>
	The idea is to first find level of the leftmost leaf and store it in a variable leafLevel. T
	hen compare level of all other leaves with leafLevel, if same, return true, else return false.
	We traverse the given Binary Tree in Preorder fashion. An argument leafLevel is passed to all calls.
	The value of leafLevel is initialized as 0 to indicate that the first leaf is not yet seen yet.
	The value is updated when we find first leaf.
	Level of subsequent leaves (in preorder) is compared with leafLevel.

https://www.geeksforgeeks.org/check-leaves-level/
 */

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

@SuppressWarnings("Duplicates")
public class LeavesAtSameLevel {
	private static int leftLeafLevel(Node root) {
		if (root.left == null && root.right == null) {
			return 0;
		}
		if (root.left != null) {
			return 1 + leftLeafLevel(root.left);
		} else {
			return 0;
		}
	}

	private static boolean isLeaf(Node root) {
		if (root == null) {
			return false;
		}
		return root.left == null && root.right == null;
	}

	private static boolean checkSameLevel(Node root, int level, int currentLevel) {
		if (root == null) {
			return true;
		}
		if (isLeaf(root)) {
			return level == currentLevel;
		} else {
			return checkSameLevel(root.left, level, currentLevel + 1)
					&& checkSameLevel(root.right, level, currentLevel + 1);
		}
	}

	private static boolean isSameLevel(Node root) {
		int level = leftLeafLevel(root), currentLevel = 0;
		return checkSameLevel(root, level, currentLevel);
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(12);
		root.left = new Node(5);
		root.left.left = new Node(3);
		root.left.right = new Node(9);
		root.left.left.left = new Node(1);
		root.left.right.left = new Node(1);
		System.out.println(isSameLevel(root));
	}
}


 ===================================================== 


PerfectBinaryTree.java


/*
Check whether a given binary tree is perfect or not

A Binary tree is Perfect Binary Tree in which all internal nodes have two children and
all leaves are at same level.

			   10
           /       \
         20         30
        /  \        /  \
      40    50    60   70

Below is an idea to check whether a given Binary Tree is perfect or not.

Find depth of any node (in below tree we find depth of leftmost node). Let this depth be d.
Now recursively traverse the tree and check for following two conditions.
	Every internal node should have both children non-empty
	All leaves are at depth d

https://www.geeksforgeeks.org/check-weather-given-binary-tree-perfect-not/
 */

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

@SuppressWarnings("Duplicates")
public class PerfectBinaryTree {
	private static int leftLeafLevel(Node root) {
		if (root.left == null && root.right == null) {
			return 0;
		}
		if (root.left != null) {
			return 1 + leftLeafLevel(root.left);
		} else {
			return 0;
		}
	}

	private static boolean checkLeaves(Node root, int leafLevel, int myLevel) {
		if (root == null) {
			return true;
		}

		if (isLeaf(root)) {
			return myLevel == leafLevel;
		} else {
			return checkLeaves(root.left, leafLevel, myLevel + 1)
					&& checkLeaves(root.right, leafLevel, myLevel + 1);
		}
	}

	private static boolean checkInternalNodes(Node root) {
		if (root == null || isLeaf(root)) {
			return true;
		}
		if (root.left != null && root.right != null) {
			return checkInternalNodes(root.left) && checkInternalNodes(root.right);
		} else {
			return false;
		}
	}

	private static boolean isLeaf(Node root) {
		return root.left == null && root.right == null;
	}

	private static boolean isPerfect(Node root) {
		int leafLevel = leftLeafLevel(root);
		return checkLeaves(root, leafLevel, 0)
				&& checkInternalNodes(root);
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(10);
		root.left = new Node(20);
		root.right = new Node(30);

		root.left.left = new Node(40);
		root.left.right = new Node(50);
		root.right.left = new Node(60);
		root.right.right = new Node(70);

		System.out.println(isPerfect(root));
	}
}


 ===================================================== 


PrintDiameter.java


/*
Print the longest leaf to leaf path in a Binary tree
The diameter of a tree (sometimes called the width) is the number of nodes on the longest path
between two end nodes. In this post, we will see how to print the nodes involved in the diameter
of the tree. The diagram below shows two trees each with diameter nine, the leaves that form the
ends of the longest path are shaded (note that there is more than one path in each tree of length
nine, but no path longer than nine nodes).

Input:      1
          /   \
        2      3
      /  \
    4     5

Output : 4 2 1 3
       or 5 2 1 3

Input:      1
          /   \
        2      3
      /  \      \
    4     5      6

Output : 4 2 1 3 6
       or 5 2 1 3 6

Approach =>
We know that Diameter of a tree can be calculated by only using the height function because the
diameter of a tree is nothing but the maximum value of (left_height + right_height + 1) for each node.
Now for the node which has the maximum value of (left_height + right_height + 1), we find the
longest root to leaf path on the left side and similarly on the right side. Finally, we print
left side path, root and right side path.
 */

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

@SuppressWarnings("Duplicates")
public class PrintDiameter {
	private static int height;
	private static int pathLength;

	private static int getHeight(Node root) {
		if (root == null) {
			return 0;
		}
		int left = getHeight(root.left), right = getHeight(root.right);
		height = Math.max(height, 1 + left + right);
		return 1 + Math.max(left, right);
	}

	private static void printPath(Node root, int[] path, int f, int max) {
		if (root == null) {
			return;
		}

		path[pathLength] = root.data;
		pathLength++;

		if (root.left == null && root.right == null) {
			if (pathLength == max && (f == 0 || f == 1)) {
				printArray(path, pathLength, f);
				f = 2;
			}
		} else {
			printPath(root.left, path, f, max);
			printPath(root.right, path, f, max);
		}
	}

	private static void printArray(int[] path, int pathLength, int f) {
		int i;

		// Left path in reverse order
		if (f == 0) {
			for (i = pathLength - 1; i >= 0; i--) {
				System.out.print(path[i] + " => ");
			}
		}

		// right in straight order
		if (f == 1) {
			for (i = 0; i < pathLength; i++) {
				System.out.print(path[i] + " => ");
			}
		}
	}

	private static void printDiameter(Node root) {
		int[] path = new int[100];
		getHeight(root);
		pathLength = 0;
		printPath(root.left, path, 0, height);
		printPath(root.right, path, 1, height);
	}

	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.left.right.left = new Node(6);
		root.left.right.right = new Node(7);
		root.left.left.right = new Node(8);
		root.left.left.right.left = new Node(9);
		printDiameter(root);
	}
}


 ===================================================== 


PrintingTreeIterative.java


/*
Printing a tree using iteration

        6
     /    \
    3      5
  /   \     \
 2     5     4
     /   \
    7     4

There are 4 leaves, hence 4 root to leaf paths -
  6->3->2
  6->3->5->7
  6->3->5->4
  6->5>4

We can traverse tree iteratively (we have used iterative preorder).
The question is, how to extend the traversal to print root to leaf paths?
The idea is to maintain a map to store parent pointers of binary tree nodes.
Now whenever we encounter a leaf node while doing iterative preorder traversal,
we can easily print root to leaf path using parent pointer.

https://www.geeksforgeeks.org/print-root-leaf-path-without-using-recursion/
 */

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

import java.util.HashMap;
import java.util.Stack;

public class PrintingTreeIterative {
	public static void main(String[] args) {
		Node root = new Node(10);
		root.left = new Node(8);
		root.right = new Node(2);
		root.left.left = new Node(3);
		root.left.right = new Node(5);
		root.right.left = new Node(2);

		printPaths(root);
	}

	private static void printPaths(Node root) {
		Stack<Node> stack = new Stack<>();
		HashMap<Node, Node> parent = new HashMap<>();
		stack.push(root);
		parent.put(root, null);

		/* Pop all items one by one. Do following for
        every popped item
            a) push its right child and set its parent
            pointer
            b) push its left child and set its parent
            pointer
        Note that right child is pushed first so that
        left is processed first */
		while (!stack.isEmpty()) {
			root = stack.pop();
			if (root.left == null && root.right == null) {
				printTopToBottomPath(root, parent);
			}

			if (root.right != null) {
				stack.push(root.right);
				parent.put(root.right, root);
			}

			if (root.left != null) {
				stack.push(root.left);
				parent.put(root.left, root);
			}
		}
	}

	private static void printTopToBottomPath(Node root, HashMap<Node, Node> parent) {
		Stack<Node> stack = new Stack<>();
		while (root != null) {
			// Push leaf node
			stack.push(root);
			// Iterate upwards
			root = parent.get(root);
		}

		while (!stack.isEmpty()) {
			root = stack.pop();
			System.out.print(root.data + " => ");
		}
		System.out.println();
	}
}


 ===================================================== 


RootsAtOddLevel.java


/*
Print the nodes at odd levels of a tree

For example consider the following tree
          1
       /     \
      2       3
    /   \       \
   4     5       6
        /  \     /
       7    8   9

Output  1 4 5 6

 */

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

@SuppressWarnings("Duplicates")
public class RootsAtOddLevel {
	private static void nodePrinter(Node root, boolean isOdd) {
		if (root == null) {
			return;
		}
		if (isOdd) {
			System.out.print(root.data + " ");
		}
		if (root.left != null) {
			nodePrinter(root.left, !isOdd);
		}
		if (root.right != null) {
			nodePrinter(root.right, !isOdd);
		}
	}

	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		nodePrinter(root, true);
	}
}


 ===================================================== 


RootToLeafPath.java


/*
Given a binary tree, print out all of its root-to-leaf paths one per line.

Approach =>
initialize: pathlen = 0, path[1000]
1000 is some max limit for paths, it can change

printPathsRecur traverses nodes of tree in preorder
printPathsRecur(tree, path[], pathlen)
		1) If node is not NULL then
			a) push data to path array:
				path[pathlen] = node->data.
			b) increment pathlen
				pathlen++
		2) If node is a leaf node then print the path array.
		3) Else
			a) Call printPathsRecur for left subtree
				printPathsRecur(node->left, path, pathLen)
			b) Call printPathsRecur for right subtree.
				printPathsRecur(node->right, path, pathLen)
*/

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

public class RootToLeafPath {
	private static void printPaths(Node root, int[] path, int pathLength) {
		if (root == null) {
			return;
		}
		path[pathLength] = root.data;
		pathLength++;
		if (root.left == null && root.right == null) {
			for (int i = 0; i < pathLength; i++) {
				System.out.print(path[i] + " => ");
			}
			System.out.println();
		} else {
			printPaths(root.left, path, pathLength);
			printPaths(root.right, path, pathLength);
		}
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		int[] paths = new int[100];
		printPaths(root, paths, 0);
	}
}


 ===================================================== 


SameInPrePost.java


/*
Check if given Preorder, Inorder and Postorder traversals are of same tree

The most basic approach to solve this problem will be to first construct a tree using two of
the three given traversals and then do the third traversal on this constructed tree and compare it
with the given traversal. If both of the traversals are same then print Yes otherwise print No.
Here, we use Inorder and Preorder traversals to construct the tree.

Input : Inorder -> 4 2 5 1 3
        Preorder -> 1 2 4 5 3
        Postorder -> 4 5 2 3 1
Output : Yes
Explanation : All of the above three traversals are of
the same tree
						   1
                         /   \
                        2     3
                      /   \
                     4     5

https://www.geeksforgeeks.org/check-if-given-preorder-inorder-and-postorder-traversals-are-of-same-tree/
 */

package DataStructures.BinaryTree.CheckingAndPrinting;

public class SameInPrePost {
	private static int preIndex = 0, postIndex = 0;
	private static int[] tempPostorder;

	private static void createPostOrder(int[] inorder, int[] preorder,
										int inStart, int inEnd) {
		if (inStart > inEnd) {
			return;
		}
		int index = search(inorder, preorder[preIndex++], inStart, inEnd);

		createPostOrder(inorder, preorder, inStart, index - 1);
		createPostOrder(inorder, preorder, index + 1, inEnd);
		tempPostorder[postIndex] = inorder[index];
		postIndex++;
	}

	private static boolean isSame(int[] inorder, int[] preorder, int[] postorder) {
		int V = inorder.length;
		tempPostorder = new int[V];
		createPostOrder(inorder, preorder, 0, V - 1);
		for (int i = 0; i < V; i++) {
			if (postorder[i] != tempPostorder[i]) {
				return false;
			}
		}
		return true;
	}

	public static void main(String[] args) {
		int[] inOrder = {4, 2, 5, 1, 3};
		int[] preOrder = {1, 2, 4, 5, 3};
		int[] postOrder = {4, 5, 2, 3, 1};
		System.out.println(isSame(inOrder, preOrder, postOrder));
	}

	private static int search(int[] inorder, int data, int start, int end) {
		int pos;
		for (pos = start; pos < end; pos++) {
			if (data == inorder[pos]) {
				return pos;
			}
		}
		return pos;
	}
}


 ===================================================== 


UncoveredAndCovered.java


/*
Check sum of Covered and Uncovered nodes of Binary Tree

Given a binary tree, you need to check whether sum of all covered elements is equal to sum of
all uncovered elements or not.
In a binary tree, a node is called Uncovered if it appears either on left boundary or right boundary.
Rest of the nodes are called covered.

https://www.geeksforgeeks.org/check-sum-covered-uncovered-nodes-binary-tree/
 */

package DataStructures.BinaryTree.CheckingAndPrinting;

import Commons.Node;

public class UncoveredAndCovered {
	private static int totalSum(Node root) {
		if (root == null) {
			return 0;
		} else {
			return root.data + totalSum(root.left) + totalSum(root.right);
		}
	}

	private static int uncoveredSumLeft(Node root) {
		if (root.left == null && root.right == null) {
			return 0;
		}
		if (root.left != null) {
			return root.data + uncoveredSumLeft(root.left);
		} else {
			return root.data + uncoveredSumLeft(root.right);
		}
	}

	private static int uncoveredSumRight(Node root) {
		if (root.left == null && root.right == null) {
			return 0;
		}
		if (root.right != null) {
			return root.data + uncoveredSumRight(root.right);
		} else {
			return root.data + uncoveredSumRight(root.left);
		}
	}

	private static boolean checkCoverage(Node root) {
		int uncovered = root.data;
		if (root.left != null) {
			uncovered += uncoveredSumLeft(root.left);
		}
		if (root.right != null) {
			uncovered += uncoveredSumRight(root.right);
		}
		int total = totalSum(root);
		return uncovered == (total - uncovered);
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(8);
		root.left = new Node(3);
		root.left.left = new Node(1);
		root.left.right = new Node(6);
		root.left.right.left = new Node(4);
		root.left.right.right = new Node(7);

		root.right = new Node(10);
		root.right.right = new Node(14);
		root.right.right.left = new Node(13);

		System.out.println(checkCoverage(root));
	}

}


 ===================================================== 


AncestorDescendantQuery.java


/*
Query for ancestor-descendant relationship in a tree

Given a rooted tree with N vertices and N-1 edges.
We will be given many pairs of vertices u and v, we need to tell whether u is an
ancestor of v or not. Given tree will be rooted at the vertex with index 0.

We can solve this problem using depth first search of the tree.
While doing dfs we can observe a relation between the order in which we visit a node
and its ancestors. If we assign in-time and out-time to each node when entering and leaving
that node in dfs then we can see that for each pair of ancestor-descendant the in-time of ancestor
is less than that of descendant and out-time of ancestor is more than that of descendant,
so using this relation we can find the result for each pair of node in O(1) time.
So time complexity for preprocessing will be O(N) and for the query it will be O(1).

https://www.geeksforgeeks.org/query-ancestor-descendant-relationship-tree/
 */

package DataStructures.BinaryTree.LowestCommonAncestor;

import Commons.GraphMatrix;

public class AncestorDescendantQuery {
	private static int[] timeOut, timeIn;
	private static int counter;

	private static void dfsWithTime(int[][] tree, int V, int u, int parent) {
		timeIn[u] = counter++;
		for (int v = 0; v < V; v++) {
			if (tree[u][v] == 1) {
				if (v != parent) {
					dfsWithTime(tree, V, v, u);
				}
			}
		}
		timeOut[u] = counter;
	}

	private static boolean isAncestor(int[][] tree, int V, int u, int v) {
		timeOut = timeIn = new int[V];
		dfsWithTime(tree, V, u, v);
		return ((timeIn[u] <= timeIn[v]) && (timeOut[v] <= timeOut[u]));
	}

	public static void main(String[] args) {
		int[][] edges = {
				{0, 1},
				{0, 2},
				{1, 3},
				{1, 4},
				{2, 5},
				{4, 6},
				{5, 7}
		};
		int V = 8;
		GraphMatrix graphMatrix = new GraphMatrix(V, false, true);
		for (int[] arr : edges) {
			graphMatrix.addEdge(arr[0], arr[1]);
		}
		int[][] tree = graphMatrix.getGraph();
		System.out.println(isAncestor(tree, V, 1, 6));
		System.out.println(isAncestor(tree, V, 1, 7));
	}
}


 ===================================================== 


DistanceBetweenNodes.java


/*
Find the distance between two nodes in a tree

Approach =>
1. Find the LCA of both nodes
2. Find distance of LCA from Node 1 and Node 2

 */

package DataStructures.BinaryTree.LowestCommonAncestor;

import Commons.Node;

public class DistanceBetweenNodes {
	private static int findLevelFromRoot(Node root, int element, int level) {
		// Distance is basically the level from the root
		if (root == null) {
			return 0;
		}
		if (root.data == element) {
			return level;
		}
		int left = findLevelFromRoot(root.left, element, level + 1);
		if (left == 0) {
			return findLevelFromRoot(root.right, element, level + 1);
		}
		return left;
	}

	private static Node findLCA(Node root, int n1, int n2) {
		if (root == null) {
			return null;
		}

		if (root.data == n1 || root.data == n2) {
			return root;
		}
		Node left = findLCA(root.left, n1, n2);
		Node right = findLCA(root.right, n1, n2);

		if (left != null && right != null) {
			return root;
		}

		return left != null ? left : right;
	}

	private static int findDistance(Node root, int n1, int n2) {
		Node lca = findLCA(root, n1, n2);
		return findLevelFromRoot(lca, n1, 0)
				+ findLevelFromRoot(lca, n2, 0);
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.left = new Node(6);
		root.right.right = new Node(7);
		root.right.left.right = new Node(8);

		System.out.println("Dist(4, 5) = " + findDistance(root, 4, 5));
		System.out.println("Dist(4, 6) = " + findDistance(root, 4, 6));
		System.out.println("Dist(3, 4) = " + findDistance(root, 3, 4));
		System.out.println("Dist(2, 4) = " + findDistance(root, 2, 4));
		System.out.println("Dist(8, 5) = " + findDistance(root, 8, 5));
	}
}


 ===================================================== 


FindingKthAncestor.java


package DataStructures.BinaryTree.LowestCommonAncestor;

import Commons.Node;

public class FindingKthAncestor {
	private static int k;

	private static Node kThAncestorDFS(Node root, int element) {
		if (root == null) {
			return null;
		}

		if (root.data == element ||
				kThAncestorDFS(root.left, element) != null ||
				kThAncestorDFS(root.right, element) != null) {
			if (k > 0) {
				k--;
			} else if (k == 0) {
				System.out.println(root.data);
				return null;
			}
			return root;
		}
		return null;
	}

	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);

		k = 3;
		int node = 4;
		Node parent = kThAncestorDFS(root, node);
		if (parent != null) {
			System.out.println("-1");
		}
	}
}


 ===================================================== 


LCAUsing3Arrays.java


/*
Following is simple O(n) algorithm to find LCA of n1 and n2.
1) Find path from root to n1 and store it in a vector or array.
2) Find path from root to n2 and store it in another vector or array.
3) Traverse both paths till the values in arrays are same.
Return the common element just before the mismatch.
 */

package DataStructures.BinaryTree.LowestCommonAncestor;

import Commons.Node;

import java.util.ArrayList;

public class LCAUsing3Arrays {
	private static ArrayList<Integer> node1path, node2path;

	private static boolean traversal(Node root, int data, boolean one) {
		if (root == null) {
			return true;
		}

		int current = root.data;
		if (root.left != null && traversal(root.left, data, one)) {
			if (one) {
				if (!node1path.contains(current)) {
					node1path.add(current);
				}
			} else {
				if (!node2path.contains(current)) {
					node2path.add(current);
				}
			}
			return true;
		}

		if (root.right != null && traversal(root.right, data, one)) {
			if (one) {
				if (!node1path.contains(current)) {
					node1path.add(current);
				}
			} else {
				if (!node2path.contains(current)) {
					node2path.add(current);
				}
			}
			return true;
		}

		return root.data == data;
	}

	private static int findLCA(Node root, int n1, int n2) {
		node1path = new ArrayList<>();
		node2path = new ArrayList<>();
		traversal(root, n1, true);
		traversal(root, n2, false);
		int size = Math.min(node1path.size(), node2path.size());
		int i;
		for (i = size - 1; i > 0; i--) {
			if (!node1path.get(i).equals(node2path.get(i)))
				break;
		}
		return node2path.get(i);
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root;
		root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.left = new Node(6);
		root.right.right = new Node(7);
		System.out.println("LCA(4, 5) = " +
				findLCA(root, 4, 5));
		System.out.println("LCA(4, 6) = " +
				findLCA(root, 4, 6));
		System.out.println("LCA(3, 4) = " +
				findLCA(root, 3, 4));
		System.out.println("LCA(2, 4) = " +
				findLCA(root, 2, 4));
	}
}


 ===================================================== 


LCAUsingOneArray.java


/*
Lowest Common Ancestor in a Binary Tree | Set 1
Given a binary tree (not a binary search tree) and two values say n1 and n2,
write a program to find the least common ancestor.

Let T be a rooted tree. The lowest common ancestor between two nodes n1 and n2 is defined
as the lowest node in T that has both n1 and n2 as descendants (where we allow a node to
be a descendant of itself).

The LCA of n1 and n2 in T is the shared ancestor of n1 and n2 that is located farthest from the root.
Computation of lowest common ancestors may be useful, for instance, as part of a procedure
for determining the distance between pairs of nodes in a tree: the distance from n1 to n2
can be computed as the distance from the root to n1, plus the distance from the root to n2,
minus twice the distance from the root to their lowest common ancestor

Approach =>
The idea is to traverse the tree starting from root.
If any of the given keys (n1 and n2) matches with root, then root is LCA (assuming that
both keys are present). If root doesnt match with any of the keys, we recur for left and right subtree.
The node which has one key present in its left subtree and the other key present in
right subtree is the LCA. If both keys lie in left subtree, then left subtree has LCA also,
otherwise LCA lies in right subtree.

https://www.geeksforgeeks.org/lowest-common-ancestor-binary-tree-set-1/
 */

package DataStructures.BinaryTree.LowestCommonAncestor;

import Commons.Node;

public class LCAUsingOneArray {
	private static Node findLCA(Node root, int n1, int n2) {
		if (root == null) {
			return null;
		}

		if (root.data == n1 || root.data == n2) {
			return root;
		}

		// If either n1 or n2 matches with root's key, report
		// the presence by returning root (Note that if a key is
		// ancestor of other, then the ancestor key becomes LCA
		Node left = findLCA(root.left, n1, n2);
		Node right = findLCA(root.right, n1, n2);

		// If both of the above calls return Non-NULL, then one key
		// is present in once subtree and other is present in other,
		// So this node is the LCA
		if (left != null && right != null) {
			return root;
		}

		return left != null ? left : right;
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root;
		root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.left = new Node(6);
		root.right.right = new Node(7);
		System.out.println("LCA(4, 5) = " +
				findLCA(root, 4, 5).data);
		System.out.println("LCA(4, 6) = " +
				findLCA(root, 4, 6).data);
		System.out.println("LCA(3, 4) = " +
				findLCA(root, 3, 4).data);
		System.out.println("LCA(2, 4) = " +
				findLCA(root, 2, 4).data);
	}
}


 ===================================================== 


MaxDifferenceBetweenNodeAndAncestor.java


/*
Maximum difference between node and its ancestor in Binary Tree

Given a binary tree, we need to find maximum value we can get by subtracting value of node B
from value of node A, where A and B are two nodes of the binary tree and A is an ancestor of B.
Expected time complexity is O(n).

If we are at leaf node then just return its value because it cant be ancestor of any node.
Then at each internal node we will try to get minimum value from left subtree and right subtree
and calculate the difference between node value and this minimum value and according to that
we will update the result.
As we are calculating minimum value while retuning in recurrence we will check all
optimal possibilities (checking node value with minimum subtree value only) of
differences and hence calculate the result in one traversal only.

https://www.geeksforgeeks.org/maximum-difference-between-node-and-its-ancestor-in-binary-tree/
 */

package DataStructures.BinaryTree.LowestCommonAncestor;

import Commons.GlobalVar;
import Commons.Node;

public class MaxDifferenceBetweenNodeAndAncestor {
	private static int findMinimum(Node root, GlobalVar small) {
		if (root == null) {
			return 99999;
		}

		// Return leaf node if encountered
		if (root.left == null && root.right == null) {
			return root.data;
		}

		int value = Math.min(findMinimum(root.left, small),
				findMinimum(root.right, small));

		small.var = Math.max(small.var, root.data - value);

		return Math.min(value, root.data);
	}

	private static int getMaxDifference(Node root) {
		GlobalVar small = new GlobalVar(-9999);
		findMinimum(root, small);
		return small.var;
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(8);
		root.left = new Node(3);
		root.left.left = new Node(1);
		root.left.right = new Node(6);
		root.left.right.left = new Node(4);
		root.left.right.right = new Node(7);
		root.right = new Node(10);
		root.right.right = new Node(14);
		root.right.right.left = new Node(13);

		System.out.println(getMaxDifference(root));
	}
}


 ===================================================== 


GenerateNumberFromRootToLeafPath.java


/*
Sum of all the numbers that are formed from root to leaf paths
Given a binary tree, where every node value is a Digit from 1-9.
Find the sum of all the numbers which are formed from root to leaf paths.
For example consider the following Binary Tree.

           6
       /      \
     3          5
   /   \          \
  2     5          4
      /   \
     7     4
  There are 4 leaves, hence 4 root to leaf paths:
   Path                    Number
  6->3->2                   632
  6->3->5->7               6357
  6->3->5->4               6354
  6->5>4                    654
Answer = 632 + 6357 + 6354 + 654 = 13997
The idea is to do a preorder traversal of the tree.
In the preorder traversal, keep track of the value calculated till the current node,
let this value be val. For every node, we update the val as val*10 plus nodes data.

https://www.geeksforgeeks.org/sum-numbers-formed-root-leaf-paths/
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

import java.util.ArrayList;

public class GenerateNumberFromRootToLeafPath {
	private static ArrayList<Integer> numbers;

	private static void preorderTraversal(Node root, int val) {
		if (root == null) {
			return;
		}

		// if leaf, add number generated to list
		if (root.left == null && root.right == null) {
			numbers.add(val * 10 + root.data);
		}

		preorderTraversal(root.left, val * 10 + root.data);
		preorderTraversal(root.right, val * 10 + root.data);
	}

	private static int getSum(Node root) {
		numbers = new ArrayList<>();
		preorderTraversal(root, 0);
		int sum = 0;
		for (int i : numbers) {
			System.out.println(i);
			sum += i;
		}
		return sum;
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(6);
		root.left = new Node(3);
		root.right = new Node(5);
		root.right.right = new Node(4);
		root.left.left = new Node(2);
		root.left.right = new Node(5);
		root.left.right.right = new Node(4);
		root.left.right.left = new Node(7);
		System.out.println(getSum(root));
	}
}


 ===================================================== 


MaximumLeafToRootPath.java


/*
Find the maximum sum leaf to root path in a Binary Tree
Given a Binary Tree, find the maximum sum path from a leaf to root.
For example, in the following tree, there are three leaf to root paths 8->-2->10, -4->-2->10 and 7->10.
The sums of these three paths are 16, 4 and 17 respectively. The maximum of them is 17
and the path for maximum is 7->10.
                  10
               /      \
             -2        7
           /   \
          8     -4
Solution
1) First find the leaf node that is on the maximum sum path.
	In the following code getTargetLeaf() does this by assigning the result to *target_leaf_ref.
2) Once we have the target leaf node, we can print the maximum sum path by traversing the tree.
	In the following code, printPath() does this.

The main function is maxSumPath() that uses above two functions to get the complete solution.
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

public class MaximumLeafToRootPath {
	private static int result = -9999;
	private static Node target = null;

	private static void getTargetLeaf(Node root, int currentSum) {
		if (root == null) {
			return;
		}

		currentSum = currentSum + root.data;

		if (root.left == null && root.right == null) {
			if (currentSum > result) {
				result = currentSum;
				target = root;
			}
		}

		getTargetLeaf(root.left, currentSum);
		getTargetLeaf(root.right, currentSum);
	}

	private static boolean printPath(Node root, Node target) {
		if (root == null) {
			return false;
		}

		if (root == target ||
				printPath(root.left, target) ||
				printPath(root.right, target)) {
			System.out.print(root.data + " ");
			return true;
		}

		return false;
	}

	public static void main(String[] args) {
		Node root = new Node(10);
		root.left = new Node(-2);
		root.right = new Node(7);
		root.left.left = new Node(8);
		root.left.right = new Node(-4);

		getTargetLeaf(root, 0);
		printPath(root, target);
		System.out.println("\n" + result);
	}
}


 ===================================================== 


MaxPathSum.java


/*
We can find the maximum sum using single traversal of binary tree.
The idea is to maintain two values in recursive calls
1) Maximum root to leaf path sum for the subtree rooted under current node.
2) The maximum path sum between leaves (desired output).

For every visited node X, we find the maximum root to leaf sum in left and right subtrees of X.
We add the two values with X->data, and compare the sum with maximum path sum found so far.

https://www.geeksforgeeks.org/find-maximum-path-sum-two-leaves-binary-tree/
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

public class MaxPathSum {
	private static int result = Integer.MIN_VALUE;

	private static int getResult(Node root) {
		if (root == null) {
			return 0;
		}
		if (root.left == null && root.right == null) {
			return root.data;
		}

		// Find maximum sum in left and right subtree. Also
		// find maximum root to leaf sums in left and right
		// subtrees and store them in ls and rs
		int ls = getResult(root.left),
				rs = getResult(root.right);

		// If both left and right children exist
		if (root.left != null && root.right != null) {
			result = Math.max(result, ls + rs + root.data);
			return Math.max(ls, rs) + root.data;
		}

		// If any of the two children is empty, return
		// root sum for root being on one side
		return (root.left == null) ? rs + root.data : ls + root.data;
	}

	private static int maxPathSum(Node root) {
		getResult(root);
		return result;
	}

	public static void main(String[] args) {
		Node root;
		root = new Node(-15);
		root.left = new Node(5);
		root.right = new Node(6);
		root.left.left = new Node(-8);
		root.left.right = new Node(1);
		root.left.left.left = new Node(2);
		root.left.left.right = new Node(6);
		root.right.left = new Node(3);
		root.right.right = new Node(9);
		root.right.right.right = new Node(0);
		root.right.right.right.left = new Node(4);
		root.right.right.right.right = new Node(-1);
		root.right.right.right.right.left = new Node(10);

		System.out.println(maxPathSum(root));
	}
}


 ===================================================== 


MaxSubTreeSum.java


/*
Find largest subtree sum in a tree
Given a binary tree, task is to find subtree with maximum sum in tree.

Examples:

Input :       1
            /   \
           2      3
          / \    / \
         4   5  6   7
Output : 28
As all the tree elements are positive,
the largest subtree sum is equal to
sum of all tree elements.

Input :       1
            /    \
          -2      3
          / \    /  \
         4   5  -6   2
Output : 7
Subtree with largest sum is :  -2
                             /  \
                            4    5
Also, entire tree sum is also 7.

Approach :
Do post order traversal of the binary tree. At every node, find left subtree value and
right subtree value recursively. The value of subtree rooted at current node is equal to
sum of current node value, left node subtree sum and right node subtree sum.
Compare current subtree sum with overall maximum subtree sum so far.

https://www.geeksforgeeks.org/find-largest-subtree-sum-tree/
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

public class MaxSubTreeSum {
	private static int sum = 0;

	private static int getSum(Node root) {
		if (root == null) {
			return 0;
		}

		int ls = getSum(root.left),
				rs = getSum(root.right);

		int currentNodeSum = ls + rs + root.data;

		if (currentNodeSum > sum) {
			sum = currentNodeSum;
		}

		return currentNodeSum;
	}

	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(-2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.left = new Node(-6);
		root.right.right = new Node(2);
		getSum(root);
		System.out.println(sum);
	}
}


 ===================================================== 


PairSumEqualToRoot.java


/*
Find if there is a pair in root to a leaf path with sum equals to roots data

Given a binary tree, find if there is a pair in root to a leaf path such that
sum of values in pair is equal to roots data

Approach =>
	Create an empty hash table.
	Start traversing tree in Preorder fashion.
	If we reach a leaf node, we return false.
	For every visited node, check if roots data minus current nodes data exists in hash table or not.
		If yes, return true. Else insert current node in hash table.
	Recursively check in left and right subtrees.
	Remove current node from hash table so that it doesnt appear in other root to leaf paths.

https://www.geeksforgeeks.org/find-pair-root-leaf-path-sum-equals-roots-data/
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

import java.util.HashSet;

public class PairSumEqualToRoot {
	private static boolean doesPairExist(Node root) {
		HashSet<Integer> map = new HashSet<>();
		return pairCheck(root, map, root.data);
	}

	private static boolean pairCheck(Node root, HashSet<Integer> map, int rootData) {
		if (root == null) {
			return true;
		}

		if (map.contains(rootData - root.data)) {
			return true;
		}

		map.add(root.data);

		boolean result = pairCheck(root.left, map, rootData)
				|| pairCheck(root.left, map, rootData);

		map.remove(root.data);

		return result;
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root = new Node(8);
		root.left = new Node(5);
		root.right = new Node(4);
		root.left.left = new Node(9);
		root.left.right = new Node(7);
		root.left.right.left = new Node(1);
		root.left.right.right = new Node(12);
		root.left.right.right.right = new Node(2);
		root.right.right = new Node(11);
		root.right.right.left = new Node(3);

		System.out.println(doesPairExist(root));
	}
}


 ===================================================== 


RemovingPathsLessThanK.java


/*
Remove all nodes which dont lie in any path with sum>= k
Given a binary tree, a complete path is defined as a path from root to a leaf.
The sum of all nodes on that path is defined as the sum of that path. Given a number K,
you have to remove (prune the tree) all nodes which dont lie in any path with sum>=k.

Note: A node can be part of multiple paths. So we have to delete it only in case when all
paths from it have sum less than K.

Consider the following Binary Tree
          1
      /      \
     2        3
   /   \     /  \
  4     5   6    7
 / \    /       /
8   9  12      10
   / \           \
  13  14         11
      /
     15

For input k = 20, the tree should be changed to following
(Nodes with values 6 and 8 are deleted)
          1
      /      \
     2        3
   /   \        \
  4     5        7
   \    /       /
    9  12      10
   / \           \
  13  14         11
      /
     15

For input k = 45, the tree should be changed to following.
      1
    /
   2
  /
 4
  \
   9
    \
     14
     /
    15

The idea is to keep reducing the sum when traversing down.
When we reach a leaf and sum is greater than the leafs data,
then we delete the leaf. Note that deleting nodes may convert a non-leaf node to a
leaf node and if the data for the converted leaf node is less than the current sum,
then the converted leaf should also be deleted.

https://www.geeksforgeeks.org/remove-all-nodes-which-lie-on-a-path-having-sum-less-than-k/
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

public class RemovingPathsLessThanK {
	private static Node prune(Node root, int sum) {
		if (root == null) {
			return null;
		}
		root.left = prune(root.left, sum - root.data);
		root.right = prune(root.right, sum - root.data);
		if (root.left == null && root.right == null) {
			if (sum > root.data) {
				root = null;
			}
		}

		return root;
	}

	private static void printInorder(Node root) {
		if (root == null) {
			return;
		}
		printInorder(root.left);
		System.out.print(root.data + " ");
		printInorder(root.right);
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.left = new Node(6);
		root.right.right = new Node(7);
		root.left.left.left = new Node(8);
		root.left.left.right = new Node(9);
		root.left.right.left = new Node(12);
		root.right.right.left = new Node(10);
		root.right.right.left.right = new Node(11);
		root.left.left.right.left = new Node(13);
		root.left.left.right.right = new Node(14);
		root.left.left.right.right.left = new Node(15);
		int sum = 45;
		printInorder(prune(root, sum));
	}
}


 ===================================================== 


ReplacementWithInorderNeighbor.java


/*
Replace each node in binary tree with the sum of its inorder predecessor and successor
Given a binary tree containing n nodes.
The problem is to replace each node in the binary tree with the sum of its
inorder predecessor and inorder successor.

Examples:

Input :          1
               /   \
              2     3
            /  \  /  \
           4   5  6   7

Output :        11
              /    \
             9      13
            / \    /  \
           2   3   4   3

For 1:
Inorder predecessor = 5
Inorder successor  = 6
Sum = 11

For 4:
Inorder predecessor = 0
(as inorder predecessor is not present)
Inorder successor  = 2
Sum = 2

For 7:
Inorder predecessor = 3
Inorder successor  = 0
(as inorder successor is not present)
Sum = 3

Approach:
Create an array arr. Store 0 at index 0.
Now, store the inorder traversal of tree in the array arr.
Then, store 0 at last index. 0s are stored as inorder predecessor of leftmost leaf and
inorder successor of rightmost leaf is not present. Now, perform inorder traversal and
while traversing node replace nodes value with arr[i-1] + arr[i+1] and then increment i.
In the beginning initialize i = 1. For an element arr[i], the values arr[i-1] and arr[i+1]
are its inorder predecessor and inorder successor respectively.
 */

package DataStructures.BinaryTree.Summation;

import Commons.ArrayPrinter;
import Commons.Node;

public class ReplacementWithInorderNeighbor {
	private static int[] arr;
	private static int i;

	private static void doInorder(Node root, boolean replace) {
		if (root == null) {
			return;
		}

		doInorder(root.left, replace);
		if (replace) {
			root.data = arr[i - 1] + arr[i + 1];
		} else {
			arr[i] = root.data;
		}
		i++;
		doInorder(root.right, replace);
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root = new Node(1);       //         1
		root.left = new Node(2);        //      /   \
		root.right = new Node(3);       //     2     3
		root.left.left = new Node(4);  //    /  \  /   \
		root.left.right = new Node(5); //   4   5  6   7
		root.right.left = new Node(6);
		root.right.right = new Node(7);
		arr = new int[100];
		arr[0] = 0;
		doInorder(root, false);
		arr[i] = 0;
		(new ArrayPrinter()).printArray(arr, i);
		System.out.println();
		i = 1;
		doInorder(root, true);
		i = 1;
		doInorder(root, false);
		(new ArrayPrinter()).printArray(arr, i);
	}
}


 ===================================================== 


SubTreesWithSumX.java


/*
Count subtrees that sum up to a given value x only using single recursive function

Given a binary tree containing n nodes. The problem is to count subtrees having
total nodes data sum equal to a given value using only single recursive function x.

Examples:

Input :
             5
           /   \
        -10     3
        /  \   /  \
       9    8 -4   7

       x = 7

Output : 2
There are 2 subtrees with sum 7.

1st one is leaf node:
7.

2nd one is:

      -10
     /   \
    9     8

Approach:

countSubtreesWithSumX(root, count, x)
    if !root then
        return 0

    ls = countSubtreesWithSumX(root->left, count, x)
    rs = countSubtreesWithSumX(root->right, count, x)
    sum = ls + rs + root->data

    if sum == x then
    count++
    return sum

countSubtreesWithSumXUtil(root, x)
    if !root then
        return 0

    Initialize count = 0
    ls = countSubtreesWithSumX(root->left, count, x)
    rs = countSubtreesWithSumX(root->right, count, x)

    if (ls + rs + root->data) == x
        count++
    return count

https://www.geeksforgeeks.org/count-subtress-sum-given-value-x/
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

public class SubTreesWithSumX {
	private static int count;

	private static int utilFunction(Node root, int x) {
		if (root == null) {
			return 0;
		}

		int ls = utilFunction(root.left, x),
				rs = utilFunction(root.right, x);
		int sum = ls + rs + root.data;
		if (sum == x) {
			count++;
		}

		return sum;
	}

	private static int findCount(Node root, int x) {
		if (root == null) {
			return 0;
		}

		count = 0;
		int ls = utilFunction(root.left, x),
				rs = utilFunction(root.right, x);


		if ((ls + rs + root.data) == x) {
			count++;
		}

		return count;
	}

	public static void main(String[] args) {
		 /* binary tree creation
           5
          / \
        -10  3
        / \ / \
        9 8 -4 7
    */
		Node root = new Node(5);
		root.left = new Node(-10);
		root.right = new Node(3);
		root.left.left = new Node(9);
		root.left.right = new Node(8);
		root.right.left = new Node(-4);
		root.right.right = new Node(7);

		int x = 7;

		System.out.println(findCount(root, x));
	}
}


 ===================================================== 


SubTreeWithGivenSum.java


/*
Subtree with given sum in a Binary Tree
You are given a binary tree and a given sum.
The task is to check if there exist a subtree whose sum of all nodes is equal to the given sum.

The idea is to traverse tree in Postorder fashion because here we have to think bottom-up.
First calculate the sum of left subtree then right subtree and check
if sum_left + sum_right + cur_node = sum is satisfying the condition that means any subtree
with given sum exist. Below is the recursive implementation of algorithm.

https://www.geeksforgeeks.org/subtree-given-sum-binary-tree/
 */

package DataStructures.BinaryTree.Summation;

import Commons.GlobalVar;
import Commons.Node;

public class SubTreeWithGivenSum {
	private static boolean check(Node root, GlobalVar currentSum, int x) {
		if (root == null) {
			return true;
		}
		GlobalVar sumLeft = new GlobalVar(0),
				sumRight = new GlobalVar(0);

		currentSum.var = sumLeft.var + sumRight.var + root.data;

		return (check(root.left, sumLeft, x) ||
				check(root.right, sumRight, x) ||
				((currentSum.var) == x));
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root = new Node(8);
		root.left = new Node(5);
		root.right = new Node(4);
		root.left.left = new Node(9);
		root.left.right = new Node(7);
		root.left.right.left = new Node(1);
		root.left.right.right = new Node(12);
		root.left.right.right.right = new Node(2);
		root.right.right = new Node(11);
		root.right.right.left = new Node(3);
		int sum = 22;
		GlobalVar currentSum = new GlobalVar(0);
		System.out.println(check(root, currentSum, sum));
	}
}


 ===================================================== 


sumOfDiagonals.java


/*
Diagonal Sum of a Binary Tree
Consider lines of slope -1 passing between nodes (dotted lines in below diagram).
Diagonal sum in a binary tree is sum of all nodes data lying between these lines.
Given a Binary Tree, print all diagonal sums.

The idea is to keep track of vertical distance from top diagonal passing through root. We increment the vertical distance we go down to next diagonal.
1. Add root with vertical distance as 0 to the queue.
2. Process the sum of all right child and right of right child and so on.
3. Add left child current node into the queue for later processing.
	The vertical distance of left child is vertical distance of current node plus 1.
4. Keep doing 2nd, 3rd and 4th step till the queue is empty.

https://www.geeksforgeeks.org/diagonal-sum-binary-tree/
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;

public class sumOfDiagonals {
	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(9);
		root.left.right = new Node(6);
		root.right.left = new Node(4);
		root.right.right = new Node(5);
		root.right.left.left = new Node(12);
		root.right.left.right = new Node(7);
		root.left.right.left = new Node(11);
		root.left.left.right = new Node(10);

		System.out.println(getSumDiagonal(root));
	}

	private static int getSumDiagonal(Node root) {
		Queue<VerticalDistance> queue = new LinkedList<>();
		HashMap<Integer, Integer> diagonalSum = new HashMap<>();
		queue.add(new VerticalDistance(root, 0));
		VerticalDistance current;
		int vd;
		while (!queue.isEmpty()) {
			current = queue.poll();
			vd = current.vd;

			while (current.root != null) {
				int prevSum = (diagonalSum.get(vd) == null) ? 0 : diagonalSum.get(vd);
				diagonalSum.put(vd, prevSum + current.root.data);

				if (current.root.left != null) {
					queue.add(new VerticalDistance(current.root.left, vd + 1));
				}

				current = new VerticalDistance(current.root.right, vd);
			}
		}

		int sum = 0;
		for (Map.Entry<Integer, Integer> entry : diagonalSum.entrySet()) {
			System.out.print(entry.getValue() + " ");
			sum += entry.getValue();
		}
		System.out.println();
		return sum;
	}

	static class VerticalDistance {
		Node root;
		int vd;

		public VerticalDistance(Node root, int vd) {
			this.root = root;
			this.vd = vd;
		}
	}
}


 ===================================================== 


SumOfLeftLeaves.java


/*
Find sum of all left leaves in a given Binary Tree

The idea is to traverse the tree, starting from root.
For every node, check if its left subtree is a leaf. If it is, then add it to the result.

Input : Binary tree:
        5
       / \
      2   5
     / \ / \
    7  2 2  3
Output : 9

https://www.geeksforgeeks.org/find-sum-left-leaves-given-binary-tree/
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

public class SumOfLeftLeaves {
	private static int sum = 0;

	private static void sumCalculator(Node root) {
		if (root == null) {
			return;
		}

		if (root.left != null) {
			if (root.left.left == null && root.left.right == null) {
				sum += root.left.data;
			}
		}

		sumCalculator(root.left);
		sumCalculator(root.right);
	}

	public static void main(String[] args) {
		sum = 0;
		Node root;
		root = new Node(20);
		root.left = new Node(9);
		root.right = new Node(49);
		root.left.right = new Node(12);
		root.left.left = new Node(5);
		root.right.left = new Node(23);
		root.right.right = new Node(52);
		root.left.right.right = new Node(12);
		root.right.right.left = new Node(50);

		sumCalculator(root);
		System.out.println(sum);
	}
}


 ===================================================== 


SumOfParentsOfX.java


/*
Sum of all the parent nodes having child node x
Given a binary tree containing n nodes. The problem is to find the sum of all the parent nodes
which have a child node with value x.

Examples:

Input : Binary tree with x = 2:
        5
       / \
      2   5
     / \ / \
    7  2 2  3
Output : 11

The highlighted nodes (4, 2, 5) above
are the nodes having 2 as a child node.

Approach =>
sumOfParentOfX(root,sum,x)
    if root == NULL
        return

    if (root->left && root->left->data == x) ||
       (root->right && root->right->data == x)
        sum += root->data

    sumOfParentOfX(root->left, sum, x)
    sumOfParentOfX(root->right, sum, x)

sumOfParentOfXUtil(root,x)
    Declare sum = 0
    sumOfParentOfX(root, sum, x)
    return sum

https://www.geeksforgeeks.org/sum-parent-nodes-child-node-x/
 */
package DataStructures.BinaryTree.Summation;

import Commons.Node;

public class SumOfParentsOfX {
	private static int sum;

	private static void sumOfParentsX(Node root, int x) {
		if (root == null) {
			return;
		}

		if ((root.left != null && root.left.data == x) ||
				(root.right != null && root.right.data == x)) {
			sum += root.data;
		}

		sumOfParentsX(root.left, x);
		sumOfParentsX(root.right, x);
	}

	public static void main(String[] args) {
		sum = 0;
		Node root = new Node(5);
		root.left = new Node(2);
		root.right = new Node(5);
		root.left.left = new Node(7);
		root.left.right = new Node(2);
		root.right.left = new Node(2);
		root.right.right = new Node(3);

		int x = 2;
		sumOfParentsX(root, x);
		System.out.println(sum);
	}
}


 ===================================================== 


SumOfRootsAtALevel.java


/*
Sum of nodes at k-th level in a tree represented as string
Given an integer K and a binary tree in string format.
Every node of a tree has value in range from 0 to 9. We need to find sum of elements
at K-th level from root. The root is at level 0.
Tree is given in the form: (node value(left subtree)(right subtree))

1. Input 'tree' in string format and level k
2. Initialize level = -1 and sum = 0
3. for each character 'ch' in 'tree'
   3.1  if ch == '(' then
        --> level++
   3.2  else if ch == ')' then
        --> level--
   3.3  else
        if level == k then
           sum = sum + (ch-'0')
4. Print sum

https://www.geeksforgeeks.org/sum-nodes-k-th-level-tree-represented-string/
 */

package DataStructures.BinaryTree.Summation;

public class SumOfRootsAtALevel {
	public static void main(String[] args) {
		String tree = "(0(5(6()())(4()(9()())))(7(1()())(3()())))";
		int k = 2;
		System.out.println(getSum(tree, k));
	}

	private static int getSum(String tree, int k) {
		int sum = 0, level = -1;
		for (int i = 0; i < tree.length(); i++) {
			if (tree.charAt(i) == '(') {
				level++;
			} else if (tree.charAt(i) == ')') {
				level--;
			} else {
				if (level == k) {
					sum += tree.charAt(i) - '0';
				}
			}
		}
		return sum;
	}
}


 ===================================================== 


VerticalSum.java


/*
Vertical Sum in a given Binary Tree | Set 1
Given a Binary Tree, find the vertical sum of the nodes that are in the same vertical line.
Print all sums through different vertical lines.
Examples:

      1
    /   \
  2      3
 / \    / \
4   5  6   7
The tree has 5 vertical lines

Vertical-Line-1 has only one node 4 => vertical sum is 4
Vertical-Line-2: has only one node 2=> vertical sum is 2
Vertical-Line-3: has three nodes: 1,5,6 => vertical sum is 1+5+6 = 12
Vertical-Line-4: has only one node 3 => vertical sum is 3
Vertical-Line-5: has only one node 7 => vertical sum is 7

We need to check the Horizontal Distances from the root for all nodes.
If two nodes have the same Horizontal Distance (HD), then they are on the same vertical line.
The idea of HD is simple. HD for root is 0, a right edge (edge connecting to right subtree)
is considered as +1 horizontal distance and a left edge is considered as -1 horizontal distance.
For example, in the above tree, HD for Node 4 is at -2, HD for Node 2 is -1, HD for 5 and 6 is 0
and HD for node 7 is +2.
We can do an in-order traversal of the given Binary Tree.
While traversing the tree, we can recursively calculate HDs.
We initially pass the horizontal distance as 0 for root. For left subtree,
we pass the Horizontal Distance as Horizontal distance of root minus 1.
For right subtree, we pass the Horizontal Distance as Horizontal Distance of root plus 1.

https://www.geeksforgeeks.org/vertical-sum-in-a-given-binary-tree/
 */

package DataStructures.BinaryTree.Summation;

import Commons.Node;

import java.util.HashMap;
import java.util.HashSet;

public class VerticalSum {
	private static HashMap<Node, Integer> hd;
	private static int[] arr;

	private static void getHorizontalDistances(Node root, int hDist, boolean doSum) {
		if (root == null) {
			return;
		}
		getHorizontalDistances(root.left, hDist - 1, doSum);
		if (doSum) {
			if (hDist >= 0) {
				arr[hDist] += root.data;
			} else {
				arr[arr.length + hDist] += root.data;
			}
		} else {
			hd.put(root, hDist);
		}
		getHorizontalDistances(root.right, hDist + 1, doSum);
	}

	private static void printSums(Node root) {
		hd = new HashMap<>();
		getHorizontalDistances(root, 0, false);
		int val = new HashSet<>(hd.values()).size();
		arr = new int[val];
		getHorizontalDistances(root, 0, true);
		for (int i = arr.length - 1; i >= 0; i--) {
			System.out.println("Level Sum of " + i + " => " + arr[i]);
		}
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root;
		/* Create the following Binary Tree
              1
            /    \
          2        3
         / \      / \
        4   5    6   7

        */
		root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.left = new Node(6);
		root.right.right = new Node(7);
		printSums(root);
	}
}


 ===================================================== 


AncestorMatrix.java


/*
Construct Ancestor Matrix from a Given Binary Tree

Given a Binary Tree where all values are from 0 to n-1.
Construct an ancestor matrix mat[n][n]. Ancestor matrix is defined as below.
mat[i][j] = 1 if i is ancestor of j
mat[i][j] = 0, otherwise

Input: Root of below Binary Tree.
           5
        /    \
       1      2
      /  \    /
     0    4  3
Output: 0 0 0 0 0 0
        1 0 0 0 1 0
        0 0 0 1 0 0
        0 0 0 0 0 0
        0 0 0 0 0 0
        1 1 1 1 1 0

https://www.geeksforgeeks.org/construct-ancestor-matrix-from-a-given-binary-tree/
 */

package DataStructures.BinaryTree.Traversals;

import Commons.Node;

public class AncestorMatrix {
	private static void ancestorMatrix(Node root, int[][] matrix, int size) {
		if (root == null) {
			return;
		}
		ancestorMatrix(root.left, matrix, size);
		ancestorMatrix(root.right, matrix, size);

		if (root.left != null) {
			matrix[root.data][root.left.data] = 1;

			// iterate through all the columns of children node
			// all nodes which are children to
			// children of root node will also
			// be children of root node
			for (int i = 0; i < size; i++) {
				if (matrix[root.left.data][i] == 1) {
					matrix[root.data][i] = 1;
				}
			}
		}

		// same procedure followed for right node as well
		if (root.right != null) {
			matrix[root.data][root.right.data] = 1;

			for (int i = 0; i < size; i++) {
				if (matrix[root.right.data][i] == 1)
					matrix[root.data][i] = 1;
			}
		}
	}

	public static void main(String[] args) {
		Node tree_root = new Node(5);
		tree_root.left = new Node(1);
		tree_root.right = new Node(2);
		tree_root.left.left = new Node(0);
		tree_root.left.right = new Node(4);
		tree_root.right.left = new Node(3);

		// size of matrix
		int size = 6;
		int[][] matrix = new int[size][size];

		ancestorMatrix(tree_root, matrix, size);

		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				System.out.print(matrix[i][j] + " ");
			}
			System.out.println();
		}
	}
}


 ===================================================== 


DepthOfATree.java


/*
Calculate depth of a full Binary tree from Preorder
Given preorder of a binary tree, calculate its depth(or height) [starting from depth 0].
The preorder is given as a string with two possible characters.

l denotes the leaf
n denotes internal node
The given tree can be seen as a full binary tree where every node has 0 or two children.
The two children of a node can n or l or mix of both.

Input  : nlnll
Output : 2
			  n
            /   \
           l     n
			   /   \
			  l     l

The recursion function would be:
1) Base Case: return 0; when tree[i] = l or i >= strlen(tree)
2) find_depth( tree[i++] ) //left subtree
3) find_depth( tree[i++] ) //right subtree

Where i is the index of the string tree.

https://www.geeksforgeeks.org/calculate-depth-full-binary-tree-preorder/
 */

package DataStructures.BinaryTree.Traversals;

public class DepthOfATree {
	private static int findDepth(String tree, int index) {
		if (index >= tree.length() || tree.charAt(index) == 'l') {
			return 0;
		}
		index++;
		int left = findDepth(tree, index);
		index++;
		int right = findDepth(tree, index);
		return Math.max(left, right) + 1;
	}

	public static void main(String[] args) {
		String tree = "nlnnlll";
		System.out.println(findDepth(tree, 0));
	}
}


 ===================================================== 


DiagonalTraversal.java


/*
Diagonal Traversal of Tree

https://www.geeksforgeeks.org/diagonal-traversal-of-binary-tree/
 */

package DataStructures.BinaryTree.Traversals;

import Commons.Node;

import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;

public class DiagonalTraversal {
	private static TreeMap<Integer, ArrayList<Integer>> traversal;

	private static void diagonalTraverse(Node root, int slope) {
		if (root == null) {
			return;
		}

		// Check if a arraylist exists at a particular slope
		if (traversal.containsKey(slope)) {
			traversal.get(slope).add(root.data);
		} else {
			// if does not exist, create one
			traversal.put(slope, new ArrayList<>());
			if (!traversal.get(slope).contains(root.data)) {
				traversal.get(slope).add(root.data);
			}
		}

		// traverse right with same slope
		diagonalTraverse(root.right, slope);
		// traverse left with slope+1
		diagonalTraverse(root.left, slope + 1);
	}

	private static void printDiagonal(Node root) {
		traversal = new TreeMap<>();
		diagonalTraverse(root, 1);
		for (Map.Entry<Integer, ArrayList<Integer>> entry : traversal.entrySet()) {
			for (int i : entry.getValue()) {
				System.out.print(i + " => ");
			}
			System.out.println();
		}
	}

	public static void main(String[] args) {
		Node root = new Node(8);
		root.left = new Node(3);
		root.right = new Node(10);
		root.left.left = new Node(1);
		root.left.right = new Node(6);
		root.right.right = new Node(14);
		root.right.right.left = new Node(13);
		root.left.right.left = new Node(4);
		root.left.right.right = new Node(7);
		printDiagonal(root);
	}
}


 ===================================================== 


DiameterOfATree.java


/*
Calculating the diameter of the tree

The diameter of a tree is the number of nodes on the longest path between two leaves in the tree.
The diagram below shows two trees each with diameter nine, the leaves that form the
ends of the longest path are colored (note that there may be more than one path in the
tree of the same diameter).

Input :     1
          /   \
        2      3
      /  \
    4     5

Output : 4

Input :     1
          /   \
        2      3
      /  \ .    \
    4     5 .    6

Output : 5

Approach =>
In this post a new simple O(n) method is discussed. Diameter of a tree can be calculated
by only using the height function, because the diameter of a tree is nothing but
maximum value of (left_height + right_height + 1) for each node.
So we need to calculate this value (left_height + right_height + 1) for each node and update the result.
Time complexity  O(n)
*/

package DataStructures.BinaryTree.Traversals;

import Commons.Node;

@SuppressWarnings("Duplicates")
public class DiameterOfATree {
	private static int ans;

	private static int getHeight(Node root) {
		if (root == null) {
			return 0;
		}

		int left = getHeight(root.left);
		int right = getHeight(root.right);
		ans = Math.max(ans, left + right + 1);
		return 1 + Math.max(left, right);
	}

	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		getHeight(root);
		System.out.println(ans);
	}
}


 ===================================================== 


LevelOrderTraversal.java


/*
Level Order Tree Traversal
              1
            /   \
           2     3
         /   \
        4    5

printLevelOrder(tree)
1) Create an empty queue q
2) temp_node = root start from root
3) Loop while temp_node is not NULL
		a) print temp_node->data.
		b) Enqueue temp_nodes children (first left then right children) to q
		c) Dequeue a node from q and assign its value to temp_node

https://www.geeksforgeeks.org/level-order-tree-traversal/
 */

package DataStructures.BinaryTree.Traversals;

import Commons.Node;

import java.util.LinkedList;
import java.util.Queue;

public class LevelOrderTraversal {
	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root;
		root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		System.out.println("Level order traversal of binary tree is - ");
		levelOrder(root);
	}

	private static void levelOrder(Node root) {
		Queue<Node> queue = new LinkedList<>();
		Node tempNode = root;
		queue.add(tempNode);
		while (!queue.isEmpty()) {
			tempNode = queue.poll();
			System.out.print(tempNode.data + " ");
			if (tempNode.left != null) {
				queue.add(tempNode.left);
			}
			if (tempNode.right != null) {
				queue.add(tempNode.right);
			}
		}
	}
}


 ===================================================== 


MinSwapsToMakeBST.java


/*Minimum swap required to convert binary tree to binary search tree
Given the array representation of Complete Binary Tree i.e, if index i is the parent,
index 2*i + 1 is the left child and index 2*i + 2 is the right child.
The task is to find the minimum number of swap required to convert it into Binary Search Tree.

The idea is to use the fact that inorder traversal of Binary Search Tree is in increasing order of their value.
So, find the inorder traversal of the Binary Tree and store it in the array and try to sort the array.
The minimum number of swap required to get the array sorted will be the answer.
*/

package DataStructures.BinaryTree.Traversals;

import Commons.Node;

import java.util.ArrayList;
import java.util.Arrays;

@SuppressWarnings({"Duplicates", "unchecked"})
public class MinSwapsToMakeBST {
	private static int[] inOrder;
	private static int index = 0;

	private static void inOrderTraversal(Node root) {
		if (root == null) {
			return;
		}
		inOrderTraversal(root.left);
		inOrder[index] = root.data;
		index++;
		inOrderTraversal(root.right);
	}

	private static int swapNumber(Node root, int V) {
		inOrder = new int[V];
		inOrderTraversal(root);
		int[] temp = inOrder.clone();
		Arrays.sort(temp);
		boolean[] visited = new boolean[V];
		ArrayList<Integer>[] graph = new ArrayList[V];
		Arrays.fill(graph, new ArrayList<>());
		for (int i = 0; i < V; i++) {
			if (temp[i] != inOrder[i]) {
				graph[temp[i]].add(inOrder[i]);
			}
		}
		int ans = 0;
		for (int i = 0; i < V; i++) {
			if (visited[i] || temp[i] == inOrder[i]) {
				continue;
			}
			int cycle = 0, j = i, v = 0;
			while (!visited[j]) {
				visited[j] = true;
				cycle++;
				if (v < graph[j].size()) {
					j = graph[j].get(v);
					v++;
				} else {
					break;
				}
			}
			if (cycle > 0) {
				ans += cycle - 1;
			}
		}
		return ans;
	}

	public static void main(String[] args) {
		Node root = new Node(25);
		int v = 1;
		System.out.println(swapNumber(root, v));
	}

}


 ===================================================== 


MorrisTraversal.java


/*
Morris Traversal

Using Morris Traversal, we can traverse the tree without using stack and recursion.
The idea of Morris Traversal is based on Threaded Binary Tree.
In this traversal, we first create links to Inorder successor and print the data using these links,
and finally revert the changes to restore original tree.

1. Initialize current as root
2. While current is not NULL
   If the current does not have left child
      a) Print currents data
      b) Go to the right, i.e., current = current->right
   Else
      a) Make current as the right child of the rightmost
         node in current's left subtree
      b) Go to this left child, i.e., current = current->left

https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/
 */

package DataStructures.BinaryTree.Traversals;

import Commons.Node;

public class MorrisTraversal {
	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root;
		root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		morrisTraversal(root);
	}

	private static void morrisTraversal(Node root) {
		Node current, temp;
		current = root;
		while (current != null) {
			if (current.left == null) {
				System.out.print(current.data + " ");
				current = current.right;
			} else {
				temp = current.left;
				/* Find the inorder predecessor of current */
				while (temp.right != null && temp.right != current) {
					temp = temp.right;
				}

				/* Make current as right child of its inorder predecessor */
				if (temp.right == null) {
					temp.right = current;
					current = current.left;
				} else {
					/* Revert the changes made in the 'if' part to restore the
                    original tree i.e., fix the right child of predecessor*/
					temp.right = null;
					System.out.print(current.data + " ");
					current = current.right;
				}
			}
		}
	}
}


 ===================================================== 


NthNode.java


/*
Find n-th node of inorder traversal

Input : n = 4
              10
            /   \
           20     30
         /   \
        40     50
Output : 10
Inorder Traversal is : 40 20 50 10 30

We do simple Inorder Traversal. While doing the traversal,
we keep track of count of nodes visited so far. When count becomes n, we print the node.

https://www.geeksforgeeks.org/find-n-th-node-inorder-traversal/
 */

package DataStructures.BinaryTree.Traversals;

import Commons.Node;

public class NthNode {
	private static int position = 0;

	private static int inOrderTraversal(Node root, int n) {
		if (root == null) {
			return -1;
		}
		inOrderTraversal(root.left, n);
		position++;
		if (position == n) {
			return root.data;
		}
		inOrderTraversal(root.right, n);
		return -1;
	}

	public static void main(String[] args) {
		Node root = new Node(10);
		root.left = new Node(20);
		root.right = new Node(30);
		root.left.left = new Node(40);
		root.left.right = new Node(50);

		int n = 4;
		System.out.println(inOrderTraversal(root, n));
	}

}


 ===================================================== 


PostFromPreIn.java


/*
Print Post order traversal from given Inorder and Preorder traversals
Given Inorder and Preorder traversals of a binary tree, print Post order traversal.

We can print postorder traversal without constructing the tree.
The idea is, root is always the first item in preorder traversal and it must be the last item
in postorder traversal. We first recursively print left subtree, then recursively print right subtree.
Finally, print root. To find boundaries of left and right subtrees in pre[] and in[],
we search root in in[], all elements before root in in[] are elements of left subtree and all
elements after root are elements of right subtree. In pre[], all elements after index of root
in in[] are elements of right subtree. And elements before index (including the element at index
and excluding the first element) are elements of left subtree.

 */

package DataStructures.BinaryTree.Traversals;

public class PostFromPreIn {
	private static int preIndex = 0;

	private static void printPost(int[] inorder, int[] preorder, int inStart, int inEnd) {
		if (inStart > inEnd) {
			return;
		}
		int index = search(inorder, preorder[preIndex++], inStart, inEnd);

		printPost(inorder, preorder, inStart, index - 1);
		printPost(inorder, preorder, index + 1, inEnd);
		System.out.print(inorder[index] + " ");
	}

	private static int search(int[] inorder, int data, int start, int end) {
		int pos;
		for (pos = start; pos < end; pos++) {
			if (data == inorder[pos]) {
				return pos;
			}
		}
		return pos;
	}

	public static void main(String[] args) {
		int[] in = {4, 2, 5, 1, 3, 6};
		int[] pre = {1, 2, 4, 5, 3, 6};
		int len = in.length;
		printPost(in, pre, 0, len - 1);
	}
}


 ===================================================== 


PostorderFromPreorderBST.java


/*
Find postorder traversal of BST from preorder traversal

An efficient approach is to find postorder traversal without constructing the tree.
The idea is to traverse the given preorder array and maintain a range in which current element should lie.
This is to ensure that BST property is always satisfied. Initially the range is set to
{minval = INT_MIN, maxval = INT_MAX}. In preorder traversal, the first element is always the
root and it will certainly lie in initial range. So store the first element of the preorder array.
In postorder traversal, first left and right subtrees are printed and then root data is printed.
So first recursive call for left and right subtrees are performed and then the value of root is printed.
For left subtree range is updated to {minval, root->data} and for right subtree range is updated to
{root->data, maxval}. If current preorder array element does not lie in the range specified for it,
then it does not belong to a current subtree, return from recursive calls until correct position of
that element is not found.

https://www.geeksforgeeks.org/find-postorder-traversal-of-bst-from-preorder-traversal/
 */

package DataStructures.BinaryTree.Traversals;

public class PostorderFromPreorderBST {
	private static void postOrder(int[] preorder, int n, int min, int max, int preIndex) {
		if (preorder[preIndex] == n) {
			return;
		}
		if (preorder[preIndex] < min || preorder[preIndex] > max) {
			return;
		}
		int val = preorder[preIndex++];
		postOrder(preorder, n, min, val, preIndex);
		postOrder(preorder, n, val, max, preIndex);
		System.out.println(val + " ");
	}

	public static void main(String[] args) {
		int[] pre = {40, 30, 35, 80, 100};
		int n = pre.length;
		postOrder(pre, n, Integer.MIN_VALUE, Integer.MAX_VALUE, 0);
	}
}


 ===================================================== 


ReverseLevelOrder.java


/*
The method 2 of normal level order traversal can also be easily modified to print level order traversal
in reverse order. The idea is to use a stack to get the reverse level order.
If we do normal level order traversal and instead of printing a node,
push the node to a stack and then print contents of stack, we get 5 4 3 2 1 for above example tree,
but output should be 4 5 2 3 1. So to get the correct sequence (left to right at every level),
we process children of a node in reverse order, we first push the right subtree to stack, then left subtree.

https://www.geeksforgeeks.org/reverse-level-order-traversal/
 */

package DataStructures.BinaryTree.Traversals;

import Commons.Node;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

@SuppressWarnings("Duplicates")
public class ReverseLevelOrder {
	public static void main(String[] args) {
		Node root;
		root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		System.out.println("Level order traversal of binary tree is - ");
		reverseLevelOrder(root);
	}

	private static void reverseLevelOrder(Node root) {
		Queue<Node> queue = new LinkedList<>();
		Stack<Integer> stack = new Stack<>();
		Node tempNode = root;
		queue.add(tempNode);
		while (!queue.isEmpty()) {
			tempNode = queue.poll();
			stack.add(tempNode.data);
			if (tempNode.right != null) {
				queue.add(tempNode.right);
			}
			if (tempNode.left != null) {
				queue.add(tempNode.left);
			}
		}
		while (!stack.isEmpty()) {
			System.out.print(stack.pop() + " ");
		}
	}
}


 ===================================================== 


TreeTraversalBasics.java


package DataStructures.BinaryTree.Traversals;

import Commons.Node;

public class TreeTraversalBasics {
	public static void preOrder(Node root) {
		if (root == null) {
			return;
		}
		System.out.print(root.data + " ");
		preOrder(root.left);
		preOrder(root.right);
	}

	public static void inOrder(Node root) {
		if (root == null) {
			return;
		}
		inOrder(root.left);
		System.out.print(root.data + " ");
		inOrder(root.right);
	}

	public static void postOrder(Node root) {
		if (root == null) {
			return;
		}
		postOrder(root.left);
		postOrder(root.right);
		System.out.print(root.data + " ");
	}

	@SuppressWarnings("Duplicates")
	public static void main(String[] args) {
		Node root;
		root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);

		System.out.println("Preorder traversal of binary tree is ");
		preOrder(root);

		System.out.println("\nInorder traversal of binary tree is ");
		inOrder(root);

		System.out.println("\nPostorder traversal of binary tree is ");
		postOrder(root);
	}
}


 ===================================================== 


PathMoreThanK.java


package DataStructures.Graphs.Backtracking;

import Commons.GraphMatrix;

public class PathMoreThanK {
	private static boolean pathTraversal(int[][] graph, int V,
										 boolean[] path, int node, int K) {
		if (K <= 0) {
			return true;
		}

		for (int v = 0; v < V; v++) {
			if (graph[node][v] > 0) {
				if (path[v]) {
					continue;
				}
				if (graph[node][v] >= K) {
					return true;
				}
				path[v] = true;
				if (pathTraversal(graph, V, path, v, K - graph[node][v])) {
					return true;
				}
				path[v] = false;
			}
		}
		return false;
	}

	private static boolean pathMoreThanK(int[][] graph, int V, int source, int K) {
		boolean[] path = new boolean[V];
		path[source] = true;
		return pathTraversal(graph, V, path, source, K);
	}

	public static void main(String[] args) {
		int V = 9;
		GraphMatrix g = new GraphMatrix(V, false, true);
		g.addEdge(0, 1, 4);
		g.addEdge(0, 7, 8);
		g.addEdge(1, 2, 8);
		g.addEdge(1, 7, 11);
		g.addEdge(2, 3, 7);
		g.addEdge(2, 8, 2);
		g.addEdge(2, 5, 4);
		g.addEdge(3, 4, 9);
		g.addEdge(3, 5, 14);
		g.addEdge(4, 5, 10);
		g.addEdge(5, 6, 2);
		g.addEdge(6, 7, 1);
		g.addEdge(6, 8, 6);
		g.addEdge(7, 8, 7);
		int source = 0, K = 62;
		int[][] graph = g.getGraph();
		System.out.println(pathMoreThanK(graph, V, source, K));
		System.out.println(pathMoreThanK(graph, V, source, 60));
	}
}


 ===================================================== 


KCores.java


/*
https://www.geeksforgeeks.org/find-k-cores-graph/
 */
package DataStructures.Graphs.Connectivity;

import java.util.Arrays;

public class KCores {
	public static void main(String[] args) {
		int[][] graph = {
				{0, 1, 1, 0, 0, 0, 0, 0, 0}, // 0
				{1, 0, 1, 0, 0, 1, 0, 0, 0}, // 1
				{1, 1, 0, 1, 1, 1, 1, 0, 0}, // 2
				{0, 0, 1, 0, 1, 0, 1, 1, 0},
				{0, 0, 1, 1, 0, 0, 1, 1, 0},
				{0, 1, 1, 0, 0, 0, 1, 0, 1},
				{0, 0, 1, 1, 1, 1, 0, 1, 1},
				{0, 0, 0, 1, 1, 0, 1, 0, 0},
				{0, 0, 0, 0, 0, 1, 1, 0, 0},
		};
		int V = 9;
		int K = 3;
		kCores(graph, V, K);
	}

	private static void kCores(int[][] graph, int V, int K) {
		int[] degree = new int[V];
		Arrays.fill(degree, 0);
		for (int i = 0; i < V; i++) {
			for (int j : graph[i]) {
				if (j == 1) {
					degree[i]++;
				}
			}
		}

		boolean[] visited = new boolean[V];

		for (int v = 0; v < V; v++) {
			if (!visited[v]) {
				DFSUtil(graph, degree, v, visited, K, V);
			}
		}

		for (int v = 0; v < V; v++) {
			if (degree[v] >= K) {
				System.out.print("\n" + v + " => ");
				for (int x = 0; x < V; x++) {
					if (graph[v][x] == 1 && degree[x] >= K) {
						System.out.print(x + ", ");
					}
				}
			}
		}
	}

	private static boolean DFSUtil(int[][] graph, int[] degree, int v,
								   boolean[] visited, int K, int V) {
		visited[v] = true;
		for (int x = 0; x < V; x++) {
			if (graph[v][x] == 1) {
				if (degree[v] < K) {
					degree[x]--;
				}
				if (!visited[x]) {
					if (DFSUtil(graph, degree, x, visited, K, V)) {
						degree[v]--;
					}
				}
			}
		}
		return degree[v] < K;
	}
}


 ===================================================== 


Kosaraju.java


/*
Strongly Connected Components
A directed graph is strongly connected if there is a path between all pairs of vertices.
A strongly connected component (SCC) of a directed graph is a maximal strongly connected subgraph.

We can find all strongly connected components in O(V+E) time using Kosarajus algorithm.
Following is detailed Kosarajus algorithm.
	1) Create an empty stack S and do DFS traversal of a graph.
		In DFS traversal, after calling recursive DFS for adjacent vertices of a vertex,
		push the vertex to stack. In the above graph, if we start DFS from vertex 0,
		we get vertices in stack as 1, 2, 4, 3, 0.
	2) Reverse directions of all arcs to obtain the transpose graph.
	3) One by one pop a vertex from S while S is not empty.
		Let the popped vertex be v. Take v as source and do DFS (call DFSUtil(v)).
		The DFS starting from v prints strongly connected component of v.
		In the above example, we process vertices in order 0, 3, 4, 2, 1 (One by one popped from stack).
 */
package DataStructures.Graphs.Connectivity;

import Commons.GraphMatrix;

import java.util.Stack;

public class Kosaraju {
	private static int[][] graphTranspose(int[][] graph, int V) {
		int[][] transpose = new int[V][V];
		for (int i = 0; i < V; i++) {
			for (int j = 0; j < V; j++) {
				transpose[i][j] = graph[j][i];
			}
		}
		return transpose;
	}

	private static void DFSUtil(int[][] graph, int V, int node, boolean fillOrder,
								boolean[] visited, Stack<Integer> stack) {
		visited[node] = true;
		if (!fillOrder) {
			System.out.print(node + ", ");
		}
		for (int v = 0; v < V; v++) {
			if (graph[node][v] == 1 && !visited[v]) {
				DFSUtil(graph, V, v, fillOrder, visited, stack);
			}
		}
		if (fillOrder) {
			stack.push(node);
		}
	}

	private static void showSCC(int[][] graph, int V) {
		boolean[] visited = new boolean[V];
		Stack<Integer> stack = new Stack<>();
		for (int v = 0; v < V; v++) {
			if (!visited[v]) {
				DFSUtil(graph, V, v, true, visited, stack);
			}
		}
		graph = graphTranspose(graph, V);
		visited = new boolean[V];
		while (!stack.isEmpty()) {
			int node = stack.pop();
			if (!visited[node]) {
				DFSUtil(graph, V, node, false, visited, stack);
				System.out.println();
			}
		}
	}

	public static void main(String[] args) {
		int V = 5;
		GraphMatrix g = new GraphMatrix(V, true, true);
		g.addEdge(1, 0);
		g.addEdge(0, 2);
		g.addEdge(2, 1);
		g.addEdge(0, 3);
		g.addEdge(3, 4);
		showSCC(g.getGraph(), V);
	}
}


 ===================================================== 


MinimumSumOfConnectedComponents.java


/*
Sum of the minimum elements in all connected components of an undirected graph

Given an array A of N numbers where Ai represent the value of the (i+1)th node.
Also given are M pair of edges where u and v represent the nodes that are connected by an edge.
The task is to find the sum of the minimum element in all the connected components of the given undirected graph.
If a node has no connectivity to any other node, count it as a component with one node.

https://www.geeksforgeeks.org/sum-of-the-minimum-elements-in-all-connected-components-of-an-undirected-graph/
*/


package DataStructures.Graphs.Connectivity;

import Commons.GraphMatrix;

public class MinimumSumOfConnectedComponents {
	private static void DFS(int[][] graph, int V, int[] values,
							int node, int mini, boolean[] visited) {
		mini = Math.min(mini, values[node]);
		visited[node] = true;
		for (int i = 0; i < V; i++) {
			if (graph[node][i] == 1 && !visited[i]) {
				DFS(graph, V, values, i, mini, visited);
			}
		}
	}

	private static int getSum(int[][] graph, int V, int[] values) {
		boolean[] visited = new boolean[V];
		int sum = 0, mini;
		for (int i = 0; i < V; i++) {
			if (!visited[i]) {
				mini = values[i];
				DFS(graph, V, values, i, mini, visited);
				sum += mini;
			}
		}
		return sum;
	}

	public static void main(String[] args) {
//		int[] values = {1, 6, 2, 7, 3, 8, 4, 9, 5, 10};
//		GraphMatrix graphMatrix = new GraphMatrix(10, false);
//		graphMatrix.addEdge(1, 2, false);
//		graphMatrix.addEdge(3, 4, false);
//		graphMatrix.addEdge(5, 6, false);
//		graphMatrix.addEdge(7, 8, false);
//		graphMatrix.addEdge(9, 10, false);

		GraphMatrix graphMatrix = new GraphMatrix(10, false, false);
		int[] values = {2, 5, 3, 4, 8};
		graphMatrix.addEdge(1, 4);
		graphMatrix.addEdge(4, 5);
		System.out.println(getSum(graphMatrix.getGraph(), values.length, values));
	}
}


 ===================================================== 


MotherVertex.java


/*
Finding the mother vertex of a graph. A mother vertex is such that starting a graph traversal with that vertex, one
can visit all the vertices of the graph.
The following approach does the following by performing a DFS and noting the last visited vertex. Then another DFS is
performed and checked whether all vertices are visited or not.
 */

package DataStructures.Graphs.Connectivity;

import java.util.Arrays;

public class MotherVertex {
	public static void main(String[] args) {
		int[][] graph = {
				{0, 1, 1, 0, 0, 0, 0},
				{0, 0, 0, 1, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0},
				{0, 1, 0, 0, 0, 0, 0},
				{0, 0, 1, 0, 0, 0, 1},
				{1, 0, 0, 0, 1, 0, 0},
		};
		int V = 7;
		System.out.println(new MotherVertex().findMother(graph, V));
	}

	private void DFS(int[][] graph, int v, boolean[] visited, int V) {
		visited[v] = true;
		for (int x = 0; x < V; x++) {
			if (graph[v][x] == 1 && !visited[x]) {
				DFS(graph, x, visited, V);
			}
		}
	}

	private int findMother(int[][] graph, int V) {
		int v = 0;
		boolean[] visited = new boolean[V];
		for (int i = 0; i < V; i++) {
			if (!visited[i]) {
				DFS(graph, i, visited, V);
				v = i;
			}
		}
		Arrays.fill(visited, false);
		DFS(graph, v, visited, V);
		for (boolean b : visited) {
			if (!b) {
				return -1;
			}
		}
		return v;
	}
}


 ===================================================== 


NumberOfIslands.java


/*
Find the number of islands | Set 1 (Using DFS)
Given a boolean 2D matrix, find the number of islands.
A group of connected 1s forms an island. For example, the below matrix contains 5 islands

Example:
Input : mat[][] = {{1, 1, 0, 0, 0},
                   {0, 1, 0, 0, 1},
                   {1, 0, 0, 1, 1},
                   {0, 0, 0, 0, 0},
                   {1, 0, 1, 0, 1}
Output : 5
 */

package DataStructures.Graphs.Connectivity;

public class NumberOfIslands {
	private static void DFSUtil(int[][] matrix, int m, int n,
								int row, int col, boolean[][] visited) {
		visited[row][col] = true;
		int[] rowMovement = {-1, -1, -1, 0, 0, 1, 1, 1};
		int[] colMovement = {-1, 0, 1, -1, 1, -1, 0, 1};
		for (int k = 0; k < 8; k++) {
			if (isSafe(row + rowMovement[k], col + colMovement[k], m, n) &&
					!visited[row + rowMovement[k]][col + colMovement[k]] &&
					(matrix[row + rowMovement[k]][col + colMovement[k]] != 0)) {
				DFSUtil(matrix, m, n, row + rowMovement[k],
						col + colMovement[k], visited);
			}
		}
	}

	private static boolean isSafe(int row, int col, int m, int n) {
		return ((row >= 0) && (col >= 0) && (row < m) && (col < n));
	}

	private static int numberOfIslands(int[][] matrix, int m, int n) {
		boolean[][] visited = new boolean[m][n];
		int count = 0;
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (matrix[i][j] == 1 && !visited[i][j]) {
					DFSUtil(matrix, m, n, i, j, visited);
					count++;
				}
			}
		}
		return count;
	}

	public static void main(String[] args) {
		int[][] matrix = {
				{1, 1, 0, 0, 0},
				{0, 1, 0, 0, 1},
				{1, 0, 0, 1, 1},
				{0, 0, 0, 0, 0},
				{1, 0, 1, 0, 1}};
		int m = 5, n = 5;
		System.out.println(numberOfIslands(matrix, m, n));
	}
}


 ===================================================== 


CyclesInDigraph.java


package DataStructures.Graphs.Cycles;

public class CyclesInDigraph {
	private static boolean cyclic(int[][] graph, int v, boolean[] recursion,
								  boolean[] visited, int V) {

		// Present in the recursion stack => Cycle exists
		if (recursion[v])
			return true;

		// If not present in recursive stack, but visited => skip it
		if (visited[v])
			return false;

		// Mark in recursive stack that the current node is under recursion
		recursion[v] = true;
		visited[v] = true;
		for (int i = 0; i < V; i++) {
			if (graph[v][i] == 1 && !visited[i]) {
				if (cyclic(graph, i, recursion, visited, V)) {
					return true;
				}
			}
		}
		recursion[v] = false;
		return false;
	}

	private static boolean detectCycle(int[][] graph, int V) {
		boolean[] visited = new boolean[V];
		boolean[] recursion = new boolean[V];
		for (int v = 0; v < V; v++) {
			if (cyclic(graph, v, recursion, visited, V)) {
				return true;
			}
		}
		return false;
	}

	public static void main(String[] args) {
//		int[][] graph = {
//				{0, 1, 1, 0},
//				{0, 0, 0, 0},
//				{0, 0, 0, 1},
//				{0, 0, 0, 0}
//		};
//		int V = 4;

		int[][] graph = {
				{0, 1},
				{1, 0}
		};
		int V = 2;
		System.out.println(detectCycle(graph, V));
	}
}


 ===================================================== 


RectanglesWithCircles.java


/*
There is a m*n rectangular matrix whose top-left(start)
location is (1, 1) and bottom-right(end) location is (m*n).
There are k circles each with radius r. Find if there is any path from start to end without touching any circle.

The input contains values of m, n, k, r and two array of integers X and Y, each of length k.
(X[i], Y[i]) is the centre of ith circle.

https://www.geeksforgeeks.org/path-rectangle-containing-circles/
 */

package DataStructures.Graphs.Cycles;

import java.util.LinkedList;
import java.util.Queue;

public class RectanglesWithCircles {
	public static void main(String[] args) {
		int m = 5, n = 5, k = 2, r = 1;
		System.out.println(doesPathExist(m, n, k, r, new int[]{1, 3}, new int[]{3, 3}));
		System.out.println(doesPathExist(m, n, k, r, new int[]{1, 1}, new int[]{2, 3}));
	}

	private static boolean doesPathExist(int m, int n, int k, int r, int[] X, int[] Y) {
		int[][] rectangle = new int[m][n];
		// check for reachable cells
		for (int c = 0; c < k; c++) {
			for (int i = 0; i < m; i++) {
				for (int j = 0; j < n; j++) {
					if (underCircle(i, j, X[c], Y[c], r)) {
						rectangle[i][j] = -1;
					}
				}
			}
		}
		if (rectangle[0][0] == -1) {
			return false;
		}
		rectangle[0][0] = 1;
		Queue<Integer[]> queue = new LinkedList<>();
		queue.add(new Integer[]{0, 0});
		while (!queue.isEmpty()) {
			Integer[] current = queue.poll();
			int x = current[0], y = current[1];
			// Top left
			if (x > 0 && y > 0 && rectangle[x - 1][y - 1] == 0) {
				rectangle[x - 1][y - 1] = 1;
				queue.add(new Integer[]{x - 1, y - 1});
			}
			// Top
			if (x > 0 && rectangle[x - 1][y] == 0) {
				rectangle[x - 1][y] = 1;
				queue.add(new Integer[]{x - 1, y});
			}
			// Top right
			if (x > 0 && y < n - 1 && rectangle[x - 1][y + 1] == 0) {
				rectangle[x - 1][y + 1] = 1;
				queue.add(new Integer[]{x - 1, y + 1});
			}
			// left
			if (y > 0 && rectangle[x][y - 1] == 0) {
				rectangle[x][y - 1] = 1;
				queue.add(new Integer[]{x, y - 1});
			}
			// Right
			if (y < n - 1 && rectangle[x][y + 1] == 0) {
				rectangle[x][y + 1] = 1;
				queue.add(new Integer[]{x, y + 1});
			}
			// Bottom left
			if (x < m - 1 && y > 0 && rectangle[x + 1][y - 1] == 0) {
				rectangle[x + 1][y - 1] = 1;
				queue.add(new Integer[]{x + 1, y - 1});
			}
			// Bottom
			if (x < m - 1 && rectangle[x + 1][y] == 0) {
				rectangle[x + 1][y] = 1;
				queue.add(new Integer[]{x + 1, y});
			}
			// Bottom left
			if (x < m - 1 && y < n - 1 && rectangle[x + 1][y + 1] == 0) {
				rectangle[x + 1][y + 1] = 1;
				queue.add(new Integer[]{x + 1, y + 1});
			}
		}
		return rectangle[m - 1][n - 1] == 1;
	}

	private static boolean underCircle(int x1, int y1, int x2, int y2, int r) {
		x2--;
		y2--;
		return Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow(y1 - y2, 2)) <= r;
	}
}


 ===================================================== 


ShortestChain.java


package DataStructures.Graphs.Cycles;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class ShortestChain {
	public static void main(String[] args) {
//		String[] words = {"POON", "PLEE", "SAME", "POIE", "PLEA", "PLIE", "POIN"};
//		ArrayList<String> dictionary = new ArrayList<>(Arrays.asList(words));
//		String start = "TOON";
//		String find = "POIN";
		String[] words = {"hot", "dot", "dog", "lot", "log", "cog"};
		ArrayList<String> dictionary = new ArrayList<>(Arrays.asList(words));
		String start = "hit";
		String find = "cog";
//		String[] words = {"a", "b", "c"};
//		ArrayList<String> dictionary = new ArrayList<>(Arrays.asList(words));
//		String start = "a";
//		String find = "c";
		System.out.println(new ShortestChain().findChainLength(dictionary, start, find));
	}

	private int findChainLength(ArrayList<String> dictionary, String start, String target) {
		Queue<Entry> queue = new LinkedList<>();
		boolean[] visited = new boolean[dictionary.size()];
		if (dictionary.contains(start)) {
			visited[dictionary.indexOf(start)] = true;
		}
		queue.add(new Entry(start, 1));
		Entry word;
		while (!queue.isEmpty()) {
			word = queue.poll();
			start = word.s;
			if (start.equals(target)) {
				return word.length;
			}
			for (int i = 0; i < dictionary.size(); i++) {
				if (isAdjacent(start, dictionary.get(i)) && !visited[i]) {
					queue.add(new Entry(dictionary.get(i), word.length + 1));
					visited[i] = true;
				}
			}
		}
		return -1;
	}

	private boolean isAdjacent(String a, String b) {
		int count = 0;
		for (int pos = 0; pos < a.length(); pos++) {
			if (a.charAt(pos) != b.charAt(pos)) {
				count++;
			}
			if (count > 1) {
				return false;
			}
		}
		return count == 1;
	}

	static class Entry {
		String s;
		int length;

		Entry(String s, int length) {
			this.s = s;
			this.length = length;
		}
	}
}


 ===================================================== 


ShortestSourcePath.java


/*
Shortest Source to Destination Path

Given a boolean 2D matrix (0-based index), find whether there is path from (0,0) to (x,y) and
if there is one path, print the minimum no of steps needed to reach it,
else print -1 if the destination is not reachable. You may move in only four direction
ie up, down, left and right. The path can only be created out of a cell if its value is 1.

Input:
The first line of input contains an integer T denoting the no of test cases.
Then T test cases follow. Each test case contains two lines .
The first line of each test case contains two integers n and m denoting the size of the matrix.
Then in the next line are n*m space separated values of the matrix.
The following line after it contains two integers x and y denoting the index of the destination.

Output:
For each test case print in a new line the min no of steps needed to reach the destination.

Constraints:
1<=T<=100
1<=n,m<=20

Example:
Input:
2
3 4
1 0 0 0 1 1 0 1 0 1 1 1
2 3
3 4
1 1 1 1 0 0 0 1 0 0 0 1
0 3
Output:
5
3

Approach =>
The idea is to BFS (breadth first search) on matrix cells.
Note that we can always use BFS to find shortest path if graph is unweighted.
	1. Store each cell as a node with their row, column values and distance from source cell.
	2. Start BFS with source cell.
	3. Make a visited array with all having false values except 0cells which are assigned true values
		as they can not be traversed.
	4. Keep updating distance from source value in each move.
	5. Return distance when destination is met, else return -1 (no path exists in between source and destination).

https://practice.geeksforgeeks.org/problems/shortest-source-to-destination-path/
 */

package DataStructures.Graphs.Cycles;

import java.util.LinkedList;
import java.util.Queue;

public class ShortestSourcePath {
	public static void main(String[] args) {
		try {
			int m = 3, n = 4;
			int[][] matrix = new int[m][n];
			String[] elements = "1 0 0 0 1 1 0 1 0 1 1 1".split(" ");
			int k = 0;
			for (int i = 0; i < m; i++) {
				for (int j = 0; j < n; j++) {
					matrix[i][j] = Integer.parseInt(elements[k]);
					k++;
				}
			}
			int destX = 2, destY = 3;
			System.out.println(minimumDistance(matrix, m, n, destX, destY));
		} catch (Exception e) {
			System.out.println(e.getMessage());
		}
	}

	private static int minimumDistance(int[][] matrix, int m, int n, int destX, int destY) {
		if (destX == 0 && destY == 0) {
			return 0;
		}

		boolean[][] visited = new boolean[m][n];

		// Marking invalid nodes as visited
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (matrix[i][j] == 0) {
					visited[i][j] = true;
					if (i == destX && j == destY) {
						return -1;
					}
				}
			}
		}

		QueueItem source = new QueueItem(0, 0, 0);
		Queue<QueueItem> queue = new LinkedList<>();
		queue.add(source);
		visited[0][0] = true;
		while (!queue.isEmpty()) {
			source = queue.poll();
			int row = source.row, col = source.col;
			if (row == destX && col == destY) {
				return source.steps;
			} else {
				// Top
				if (row > 0 && !visited[row - 1][col]) {
					queue.add(new QueueItem(row - 1, col, source.steps + 1));
					visited[row - 1][col] = true;
				}

				// Bottom
				if (row < m - 1 && !visited[row + 1][col]) {
					queue.add(new QueueItem(row + 1, col, source.steps + 1));
					visited[row + 1][col] = true;
				}

				// Right
				if (col < n - 1 && !visited[row][col + 1]) {
					queue.add(new QueueItem(row, col + 1, source.steps + 1));
					visited[row][col + 1] = true;
				}

				// Left
				if (col > 0 && !visited[row][col - 1]) {
					queue.add(new QueueItem(row, col - 1, source.steps + 1));
					visited[row][col - 1] = true;
				}
			}
		}
		return -1;
	}

	static class QueueItem {
		int row, col, steps;

		QueueItem(int row, int col, int steps) {
			this.row = row;
			this.col = col;
			this.steps = steps;
		}
	}
}


 ===================================================== 


UnionFind.java


package DataStructures.Graphs.Cycles;

import java.util.Arrays;

public class UnionFind {
	private static int Find(int[] parent, int i) {
		if (parent[i] == -1)
			return i;
		else
			return Find(parent, parent[i]);
	}

	private static void Union(int[] parent, int x, int y) {
		int xSet = Find(parent, x);
		int ySet = Find(parent, y);
		parent[xSet] = ySet;
	}

	private static boolean isCycle(Graph graph) {
		int[] parent = new int[graph.V];
		Arrays.fill(parent, -1);
		for (int i = 0; i < graph.E; i++) {
			int x = Find(parent, graph.edges[i].source);
			int y = Find(parent, graph.edges[i].destination);
			if (x == y)
				return true;
			Union(parent, x, y);
		}
		return false;
	}

	public static void main(String[] args) {
		int V = 3, E = 3;
		Graph graph = new Graph(V, E);

		// add edge 0-1
		graph.edges[0].source = 0;
		graph.edges[0].destination = 1;

		// add edge 1-2
		graph.edges[1].source = 1;
		graph.edges[1].destination = 2;

		// add edge 0-2
		graph.edges[2].source = 0;
		graph.edges[2].destination = 2;

		if (isCycle(graph))
			System.out.println("graph contains cycle");
		else
			System.out.println("graph doesn't contain cycle");
	}

	private static class Graph {
		int V, E;
		Edge[] edges;

		public Graph(int v, int e) {
			V = v;
			E = e;
			edges = new Edge[E];
			for (int i = 0; i < e; i++)
				edges[i] = new Edge();
		}
	}

	private static class Edge {
		int source;
		int destination;
	}
}


 ===================================================== 


Dijkstra.java


package DataStructures.Graphs.SpanningTrees;

import java.util.Arrays;
import java.util.HashSet;

@SuppressWarnings("Duplicates")
public class Dijkstra {
	public static void main(String[] args) {
		int[][] graph = {
				{0, 4, 0, 0, 0, 0, 0, 8, 0},
				{4, 0, 8, 0, 0, 0, 0, 11, 0},
				{0, 8, 0, 7, 0, 4, 0, 0, 2},
				{0, 0, 7, 0, 9, 14, 0, 0, 0},
				{0, 0, 0, 9, 0, 10, 0, 0, 0},
				{0, 0, 4, 14, 10, 0, 2, 0, 0},
				{0, 0, 0, 0, 0, 2, 0, 1, 6},
				{8, 11, 0, 0, 0, 0, 1, 0, 7},
				{0, 0, 2, 0, 0, 0, 6, 7, 0}
		};
		int V = graph.length, source = 0;
		dijkstra(graph, V, source);
	}

	private static void dijkstra(int[][] graph, int V, int source) {
		HashSet<Integer> sptSet = new HashSet<>();
		int[] distances = new int[V];
		Arrays.fill(distances, Integer.MAX_VALUE);
		distances[source] = 0;
		while (sptSet.size() != V) {
			int u = findMinimum(distances, sptSet, V);
			sptSet.add(u);
			for (int v = 0; v < V; v++) {
				if (!sptSet.contains(v) && graph[u][v] > 0
						&& distances[u] + graph[u][v] < distances[v]) {
					distances[v] = distances[u] + graph[u][v];
				}
			}

		}
		printSolution(distances, V);
	}

	private static int findMinimum(int[] distances, HashSet<Integer> sptSet, int V) {
		int small = Integer.MAX_VALUE, pos = 0;
		for (int i = 0; i < V; i++) {
			if (!sptSet.contains(i)) {
				if (distances[i] < small) {
					small = distances[i];
					pos = i;
				}
			}
		}
		return pos;
	}

	private static void printSolution(int[] dist, int V) {
		System.out.println("Vertex \t\t Distance from Source");
		for (int i = 0; i < V; i++)
			System.out.println(i + " \t\t " + dist[i]);
	}
}


 ===================================================== 


FloydWarshall.java


package DataStructures.Graphs.SpanningTrees;

public class FloydWarshall {
	private static final int INF = 9999;

	public static void main(String[] args) {
		int[][] graph = {
				{0, 5, INF, 10},
				{INF, 0, 3, INF},
				{INF, INF, 0, 1},
				{INF, INF, INF, 0}
		};
		floydWarshall(graph, graph.length);
	}

	private static void floydWarshall(int[][] graph, int V) {
		int[][] distance = graph.clone();
		for (int k = 0; k < V; k++) {
			for (int i = 0; i < V; i++) {
				for (int j = 0; j < V; j++) {
					if (distance[i][k] + distance[k][j] < distance[i][j]) {
						distance[i][j] = distance[i][k] + distance[k][j];
					}
				}
			}
		}
		printSolution(distance, V);
	}

	private static void printSolution(int[][] dist, int V) {
		System.out.println("The following matrix shows the shortest " +
				"distances between every pair of vertices");
		for (int i = 0; i < V; ++i) {
			for (int j = 0; j < V; ++j) {
				if (dist[i][j] == INF)
					System.out.print("INF ");
				else
					System.out.print(dist[i][j] + "   ");
			}
			System.out.println();
		}
	}
}


 ===================================================== 


Kruskal.java


package DataStructures.Graphs.SpanningTrees;

import java.util.Arrays;

public class Kruskal {
	private static int Find(subset[] subsets, int i) {
		if (subsets[i].parent != i)
			subsets[i].parent = Find(subsets, subsets[i].parent);

		return subsets[i].parent;
	}

	private static void Union(subset[] subsets, int x, int y) {
		int xRoot = Find(subsets, x);
		int yRoot = Find(subsets, y);

		// Attach smaller rank tree under root of high rank tree
		// (Union by Rank)
		if (subsets[xRoot].rank < subsets[yRoot].rank)
			subsets[xRoot].parent = yRoot;
		else if (subsets[xRoot].rank > subsets[yRoot].rank)
			subsets[yRoot].parent = xRoot;

			// If ranks are same, then make one as root and increment
			// its rank by one
		else {
			subsets[yRoot].parent = xRoot;
			subsets[xRoot].rank++;
		}
	}

	private static void KruskalMST(Graph graph, int V) {
		Edge[] result = new Edge[V];
		int e = 0, i = 0;
		Arrays.fill(result, new Edge());
		Edge[] edge = graph.edge;
		Arrays.sort(edge);
		subset[] subsets = new subset[V];
		for (int v = 0; v < V; v++) {
			subsets[v] = new subset();
			subsets[v].parent = v;
			subsets[v].rank = 0;
		}

		while (e < V - 1) {
			// Step 2: Pick the smallest edge. And increment
			// the index for next iteration
			Edge next_edge = edge[i++];

			int x = Find(subsets, next_edge.source);
			int y = Find(subsets, next_edge.dest);

			// If including this edge does't cause cycle,
			// include it in result and increment the index
			// of result for next edge
			if (x != y) {
				result[e++] = next_edge;
				Union(subsets, x, y);
			}
			// Else discard the next_edge
		}

		// print the contents of result[] to display
		// the built MST
		System.out.println("Following are the edges in " +
				"the constructed MST");
		for (i = 0; i < e; ++i)
			System.out.println(result[i].source + " -- " +
					result[i].dest + " == " + result[i].weight);
	}

	public static void main(String[] args) {
		int V = 4;  // Number of vertices in graph
		int E = 5;  // Number of edges in graph
		Graph graph = new Graph(V, E);

		// add edge 0-1
		graph.edge[0].source = 0;
		graph.edge[0].dest = 1;
		graph.edge[0].weight = 10;

		// add edge 0-2
		graph.edge[1].source = 0;
		graph.edge[1].dest = 2;
		graph.edge[1].weight = 6;

		// add edge 0-3
		graph.edge[2].source = 0;
		graph.edge[2].dest = 3;
		graph.edge[2].weight = 5;

		// add edge 1-3
		graph.edge[3].source = 1;
		graph.edge[3].dest = 3;
		graph.edge[3].weight = 15;

		// add edge 2-3
		graph.edge[4].source = 2;
		graph.edge[4].dest = 3;
		graph.edge[4].weight = 4;

		KruskalMST(graph, V);
	}

	static class Edge implements Comparable<Edge> {
		int source, dest, weight;

		public int compareTo(Edge compareEdge) {
			return this.weight - compareEdge.weight;
		}
	}

	static class subset {
		int parent, rank;
	}

	static class Graph {
		int V, E;
		Edge[] edge;

		public Graph(int v, int e) {
			V = v;
			E = e;
			edge = new Edge[E];
			for (int i = 0; i < e; ++i)
				edge[i] = new Edge();
		}
	}
}


 ===================================================== 


MinProductSpanningTree.java


package DataStructures.Graphs.SpanningTrees;

import java.util.Arrays;
import java.util.HashSet;

@SuppressWarnings("Duplicates")
public class MinProductSpanningTree {
	public static void main(String[] args) {
		int[][] graph = {
				{0, 2, 0, 6, 0},
				{2, 0, 3, 8, 5},
				{0, 3, 0, 0, 7},
				{6, 8, 0, 0, 9},
				{0, 5, 7, 9, 0},
		};

		// Print the solution
		System.out.println(getMinimumProduct(graph, graph.length));
	}

	private static int getMinimumProduct(int[][] graph, int V) {
		double[][] logGraph = new double[V][V];
		for (int i = 0; i < V; i++) {
			for (int j = 0; j < V; j++) {
				logGraph[i][j] = graph[i][j] > 0 ? Math.log(graph[i][j]) : 0;
			}
		}
		return MinSpanningTree(graph, V, logGraph);
	}

	private static int MinSpanningTree(int[][] graph, int V, double[][] logGraph) {
		HashSet<Integer> mstSet = new HashSet<>();
		double[] distances = new double[V];
		int[] parent = new int[V];
		Arrays.fill(distances, Integer.MAX_VALUE);
		distances[0] = 0.0;
		while (mstSet.size() != V) {
			int vertex = findMinimum(distances, mstSet, V);
			mstSet.add(vertex);
			for (int v = 0; v < V; v++) {
				if (logGraph[vertex][v] > 0 && logGraph[vertex][v] < distances[v] &&
						!mstSet.contains(v)) {
					distances[v] = logGraph[vertex][v];
					parent[v] = vertex;
				}
			}
		}
		return printMST(graph, V, parent);
	}

	private static int findMinimum(double[] distances, HashSet<Integer> mstSet, int V) {
		double small = Double.MAX_VALUE;
		int pos = 0;
		for (int i = 0; i < V; i++) {
			if (!mstSet.contains(i)) {
				if (distances[i] < small) {
					small = distances[i];
					pos = i;
				}
			}
		}
		return pos;
	}

	private static int printMST(int[][] graph, int V, int[] parent) {
		int product = 1;
		for (int i = 1; i < V; i++) {
			product *= graph[parent[i]][i];
		}
		return product;
	}
}


 ===================================================== 


Prims.java


package DataStructures.Graphs.SpanningTrees;

import java.util.Arrays;
import java.util.HashSet;

@SuppressWarnings("Duplicates")
public class Prims {
	public static void main(String[] args) {
		int[][] graph = {
				{0, 2, 0, 6, 0},
				{2, 0, 3, 8, 5},
				{0, 3, 0, 0, 7},
				{6, 8, 0, 0, 9},
				{0, 5, 7, 9, 0}
		};
		int V = graph.length;
		MinSpanningTree(graph, V);
	}

	private static void MinSpanningTree(int[][] graph, int V) {
		HashSet<Integer> mstSet = new HashSet<>();
		int[] distances = new int[V];
		int[] parent = new int[V];
		Arrays.fill(distances, Integer.MAX_VALUE);
		distances[0] = 0;
		while (mstSet.size() != V) {
			int vertex = findMinimum(distances, mstSet, V);
			mstSet.add(vertex);
			for (int v = 0; v < V; v++) {
				if (graph[vertex][v] > 0 && graph[vertex][v] < distances[v] &&
						!mstSet.contains(v)) {
					distances[v] = graph[vertex][v];
					parent[v] = vertex;
				}
			}
		}
		printMST(graph, V, parent);
	}

	private static int findMinimum(int[] distances, HashSet<Integer> mstSet, int V) {
		int small = Integer.MAX_VALUE, pos = 0;
		for (int i = 0; i < V; i++) {
			if (!mstSet.contains(i)) {
				if (distances[i] < small) {
					small = distances[i];
					pos = i;
				}
			}
		}
		return pos;
	}

	private static void printMST(int[][] graph, int V, int[] parent) {
		System.out.println("Edge \tWeight");
		for (int i = 1; i < V; i++)
			System.out.println(parent[i] + " - " + i + "\t" + graph[i][parent[i]]);
	}
}


 ===================================================== 


AlienDictionary.java


/*
Given a sorted dictionary (array of words) of an alien language, find order of characters in the language.

Examples =>
	Input:  words[] = {"baa", "abcd", "abca", "cab", "cad"}
	Output: Order of characters is 'b', 'd', 'a', 'c'
	Note that words are sorted and in the given language "baa"
	comes before "abcd", therefore 'b' is before 'a' in output.
	Similarly we can find other orders.

	Input:  words[] = {"caa", "aaa", "aab"}
	Output: Order of characters is 'c', 'a', 'b'

Approach =>
	1) Create a graph g with number of vertices equal to the size of alphabet in the given alien language.
		For example, if the alphabet size is 5, then there can be 5 characters in words.
		Initially there are no edges in graph.

	2) Do following for every pair of adjacent words in given sorted array.
	..a) Let the current pair of words be word1 and word2. One by one compare characters of
			both words and find the first mismatching characters.
	..b) Create an edge in g from mismatching character of word1 to that of word2.

	3) Print topological sorting of the above created graph.

https://www.geeksforgeeks.org/given-sorted-dictionary-find-precedence-characters/
 */
package DataStructures.Graphs.TopologicalSort;

import java.util.Stack;

@SuppressWarnings("Duplicates")
public class AlienDictionary {
	public static void main(String[] args) {
		String[] dictionary = {"baa", "abcd", "abca", "cab", "cad"};
		findOrder(dictionary);
	}

	private static void findOrder(String[] dictionary) {
		int V = Integer.MIN_VALUE;
		for (String s : dictionary) {
			V = Math.max(V, s.length());
		}
		int[][] graph = new int[V][V];
		String word1, word2;
		for (int i = 0; i < dictionary.length - 1; i++) {
			word1 = dictionary[i];
			word2 = dictionary[i + 1];
			for (int j = 0; j < Math.min(word1.length(), word2.length()); j++) {
				if (word1.charAt(j) != word2.charAt(j)) {
					graph[word1.charAt(j) - 'a'][word2.charAt(j) - 'a'] = 1;
					break;
				}
			}
		}
		boolean[] visited = new boolean[V];
		Stack<Integer> stack = new Stack<>();
		for (int v = 0; v < V; v++) {
			if (!visited[v]) {
				TopologicalSort(graph, V, v, visited, stack);
			}
		}

		while (!stack.isEmpty()) {
			System.out.print(((char) (stack.pop() + 97)) + ", ");
		}
	}

	private static void TopologicalSort(int[][] graph, int V, int node, boolean[] visited, Stack<Integer> stack) {
		visited[node] = true;
		for (int v = 0; v < V; v++) {
			if (graph[node][v] == 1 && !visited[v]) {
				TopologicalSort(graph, V, v, visited, stack);
			}
		}
		stack.push(node);
	}

}


 ===================================================== 


KahnAlgorithm.java


package DataStructures.Graphs.TopologicalSort;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

public class KahnAlgorithm {
	public static void main(String[] args) {

	}

	private static void kahnTopologicalSort(ArrayList<Integer>[] graph, int V) {
		int[] indegree = new int[V];
		for (int i = 0; i < V; i++) {
			for (int j : graph[i]) {
				indegree[j]++;
			}
		}

		Queue<Integer> queue = new LinkedList<>();
		for (int i = 0; i < V; i++) {
			if (indegree[i] == 0)
				queue.add(i);
		}

		int count = 0, u;
		ArrayList<Integer> top = new ArrayList<>();
		while (!queue.isEmpty()) {
			u = queue.poll();
			top.add(u);

			for (int j : graph[u]) {
				indegree[j]--;
				if (indegree[j] == 0)
					queue.add(j);
			}
			count++;
		}

		if (count != V) {
			System.out.println("Cycle Exists");
			return;
		}

		for (int i : top) {
			System.out.print(i + " ");
		}
	}
}


 ===================================================== 


topologicalSort.java


package DataStructures.Graphs.TopologicalSort;

import java.util.Arrays;
import java.util.Stack;

public class topologicalSort {
	private static int V;

	private static void TopologicalSortUtil(int[][] graph, int v, boolean[] visited, Stack<Integer> stack) {
		visited[v] = true;
		for (int x = 0; x < V; x++) {
			if (graph[v][x] == 1 && !visited[x]) {
				TopologicalSortUtil(graph, x, visited, stack);
			}
		}
		stack.push(v);
	}

	private static void TopologicalSortRunner(int[][] graph) {
		Stack<Integer> stack = new Stack<>();
		boolean[] visited = new boolean[V];
		Arrays.fill(visited, false);
		for (int v = 0; v < V; v++) {
			if (!visited[v]) {
				TopologicalSortUtil(graph, v, visited, stack);
			}
		}

		while (!stack.isEmpty()) {
			System.out.print(stack.pop() + " ");
		}
	}

	public static void main(String[] args) {
		int[][] demoGraph = {
				{0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0},
				{0, 0, 0, 1, 0, 0},
				{0, 1, 0, 0, 0, 0},
				{1, 1, 0, 0, 0, 0},
				{1, 0, 1, 0, 0, 0}
		};
		V = 6;
		TopologicalSortRunner(demoGraph);
	}
}


 ===================================================== 


bfs.java


package DataStructures.Graphs.Traversals;

import java.util.ArrayList;
import java.util.Arrays;

public class bfs {
	public static void main(String[] args) {
		int[][] graph = {
				{0, 1, 1, 0, 0, 0},
				{1, 0, 0, 1, 1, 0},
				{1, 0, 0, 0, 1, 0},
				{0, 1, 0, 0, 1, 1},
				{0, 1, 1, 1, 0, 1},
				{0, 0, 0, 1, 1, 0}
		};
		BFS(graph, 6, 1);
	}

	private static void BFS(int[][] graph, int V, int start) {
		boolean[] visited = new boolean[V];
		Arrays.fill(visited, false);
		ArrayList<Integer> queue = new ArrayList<>();
		start = start - 1;
		queue.add(start);
		visited[start] = true;
		while (!queue.isEmpty()) {
			start = queue.get(0);
			System.out.print((start + 1) + " ");
			queue.remove(0);

			for (int v = 0; v < V; v++) {
				if ((graph[start][v] == 1) && !visited[v]) {
					queue.add(v);
					visited[v] = true;
				}
			}
		}
	}
}


 ===================================================== 


BinaryPalindrome.java


/*
Given n and k, Construct a palindrome of size n using a binary number of size k repeating itself
to wrap into the palindrome.
The palindrome must always begin with 1 and contains maximum number of zeros.
https://www.geeksforgeeks.org/construct-binary-palindrome-by-repeated-appending-and-trimming/
 */

package DataStructures.Graphs.Traversals;

import java.util.ArrayList;

public class BinaryPalindrome {
	private static void DFS(int parent, int[] ans, ArrayList<ArrayList<Integer>> connectChars) {
		ans[parent] = 1; // Node marked
		for (int i = 0; i < connectChars.get(parent).size(); i++) {
			if (ans[connectChars.get(parent).get(i)] != 1) {
				DFS(connectChars.get(parent).get(i), ans, connectChars);
			}
		}
	}

	private static void generatePalindrome(int n, int k) {
		int[] ans = new int[n];
		int[] arr = new int[n];
		ArrayList<ArrayList<Integer>> connectChars = new ArrayList<>();
		for (int i = 0; i < k; i++) {
			connectChars.add(new ArrayList<>());
		}
		for (int i = 0; i < n; i++) {
			arr[i] = i % k;
		}
		for (int i = 0; i < n / 2; i++) {
			connectChars.get(arr[i]).add(arr[n - i - 1]);
			connectChars.get(arr[n - i - 1]).add(arr[i]);
		}
		DFS(0, ans, connectChars);
		for (int i = 0; i < n; i++) {
			System.out.print(ans[arr[i]]);
		}
	}

	public static void main(String[] args) {
		int n = 10, k = 4;
		generatePalindrome(n, k);
	}
}


 ===================================================== 


CircleOfStrings.java


/*
Circle of Strings

Given an array of strings A[], determine if the strings can be chained together to form a circle. A
string X can be chained together with another string Y if the last character of X is same as first
character of Y. If every string of the array can be chained, it will form a circle.

For eg for the array arr[] = {"for", "geek", "rig", "kaf"}
the answer will be Yes as the given strings can be chained as "for", "rig", "geek" and "kaf"

https://www.geeksforgeeks.org/find-array-strings-can-chained-form-circle-set-2/
 */

package DataStructures.Graphs.Traversals;

import Commons.GraphList;

import java.util.ArrayList;

public class CircleOfStrings {
	private static boolean checkForLoops(String[] arr) {
		int V = 26;
		int[] inDegree = new int[V];
		int[] outDegree = new int[V];
		boolean[] mark = new boolean[26];
		GraphList graphList = new GraphList(V, true, true);
		for (String s : arr) {
			int f = s.charAt(0) - 'a';
			int l = s.charAt(s.length() - 1) - 'a';
			mark[f] = mark[l] = true;
			outDegree[f]++;
			inDegree[l]++;
			graphList.addEdge(f, l);
		}
		for (int i = 0; i < V; i++) {
			if (inDegree[i] != outDegree[i]) {
				return false;
			}
		}
		ArrayList<Integer>[] graph = graphList.getGraph();
		return isConnected(graph, V, mark,
				(arr[0].charAt(0) - 'a'));
	}

	private static boolean isConnected(ArrayList<Integer>[] graph, int V, boolean[] marked, int node) {
		boolean[] visited = new boolean[V];
		DFS(graph, visited, node);
		for (int i = 0; i < V; i++) {
			if (marked[i] && !visited[i])
				return false;
		}
		return true;
	}

	private static void DFS(ArrayList<Integer>[] graph, boolean[] visited, int node) {
		visited[node] = true;
		for (int i : graph[node]) {
			if (!visited[i])
				DFS(graph, visited, i);
		}
	}

	public static void main(String[] args) {
//		String[] arr = {"ab", "bc", "cd", "de", "ed", "da"};
//		String[] arr = {"aaa", "bbb"};
		String[] arr = {"ijk", "kji", "abc", "cba"};
		System.out.println(checkForLoops(arr));
	}

}


 ===================================================== 


DetectCycleInGraph.java


package DataStructures.Graphs.Traversals;

import Commons.GraphMatrix;

public class DetectCycleInGraph {
	private static boolean cycleUtil(int[][] graph, int V, int node,
									 int parent, boolean[] visited) {
		visited[node] = true;
		for (int v = 0; v < V; v++) {
			if (graph[node][v] == 1) {
				if (!visited[v]) {
					if (cycleUtil(graph, V, v, node, visited)) {
						return true;
					}
				} else if (v != parent) {
					return true;
				}
			}
		}
		return false;
	}

	private static boolean isCyclic(int[][] graph, int V) {
		boolean[] visited = new boolean[V];
		for (int v = 0; v < V; v++) {
			if (!visited[v]) {
				if (cycleUtil(graph, V, v, -1, visited)) {
					return true;
				}
			}
		}
		return false;
	}

	public static void main(String[] args) {
		GraphMatrix g1 = new GraphMatrix(5, false, true);
		g1.addEdge(1, 0);
		g1.addEdge(0, 2);
		g1.addEdge(2, 1);
		g1.addEdge(0, 3);
		g1.addEdge(3, 4);

		GraphMatrix g2 = new GraphMatrix(3, false, true);
		g2.addEdge(0, 1);
		g2.addEdge(1, 2);

		System.out.println(isCyclic(g1.getGraph(), 5));
		System.out.println(isCyclic(g2.getGraph(), 3));
	}
}


 ===================================================== 


dfs.java


package DataStructures.Graphs.Traversals;

import java.util.Arrays;

public class dfs {
	private static void DFSUtil(int[][] graph, int v, int V, boolean[] visited) {
		visited[v] = true;
		System.out.print((v + 1) + " ");
		for (int x = 0; x < V; x++) {
			if (graph[v][x] == 1 && !visited[x]) {
				DFSUtil(graph, x, V, visited);
			}
		}
	}

	public static void main(String[] args) {
		int[][] graph = {
				{0, 1, 1, 0, 0, 0},
				{1, 0, 0, 1, 1, 0},
				{1, 0, 0, 0, 1, 0},
				{0, 1, 0, 0, 1, 1},
				{0, 1, 1, 1, 0, 1},
				{0, 0, 0, 1, 1, 0}
		};
		boolean[] visited = new boolean[6];
		Arrays.fill(visited, false);
		DFSUtil(graph, 0, 6, visited);
	}
}


 ===================================================== 


JumpingNumbers.java


package DataStructures.Graphs.Traversals;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;

public class JumpingNumbers {
	private final ArrayList<Integer> jumpers = new ArrayList<>();

	public static void main(String[] args) {
		new JumpingNumbers().printJumping(40);
	}

	private void printJumping(int limit) {
		jumpers.add(0);
		for (int i = 1; i <= 9 && i <= limit; i++) {
			BFS(limit, i);
		}
		Collections.sort(jumpers);
		for (int i : jumpers) {
			System.out.print(i + " ");
		}
	}

	private void BFS(int limit, int num) {
		Queue<Integer> queue = new LinkedList<>();
		queue.add(num);
		int last;
		while (!queue.isEmpty()) {
			num = queue.poll();
			if (num <= limit) {
				jumpers.add(num);
				last = num % 10;
				if (last == 0) {
					queue.add(num * 10 + (last + 1));
				} else if (last == 9) {
					queue.add(num * 10 + (last - 1));
				} else {
					queue.add(num * 10 + (last + 1));
					queue.add(num * 10 + (last - 1));
				}
			}
		}
	}
}


 ===================================================== 


LengthOfCable.java


/*
NOTE : This is the same for LONGEST PATH IN DIRECTED ACYCLIC GRAPH

Longest path between any pair of vertices
We are given a map of cities connected with each other via cable lines such that
there is no cycle between any two cities.
We need to find the maximum length of cable between any two cities for given city map.

Input : n = 6
        1 2 3  // Cable length from 1 to 2 (or 2 to 1) is 3
        2 3 4
        2 6 2
        6 4 6
        6 5 5
Output: maximum length of cable = 12

https://www.geeksforgeeks.org/longest-path-between-any-pair-of-vertices/
 */
package DataStructures.Graphs.Traversals;

import Commons.GraphMatrix;

import java.util.Arrays;
import java.util.Stack;

public class LengthOfCable {
	private static void TopologicalSort(int[][] graph, int V, int node, boolean[] visited, Stack<Integer> stack) {
		visited[node] = true;
		for (int v = 0; v < V; v++) {
			if (graph[node][v] == 1 && !visited[v]) {
				TopologicalSort(graph, V, v, visited, stack);
			}
		}
		stack.push(node);
	}

	private static int findLength(int[][] graph, int V, int[][] weight) {
		Stack<Integer> stack = new Stack<>();
		boolean[] visited = new boolean[V];
		for (int v = 0; v < V; v++) {
			TopologicalSort(graph, V, v, visited, stack);
		}
		int[] distances = new int[V];
		Arrays.fill(distances, Integer.MIN_VALUE);
		int node;
		while (!stack.isEmpty()) {
			node = stack.pop();
			for (int v = 0; v < V; v++) {
				if (graph[node][v] == 1) {
					if (distances[node] < (distances[v] + weight[node][v])) {
						distances[node] = distances[v] + weight[node][v];
					}
				}
			}
		}
		Arrays.sort(distances);
		return distances[V - 1] - Integer.MIN_VALUE + 1;
	}

	public static void main(String[] args) {
		int[][] input = {
				{1, 2, 3},
				{2, 3, 4},
				{2, 6, 2},
				{6, 4, 6},
				{6, 5, 5}
		};
		int V = 6;
		GraphMatrix graphMatrix = new GraphMatrix(V, true, false);
		int[][] weights = new int[V][V];
		for (int[] arr : input) {
			graphMatrix.addEdge(arr[0], arr[1]);
			weights[arr[0] - 1][arr[1] - 1] = arr[2];
		}
		System.out.println(findLength(graphMatrix.getGraph(), V, weights));
	}
}


 ===================================================== 


LoopInArray.java


/*
Check loop in array according to given constraints
Given an array arr[0..n-1] of positive and negative numbers we need to find if there is
a cycle in array with given rules of movements. If a number at an i index is positive,
then move arr[i]%n forward steps, i.e., next index to visit is (i + arr[i])%n.
Conversely, if its negative, move backward arr[i]%n steps i.e., next index to visit is (i  arr[i])%n.
Here n is size of array. If value of arr[i]%n is zero, then it means no move from index i.

https://www.geeksforgeeks.org/check-loop-array-according-given-constraints/
 */
package DataStructures.Graphs.Traversals;

public class LoopInArray {
	public static void main(String[] args) {
		int[] arr = {1, 1, 1, 1, 1};
		int n = arr.length;
		System.out.println(checkForLoops(arr, n));
	}

	private static boolean checkForLoops(int[] arr, int n) {
		boolean[] visited = new boolean[n];
		boolean[] recursive = new boolean[n];
		for (int i = 0; i < n; i++) {
			if (LoopRecursive(arr, n, i, visited, recursive)) {
				return true;
			}
		}
		return false;
	}

	private static boolean LoopRecursive(int[] arr, int n, int current,
										 boolean[] visited, boolean[] recursive) {
		visited[current] = true;
		recursive[current] = true;
		int next;
		if (arr[current] < 0) {
			next = ((current + arr[current]) % n);
		} else {
			next = ((current + arr[current] + n) % n);
		}
		if (next == current) {
			return false;
		}
		if (recursive[next]) {
			return true;
		}
		if (!visited[next]) {
			if (LoopRecursive(arr, n, next, visited, recursive)) {
				return true;
			}
		} else if (visited[next] && recursive[next]) {
			return true;
		}
		recursive[current] = false;
		return false;
	}
}


 ===================================================== 


MatrixProbability.java


package DataStructures.Graphs.Traversals;

public class MatrixProbability {
	private static double DFS(int m, int n, int x, int y, int steps) {
		if ((x < 0) || (x > m) || (y < 0) || (y > n)) {
			return 0.0;
		}
		if (steps == 0) {
			return 1.0;
		}
		double probability = 0.0;
		// top
		probability += (DFS(m, n, x - 1, y, steps - 1) * 0.25);
		// bottom
		probability += (DFS(m, n, x + 1, y, steps - 1) * 0.25);
		// left
		probability += (DFS(m, n, x, y - 1, steps - 1) * 0.25);
		// top
		probability += (DFS(m, n, x, y + 1, steps - 1) * 0.25);
		return probability;
	}

	public static void main(String[] args) {
		System.out.println(DFS(5, 5, 1, 1, 2));
	}
}


 ===================================================== 


MinimumSwaps.java


/*
Minimum Swaps to sort an array

Given an array of integers. Find the minimum number of swaps required to sort the array in non-decreasing order.

Input:
The first line of input contains an integer T denoting the no of test cases.
Then T test cases follow. Each test case contains an integer N denoting the no of element of the array A[ ].
In the next line are N space separated values of the array A[ ] .

Output:
For each test case in a new line output will be an integer denoting minimum umber of swaps that are
required to sort the array.
 */

package DataStructures.Graphs.Traversals;

import Commons.GraphList;

import java.util.ArrayList;
import java.util.Arrays;

public class MinimumSwaps {
	public static void main(String[] args) {
//		int[] arr = {1, 5, 4, 3, 2};
		int[] arr = {4, 2, 3, 1};
		System.out.println(minimumSwaps(arr, arr.length));
	}

	private static int minimumSwaps(int[] arr, int n) {
		int[] temp = arr.clone();
		Arrays.sort(temp);
		GraphList graphList = new GraphList(n, true, false);
		for (int i = 0; i < n; i++) {
			if (arr[i] != temp[i]) {
				graphList.addEdge(arr[i], temp[i]);
			}
		}
		boolean[] visited = new boolean[n];
		ArrayList<Integer>[] graph = graphList.getGraph();
		int ans = 0;
		for (int i = 0; i < n; i++) {
			if (visited[i] || temp[i] == arr[i]) {
				continue;
			}
			int cycle = 0;
			int j = i, v = 0;
			while (!visited[j]) {
				visited[j] = true;
				cycle++;
				if (v < graph[j].size()) {
					j = graph[j].get(v);
					v++;
				} else {
					break;
				}
			}
			if (cycle > 0) {
				ans += cycle - 1;
			}
		}
		return ans;
	}
}


 ===================================================== 


NodesAtKDistance.java


/*
Count nodes within K-distance from all nodes in a set
Given an undirected tree with some marked nodes and a positive number K.
We need to print the count of all such nodes which have distance from all marked nodes less than K
that means every node whose distance from all marked nodes is less than K, should be counted in the result.

https://www.geeksforgeeks.org/count-nodes-within-k-distance-from-all-nodes-in-a-set/
 */

package DataStructures.Graphs.Traversals;

import Commons.GraphMatrix;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

public class NodesAtKDistance {
	private static int[] dl, dr;

	public static void main(String[] args) {
		GraphMatrix graphMatrix = new GraphMatrix(10, false, true);
		int[][] edges =
				{
						{1, 0}, {0, 3}, {0, 8}, {2, 3},
						{3, 5}, {3, 6}, {3, 7}, {4, 5},
						{5, 9}
				};
		for (int[] temp : edges) {
			graphMatrix.addEdge(temp[0], temp[1]);
		}
		int[][] graph = graphMatrix.getGraph();
		int[] marked = {1, 2, 4};
		int K = 3;
		int V = 10;
		System.out.println(countNumberOfNodes(graph, V, marked, K));
	}

	private static int countNumberOfNodes(int[][] graph, int V, int[] nodeList, int K) {
		dl = new int[V];
		dr = new int[V];
		Arrays.fill(dl, -1);
		Arrays.fill(dr, -1);
		boolean[] marked = new boolean[V];
		for (int node : nodeList) {
			marked[node] = true;
		}
		int u = BFSWithDistance(graph, V, 0, true, marked);
		int v = BFSWithDistance(graph, V, u, true, marked);
		BFSWithDistance(graph, V, v, false, marked);
		int result = 0;
		for (int i = 0; i < V; i++) {
			if (dl[i] <= K && dr[i] <= K) {
				result++;
			}
		}
		return result;
	}

	private static int BFSWithDistance(int[][] graph, int V,
									   int node, boolean firstNode, boolean[] marked) {
		int lastMarked = 0;
		int[] distance = new int[V];
		Arrays.fill(distance, -1);
		Queue<Integer> queue = new LinkedList<>();
		queue.add(node);
		distance[node] = 0;
		while (!queue.isEmpty()) {
			node = queue.poll();
			if (marked[node]) {
				lastMarked = node;
			}
			for (int i = 0; i < V; i++) {
				if (graph[node][i] == 1 && distance[i] == -1) {
					distance[i] = distance[node] + 1;
					queue.add(i);
				}
			}
		}
		if (firstNode) {
			dl = distance.clone();
		} else {
			dr = distance.clone();
		}
		return lastMarked;
	}
}


 ===================================================== 


NumberOfNodesAtALevel.java


package DataStructures.Graphs.Traversals;

import java.util.LinkedList;
import java.util.Queue;

public class NumberOfNodesAtALevel {
	public static void main(String[] args) {
		int[][] tree = {
				{0, 1, 1, 0, 0, 0, 0},
				{0, 0, 0, 1, 1, 1, 0},
				{0, 0, 0, 0, 0, 0, 1},
				{0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0},
		};
		int V = 7, start = 0;
		System.out.println("At level 0 => " + findNumber(tree, V, 0, start));
		System.out.println("At level 1 => " + findNumber(tree, V, 1, start));
		System.out.println("At level 2 => " + findNumber(tree, V, 2, start));
	}

	private static int findNumber(int[][] tree, int V, int level, int start) {
		int[] nodeLevel = new int[V];
		boolean[] visited = new boolean[V];
		Queue<Integer> queue = new LinkedList<>();
		queue.add(start);
		nodeLevel[start] = 0;
		while (!queue.isEmpty()) {
			start = queue.poll();
			for (int i = 0; i < V; i++) {
				if (tree[start][i] == 1 && !visited[i]) {
					nodeLevel[i] = nodeLevel[start] + 1;
					visited[i] = true;
					queue.add(i);
				}
			}
		}
		int counter = 0;
		for (int i = 0; i < V; i++) {
			if (nodeLevel[i] == level) {
				counter++;
			}
		}
		return counter;
	}
}


 ===================================================== 


NumberOfPaths.java


/*
Given a graph, a source vertex and a destination vertex, find the number of paths
https://www.geeksforgeeks.org/count-possible-paths-two-vertices/
 */
package DataStructures.Graphs.Traversals;

public class NumberOfPaths {
	private static int counter = 0;

	private static void vertexIterator(int[][] graph, int current, int destination, int V) {
		if (current == destination) {
			counter++;
		} else {
			for (int v = 0; v < V; v++) {
				if (graph[current][v] == 1) {
					vertexIterator(graph, v, destination, V);
				}
			}
		}
	}

	private static void countPaths(int[][] graph, int V, int source, int destination) {
		vertexIterator(graph, source, destination, V);
		System.out.println("Number of paths => " + counter);
	}

	public static void main(String[] args) {
		int[][] graph = {
				{0, 1, 1, 0, 1},
				{0, 0, 0, 1, 1},
				{0, 0, 0, 0, 1},
				{0, 0, 1, 0, 0},
				{0, 0, 0, 0, 0}
		};
		int V = 5;
		int source = 0, destination = 4;
		countPaths(graph, V, source, destination);
	}
}


 ===================================================== 


SamePath.java


/*
Given a tree and 2 vertices, this program finds out if both the vertices lie on the same path of the tree
 */

package DataStructures.Graphs.Traversals;

public class SamePath {
	private final int[] inTime;
	private final int[] outTime;
	private final int V;
	private int timer;

	SamePath(int V) {
		this.V = V;
		inTime = new int[V];
		outTime = new int[V];
		timer = 0;
	}

	public static void main(String[] args) {
		SamePath samePath = new SamePath(7);
		int[][] graph = {
				{0, 1, 1, 1, 0, 0, 0},
				{0, 0, 0, 0, 1, 0, 0},
				{0, 0, 0, 0, 0, 1, 0},
				{0, 0, 0, 0, 1, 0, 0},
				{0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 0, 0, 0},
		};
		boolean[] visited = new boolean[7];
		samePath.DFSUtil(graph, 0, visited);
		System.out.println(samePath.query(1, 5));
		System.out.println(samePath.query(1, 6));
		System.out.println(samePath.query(2, 6));
	}

	private void DFSUtil(int[][] graph, int v, boolean[] visited) {
		++timer;
		visited[v] = true;
		inTime[v] = timer;
		for (int x = 0; x < V; x++) {
			if (graph[v][x] == 1 && !visited[x]) {
				DFSUtil(graph, x, visited);
			}
		}
		++timer;
		outTime[v] = timer;
	}

	private boolean query(int v, int u) {
		v--;
		u--;
		return (((inTime[v] < inTime[u]) && (outTime[v] > outTime[u]))
				|| ((inTime[u] < inTime[v]) && (outTime[u] > outTime[v])));
	}

}


 ===================================================== 


TrianglesInAGraph.java


/*
This program calculates the number of triangles in a graph
 */

package DataStructures.Graphs.Traversals;

public class TrianglesInAGraph {
	public static void main(String[] args) {
		int[][] graph = {{0, 1, 1, 0},
				{1, 0, 1, 1},
				{1, 1, 0, 1},
				{0, 1, 1, 0}
		};
		System.out.println(findTriangles(graph, 4));
	}

	private static int findTriangles(int[][] graph, int V) {
		int[][] aux2 = new int[V][V];
		int[][] aux3 = new int[V][V];
		multiply(graph, graph, aux2, V);
		multiply(graph, aux2, aux3, V);
		int trace = 0;
		for (int i = 0; i < V; i++) {
			trace += aux3[i][i];
		}
		return trace / 6;
	}

	private static void multiply(int[][] A, int[][] B, int[][] C, int V) {
		for (int i = 0; i < V; i++) {
			for (int j = 0; j < V; j++) {
				C[i][j] = 0;
				for (int k = 0; k < V; k++) {
					C[i][j] += A[i][k] * B[k][j];
				}
			}
		}
	}
}


 ===================================================== 


XIntoY.java


/*
Minimum number of operation required to convert number x into y
Given a initial number x and two operations which are given below:

Multiply number by 2.
Subtract 1 from the number.
The task is to find out minimum number of operation required to convert number x into y using
only above two operations. We can apply these operations any number of times.

Constraints:
1 <= x, y <= 10000

https://www.geeksforgeeks.org/minimum-number-operation-required-convert-number-x-y/
*/

package DataStructures.Graphs.Traversals;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

public class XIntoY {
	public static void main(String[] args) {
		int x = 2, y = 5;
		System.out.println(findNumber(x, y));
	}

	private static int findNumber(int x, int y) {
		ArrayList<Integer> visited = new ArrayList<>();
		Entry node = new Entry(x, 0);
		Queue<Entry> queue = new LinkedList<>();
		queue.add(node);
		while (!queue.isEmpty()) {
			node = queue.poll();
			if (node.element == y) {
				return node.steps;
			}
			if (!visited.contains(node.element) && x > 0) {
				visited.add(x);
				queue.add(new Entry(node.element * 2, node.steps + 1));
				queue.add(new Entry(node.element - 1, node.steps + 1));
			}
		}
		return -1;
	}

	static class Entry {
		int element, steps;

		public Entry(int element, int steps) {
			this.element = element;
			this.steps = steps;
		}
	}
}


 ===================================================== 


DeletionFromACLL.java


package DataStructures.LinkedList.CicularLinkedLists;

import Commons.ListNode;

@SuppressWarnings("Duplicates")
public class DeletionFromACLL {
	public static void main(String[] args) {
		ListNode list = new ListNode();
		list.push(1);
		list.push(2);
		list.push(3);
		list.push(4);
		list.push(5);
		list.push(6);
		list.convertCircular();
		list.printCircularList();
		delete(list.head, 3);
		list.printCircularList();
		delete(list.head, 1);
		list.printCircularList();
		delete(list.head, 6);
		list.printCircularList();

	}

	private static void delete(ListNode head, int element) {
		ListNode node = head, end, prev = head;
		while (node != null && node.next != head) {
			prev = node;
			node = node.next;
		}
		end = node;

		// Last Node
		if (end.data == element) {
			prev.next = head;
		}

		// First node
		else if (head.data == element) {
			end.next = head.next;
			head = head.next;
		}

		// Node in between
		else {
			node = prev = head;
			while (node.next != head) {
				if (node.data == element) {
					prev.next = node.next;
					break;
				}
				prev = node;
				node = node.next;
			}
		}
	}
}


 ===================================================== 


InsertIntoSortedCircularList.java


package DataStructures.LinkedList.CicularLinkedLists;

import Commons.ListNode;

@SuppressWarnings("Duplicates")
public class InsertIntoSortedCircularList {
	public static void main(String[] args) {
		ListNode list = new ListNode();
		list.push(6);
		list.push(5);
		list.push(4);
		list.push(2);
		list.convertCircular();
		list.printCircularList();
		list.head = insert(list.head, 3);
		list.printCircularList();
		list.head = insert(list.head, 7);
		list.printCircularList();
		list.head = insert(list.head, 1);
		list.printCircularList();
	}

	private static ListNode insert(ListNode head, int element) {
		ListNode end, node = head, prev = null;
		while (node.next != head) {
			node = node.next;
		}
		end = node;

		ListNode elementNode = new ListNode(element);

		if (element < head.data) { // element is smaller than head
			elementNode.next = head;
			end.next = head = elementNode;
		} else if (element > end.data) { // element is greater than the last node
			end.next = elementNode;
			elementNode.next = head;
		} else {
			node = head;
			while (node.next != head) {
				if (element <= node.data) {
					elementNode.next = node;
					prev.next = elementNode;
					break;
				}
				prev = node;
				node = node.next;
			}
		}

		return head;
	}
}


 ===================================================== 


Josephus.java


package DataStructures.LinkedList.CicularLinkedLists;

import Commons.ListNode;

public class Josephus {
	public static void main(String[] args) {
		josephus(5, 3);
		josephus(4, 2);
		josephus(10, 4);
		josephus(14, 2);
	}

	private static void josephus(int n, int m) {
		ListNode head = new ListNode(1), node, lastPtr = head;
		for (int i = 2; i <= n; i++) {
			ListNode element = new ListNode(i);
			lastPtr.next = element;
			lastPtr = element;
		}
		lastPtr.next = head;

		int count = 0, countM = 0;
		node = head;
		while (count < n) {
			countM++;
			if (countM == m) {
				node.next = node.next.next;
				countM = 0;
				count++;
			}
			node = node.next;
		}

		System.out.println("Person Alive => " + node.data);
	}
}


 ===================================================== 


SplitList.java


package DataStructures.LinkedList.CicularLinkedLists;

import Commons.ListNode;

@SuppressWarnings("Duplicates")
public class SplitList {
	public static void main(String[] args) {
		ListNode list = new ListNode();
		list.push(1);
		list.push(2);
		list.push(3);
		list.push(4);
		list.push(5);
		list.push(6);
		list.convertCircular();
		list.printCircularList();
		split(list.head);
	}

	private static void split(ListNode head) {
		ListNode slow = head, fast = head, head1, head2 = null;
		while (fast.next != head && fast.next.next != head) {
			slow = slow.next;
			fast = fast.next.next;
		}

		// For even number of nodes
		if (fast.next.next == head) {
			fast = fast.next;
		}

		head1 = head;
		if (head.next != head) {
			head2 = slow.next;
		}

		fast.next = slow.next; // Making 2nd half circular

		slow.next = head;


		new ListNode().printCircularList(head1);
		if (head2 != null) {
			new ListNode().printCircularList(head2);
		}
	}
}


 ===================================================== 


CheckLoops.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

import java.util.ArrayList;

@SuppressWarnings("Duplicates")
public class CheckLoops {
	public static void main(String[] args) {
		ListNode list = new ListNode();
		list.push(1);
		list.push(2);
		list.push(3);
		list.push(4);
		list.push(5);
		list.head.next.next.next.next.next = list.head.next.next;
		System.out.println(checkWithNodes(list.head));
		System.out.println(floydCycleFinding(list.head));

	}

	private static boolean checkWithNodes(ListNode head) {
		ArrayList<ListNode> list = new ArrayList<>();
		list.add(head);
		head = head.next;
		while (head != null) {
			if (list.contains(head)) {
				return true;
			} else {
				list.add(head);
			}
			head = head.next;
		}
		return false;
	}

	private static boolean floydCycleFinding(ListNode head) {
		ListNode slow = head, fast = head;
		while (slow != null && fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
			if (slow == fast) {
				return true;
			}
		}
		return false;
	}
}


 ===================================================== 


CountDuplicates.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

public class CountDuplicates {
	public static void main(String[] args) {
		ListNode llist = new ListNode();
		llist.push(1);
		llist.push(2);
		llist.push(1);
		llist.push(3);
		llist.push(1);
		llist.printList();
		System.out.println();
		System.out.println(countDuplicates(llist.head, 1));
	}

	private static int countDuplicates(ListNode head, int key) {
		int count = 0;
		while (head != null) {
			if (head.data == key) {
				count++;
			}
			head = head.next;
		}
		return count;
	}
}


 ===================================================== 


EvenAndOddNodes.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

public class EvenAndOddNodes {
	public static void main(String[] args) {
		ListNode llist = new ListNode();
		llist.push(11);
		llist.push(10);
		llist.push(9);
		llist.push(6);
		llist.push(4);
		llist.push(1);
		llist.push(0);
		System.out.println("Original Linked List");
		llist.printList();
		System.out.println();
		System.out.println("Modified Linked List");
		llist.printList(segregate(llist.head));
	}

	private static ListNode segregate(ListNode head) {
		ListNode oddStart = null, oddEnd = null;
		ListNode evenStart = null, evenEnd = null, temp;
		while (head != null) {
			temp = new ListNode(head.data);
			if (head.data % 2 == 0) {
				if (evenStart == null) {
					evenStart = temp;
				} else {
					evenEnd.next = temp;
				}
				evenEnd = temp;
			} else {
				if (oddStart == null) {
					oddStart = temp;
				} else {
					oddEnd.next = temp;
				}
				oddEnd = temp;
			}
			head = head.next;
		}
		if (evenStart == null) {
			return oddStart;
		} else {
			evenEnd.next = oddStart;
			return evenStart;
		}
	}
}


 ===================================================== 


IntersectionOfLists.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

public class IntersectionOfLists {
	public static void main(String[] args) {
		ListNode list1 = new ListNode();
		list1.push(6);
		list1.push(5);
		list1.push(4);
		list1.push(3);
		list1.push(2);
		list1.push(1);

		ListNode list2 = new ListNode();
		list2.push(8);
		list2.push(6);
		list2.push(4);
		list2.push(2);

		new ListNode().printList(intersect(list1.head, list2.head));
	}

	private static ListNode intersect(ListNode a, ListNode b) {
		ListNode start = null, end = null, temp;
		while (a != null && b != null) {
			if (a.data == b.data) {
				// First result node
				temp = new ListNode(a.data);
				if (start == null) {
					start = temp;
				} else {
					end.next = temp;
				}
				end = temp;
				a = a.next;
				b = b.next;
			} else if (a.data < b.data) {
				a = a.next;
			} else {
				b = b.next;
			}
		}
		return start;
	}
}


 ===================================================== 


MiddleOfTheList.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

@SuppressWarnings("Duplicates")
public class MiddleOfTheList {
	public static void main(String[] args) {
		ListNode list = new ListNode();
		list.push(1);
		list.push(2);
		list.push(3);
		list.push(4);
		list.push(5);
		list.push(6);
		ListNode head = list.head;
		System.out.println(findMiddle(head));
	}

	private static int findMiddle(ListNode head) {
		if (head == null) {
			return -1;
		}
		ListNode slow = head, fast = head;
		while (slow != null && fast != null && fast.next != null) {
			slow = slow.next;
			fast = fast.next.next;
		}
		assert slow != null;
		return slow.data;
	}
}


 ===================================================== 


PairwiseSwap.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

@SuppressWarnings("Duplicates")
public class PairwiseSwap {
	public static void main(String[] args) {
		ListNode list = new ListNode();
		list.push(5);
		list.push(4);
		list.push(3);
		list.push(2);
		list.push(1);

		System.out.println("List before swapping");
		list.printList();
		System.out.println();

		pairwiseSwap(list.head);

		System.out.println("\nList after swapping");
		list.printList();
	}

	private static void pairwiseSwap(ListNode head) {
		int k;
		while (head != null && head.next != null) {
			k = head.next.data;
			head.next.data = head.data;
			head.data = k;
			head = head.next.next;
		}
	}
}


 ===================================================== 


PalindromeList.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

import java.util.Stack;

@SuppressWarnings("Duplicates")
public class PalindromeList {
	public static void main(String[] args) {
		ListNode<String> list = new ListNode();
		list.push("R");
		list.push("A");
		list.push("D");
		list.push("A");
		list.push("R");

		ListNode<String> list1 = new ListNode();
		list1.push("R");
		list1.push("A");
		list1.push("D");
		list1.push("A");
		list1.push("R");
		list1.push("D");
		System.out.println(isPalindrome(list.head));
		System.out.println(isPalindrome(list1.head));
	}

	private static boolean isPalindrome(ListNode<String> head) {
		Stack<String> stack = new Stack<>();
		ListNode<String> temp = head;
		while (head != null) {
			stack.push(head.data);
			head = head.next;
		}

		head = temp;
		while (!stack.isEmpty()) {
			if (!stack.pop().equalsIgnoreCase(head.data)) {
				return false;
			}
			head = head.next;
		}
		return true;
	}
}


 ===================================================== 


RemoveDuplicatesSorted.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

public class RemoveDuplicatesSorted {
	public static void main(String[] args) {
		ListNode llist = new ListNode();
		llist.push(20);
		llist.push(13);
		llist.push(13);
		llist.push(11);
		llist.push(11);
		llist.push(11);

		System.out.println("List before removal of duplicates");
		llist.printList();

		removeDuplicates(llist.head);

		System.out.println("List after removal of elements");
		llist.printList();
	}

	private static void removeDuplicates(ListNode head) {
		while (head != null && head.next != null) {
			if (head.data == head.next.data) {
				head.next = head.next.next;
			} else {
				head = head.next;
			}
		}
	}
}


 ===================================================== 


RemoveDuplicatesUnsorted.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

import java.util.ArrayList;

public class RemoveDuplicatesUnsorted {
	public static void main(String[] args) {
		int[] arr = {10, 12, 11, 11, 12, 11, 10};
		ListNode llist = new ListNode();
		for (int i : arr) {
			llist.push(i);
		}
		System.out.println("List before removal of duplicates");
		llist.printList();
		removeDuplicates(llist.head);
	}

	private static void removeDuplicates(ListNode head) {
		ArrayList<Integer> list = new ArrayList<>();
		while (head != null) {
			if (!list.contains(head.data)) {
				list.add(head.data);
			}
			head = head.next;
		}

		System.out.println("\nList after removing duplicates");
		for (int i : list) {
			System.out.print(i + " ");
		}
	}
}


 ===================================================== 


ReverseALinkedList.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

@SuppressWarnings("Duplicates")
public class ReverseALinkedList {
	public static void main(String[] args) {
		ListNode list1 = new ListNode();
		list1.push(6);
		list1.push(5);
		list1.push(4);
		list1.push(3);
		list1.push(2);
		list1.push(1);

		list1.printList(reversal(list1.head));
	}

	private static ListNode reversal(ListNode head) {
		ListNode curr = head, prev = null, next;
		while (curr != null) {
			next = curr.next;
			curr.next = prev;
			prev = curr;
			curr = next;
		}
		head = prev;
		return head;
	}
}


 ===================================================== 


SwapNodesAndNotData.java


package DataStructures.LinkedList.SinglyLinkedLists;

import Commons.ListNode;

@SuppressWarnings("Duplicates")
public class SwapNodesAndNotData {
	public static void main(String[] args) {
		ListNode list = new ListNode();
		list.push(1);
		list.push(2);
		list.push(3);
		list.push(4);
		list.push(5);

		System.out.println("List before swapping");
		list.printList();

		int A = 4, B = 2;
		swapNodes(list.head, A, B);


		System.out.println("\nList after swapping");
		list.printList();

	}

	private static void swapNodes(ListNode head, int A, int B) {
		if (A == B) {
			return;
		}
		ListNode prevX, currX = head, prevY, currY = head;
		ListNode temp;
		prevX = prevY = null;
		while (currX != null && currX.data != A) {
			prevX = currX;
			currX = currX.next;
		}

		while (currY != null && currY.data != B) {
			prevY = currY;
			currY = currY.next;
		}

		// Case 1 : if either X or Y is not present
		if (currX == null || currY == null) {
			return;
		}

		// Case 2 : X is not the head
		if (prevX != null) {
			prevX.next = currY;
		} else {
			head = currY;
		}

		// Case 2.2 => Y is not the head
		if (prevY != null) {
			prevY.next = currX;
		} else {
			head = currX;
		}

		temp = currY.next;
		currY.next = currX.next;
		currX.next = temp;
	}
}


 ===================================================== 


FirstNegativeElementInWindow.java


package DataStructures.Queues;

import java.util.LinkedList;
import java.util.Queue;

public class FirstNegativeElementInWindow {
	public static void main(String[] args) {
		int[] arr = {12, -1, -7, 8, -15, 30, 16, 28};
		int k = 3;
		getNegatives(arr, arr.length, k);
	}

	private static void getNegatives(int[] arr, int n, int k) {
		Queue<Integer> queue = new LinkedList<>();
		int i;
		for (i = 0; i < k; i++) {
			if (arr[i] < 0) {
				queue.add(i);
			}
		}

		for (i = k; i < n; i++) {
			if (!queue.isEmpty()) {
				System.out.print(arr[queue.peek()] + " ");
			} else {
				System.out.print("0 ");
			}

			// removing elements out of this window
			while (!queue.isEmpty() && queue.peek() < (i - k + 1)) {
				queue.poll();
			}

			if (arr[i] < 0) {
				queue.add(i);
			}
		}

		if (!queue.isEmpty()) {
			System.out.print(arr[queue.peek()] + " ");
		} else {
			System.out.print("0 ");
		}
	}
}


 ===================================================== 


GenerateBinaryTillN.java


/*
1) Create an empty queue of strings
2) Enqueue the first binary number 1 to queue.
3) Now run a loop for generating and printing n binary numbers.
a) Dequeue and Print the front of queue.
b) Append 0 at the end of front item and enqueue it.
c) Append 1 at the end of front item and enqueue it.
 */

package DataStructures.Queues;

import java.util.LinkedList;
import java.util.Queue;

public class GenerateBinaryTillN {
	public static void main(String[] args) {
		printBinary(5);
		System.out.println();
		printBinary(9);
	}

	private static void printBinary(int n) {
		Queue<String> queue = new LinkedList<>();
		queue.add("1");
		for (int i = 1; i <= n; i++) {
			String top = queue.poll();
			System.out.print(top + " ");
			queue.add(top + "0");
			queue.add(top + "1");
		}
	}
}


 ===================================================== 


InterweaveQueue.java


/*
Following are the steps to solve the problem:
1.Push the first half elements of queue to stack.
2.Enqueue back the stack elements.
3.Dequeue the first half elements of the queue and enqueue them back.
4.Again push the first half elements into the stack.
5.Interleave the elements of queue and stack.
 */

package DataStructures.Queues;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

@SuppressWarnings("Duplicates")
public class InterweaveQueue {
	public static void main(String[] args) {
		Queue<Integer> q = new LinkedList<>();
		q.add(11);
		q.add(12);
		q.add(13);
		q.add(14);
		q.add(15);
		q.add(16);
		q.add(17);
		q.add(18);
		q.add(19);
		q.add(20);
		interweave(q, q.size());
	}

	private static void interweave(Queue<Integer> queue, int n) {
		if (n % 2 == 1) {
			return;
		}
		int half = n / 2, i;
		Stack<Integer> stack = new Stack<>();
		for (i = 0; i < half; i++) {
			stack.push(queue.poll());
		}
		while (!stack.isEmpty()) {
			queue.add(stack.pop());
		}
		for (i = 0; i < half; i++) {
			queue.add(queue.poll());
		}
		for (i = 0; i < half; i++) {
			stack.push(queue.poll());
		}
		while (!stack.isEmpty()) {
			queue.add(stack.pop());
			queue.add(queue.poll());
		}
		while (!queue.isEmpty()) {
			System.out.print(queue.poll() + " ");
		}
	}
}


 ===================================================== 


IterativeHeightOfBT.java


package DataStructures.Queues;

import Commons.Node;

import java.util.LinkedList;
import java.util.Queue;

@SuppressWarnings("Duplicates")
public class IterativeHeightOfBT {
	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.right = new Node(8);
		root.right.right.left = new Node(6);
		root.right.right.right = new Node(7);

                /*   Constructed Binary tree is:
                1
              /   \
            2      3
          /  \      \
         4    5      8
                   /   \
                  6     7    */

		System.out.println("Maximum height = " + returnHeight(root));
	}

	private static int returnHeight(Node root) {
		if (root == null) {
			return -1;
		}
		Queue<Node> queue = new LinkedList<>();
		Node currNode;
		queue.add(root);
		int nodeCount, height = 0;
		while (true) {
			nodeCount = queue.size();
			if (nodeCount == 0) {
				return height;
			}
			height++;
			while (nodeCount > 0 && !queue.isEmpty()) {
				currNode = queue.remove();
				if (currNode.left != null) {
					queue.add(currNode.left);
				}
				if (currNode.right != null) {
					queue.add(currNode.right);
				}
				nodeCount--;
			}
		}
	}
}


 ===================================================== 


MaxAndMinOfWindowK.java


/*
 a) In deque 'G', we maintain decreasing order of
    values from front to rear
 b) In deque 'S', we maintain increasing order of
    values from front to rear

1) First window size K
  1.1) For deque 'G', if current element is greater
       than rear end element, we remove rear while
       current is greater.
  1.2) For deque 'S', if current element is smaller
       than rear end element, we just pop it while
       current is smaller.
  1.3) insert current element in both deque 'G' 'S'

2) After step 1, front of 'G' contains maximum element
   of first window and front of 'S' contains minimum
   element of first window. Remaining elements of G
   and S may store maximum/minimum for subsequent
   windows.

3) After that we do traversal for rest array elements.
  3.1) Front element of deque 'G' is greatest and 'S'
       is smallest element of previous window
  3.2) Remove all elements which are out of this
       window [remove element at front of queue ]
  3.3) Repeat steps 1.1 , 1.2 ,1.3

4) Return sum of minimum and maximum element of all
   sub-array size k.
 */

package DataStructures.Queues;

import java.util.Deque;
import java.util.LinkedList;

public class MaxAndMinOfWindowK {
	public static void main(String[] args) {
		int[] arr = {2, 5, -1, 7, -3, -1, -2};
		int k = 3;
		System.out.println(returnSum(arr, arr.length, k));
	}

	private static int returnSum(int[] arr, int n, int k) {
		Deque<Integer> g = new LinkedList<>();
		Deque<Integer> s = new LinkedList<>();
		int i, sum = 0;
		for (i = 0; i < k; i++) {
			while (!g.isEmpty() && arr[i] >= arr[g.peekLast()]) {
				g.removeLast();
			}
			while (!s.isEmpty() && arr[i] <= arr[s.peekLast()]) {
				s.removeLast();
			}
			g.addLast(i);
			s.addLast(i);
		}

		for (i = k; i < n; i++) {
			if (!g.isEmpty() && !s.isEmpty()) {
				sum += arr[g.peekFirst()] + arr[s.peekFirst()];
			}
			while (!g.isEmpty() && g.peekFirst() <= (i - k)) {
				g.removeFirst();
			}
			while (!s.isEmpty() && s.peekFirst() <= (i - k)) {
				s.removeFirst();
			}
			g.addLast(i);
			s.addLast(i);
		}
		if (!g.isEmpty() && !s.isEmpty()) {
			sum += arr[g.peekFirst()] + arr[s.peekFirst()];
		}
		return sum;
	}
}


 ===================================================== 


MaxSumAtCurrentLevel.java


package DataStructures.Queues;

import Commons.Node;

import java.util.LinkedList;
import java.util.Queue;

@SuppressWarnings("Duplicates")
public class MaxSumAtCurrentLevel {
	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.right = new Node(8);
		root.right.right.left = new Node(6);
		root.right.right.right = new Node(7);

                /*   Constructed Binary tree is:
                1
              /   \
            2      3
          /  \      \
         4    5      8
                   /   \
                  6     7    */

		System.out.println("Maximum width = " + getMaxSum(root));
	}

	private static int getMaxSum(Node root) {
		if (root == null) {
			return -1;
		}
		Queue<Node> queue = new LinkedList<>();
		queue.add(root);
		int maxSum = Integer.MIN_VALUE, count, currSum;
		while (!queue.isEmpty()) {
			count = queue.size(); // level width of next level
			currSum = 0;
			while (count > 0) {
				root = queue.poll();
				if (root != null) {
					currSum += root.data;
					if (root.left != null) {
						queue.add(root.left);
					}
					if (root.right != null) {
						queue.add(root.right);
					}
				}
				count--;
			}
			maxSum = Math.max(maxSum, currSum);
		}
		return maxSum;
	}
}


 ===================================================== 


MaxWidthOfBT.java


package DataStructures.Queues;

import Commons.Node;

import java.util.LinkedList;
import java.util.Queue;

@SuppressWarnings("Duplicates")
public class MaxWidthOfBT {
	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.right = new Node(8);
		root.right.right.left = new Node(6);
		root.right.right.right = new Node(7);

                /*   Constructed Binary tree is:
                1
              /   \
            2      3
          /  \      \
         4    5      8
                   /   \
                  6     7    */

		System.out.println("Maximum width = " + getMaxWidth(root));
	}

	private static int getMaxWidth(Node root) {
		if (root == null) {
			return -1;
		}
		Queue<Node> queue = new LinkedList<>();
		queue.add(root);
		int maxWidth = 1, count;
		while (!queue.isEmpty()) {
			count = queue.size(); // level width of next level
			maxWidth = Math.max(maxWidth, count);
			while (count > 0) {
				root = queue.poll();
				if (root != null && root.left != null) {
					queue.add(root.left);
				}
				if (root != null && root.right != null) {
					queue.add(root.right);
				}
				count--;
			}
		}
		return maxWidth;
	}
}


 ===================================================== 


MinTimeToRotOranges.java


package DataStructures.Queues;

import java.util.LinkedList;
import java.util.Queue;

public class MinTimeToRotOranges {
	private static final int[] rowMod = {1, 0, -1, 0}; // Up - Left - Down - Right
	private static final int[] colMod = {0, -1, 0, 1}; // Up - Left - Down - Right
	private static int R, C;

	public static void main(String[] args) {
		int[][] arr = {
				{2, 1, 0, 2, 1},
				{1, 0, 1, 2, 1},
				{1, 0, 0, 2, 1}
		};
		System.out.println(rotOranges(arr, arr.length, arr[0].length));
	}

	private static int rotOranges(int[][] mat, int r, int c) {
		R = r;
		C = c;
		int ans = 0, currX, currY;
		Queue<Element> queue = new LinkedList<>();
		for (int i = 0; i < r; i++) {
			for (int j = 0; j < C; j++) {
				if (mat[i][j] == 2) {
					queue.add(new Element(i, j));
				}
			}
		}
		queue.add(new Element(-1, -1));
		boolean flag;
		while (!queue.isEmpty()) {
			flag = false;
			while (!queue.isEmpty() && !isDelim(queue.peek().x, queue.peek().y)) {
				for (int i = 0; i < 4; i++) {
					assert queue.peek() != null;
					currX = queue.peek().x + rowMod[i];
					currY = queue.peek().y + colMod[i];
					if (isValid(currX, currY) && mat[currX][currY] == 1) {
						if (!flag) {
							ans++;
							flag = true;
						}
						mat[currX][currY] = 2; // rot the cell
						queue.add(new Element(currX, currY)); // add the newly rotted orange
					}
				}
				queue.remove();
			}
			queue.remove();
			if (!queue.isEmpty()) {
				queue.add(new Element(-1, -1));
			}
		}
		return checkAll(mat) ? -1 : ans;
	}

	private static boolean isDelim(int x, int y) {
		return x == -1 && y == -1;
	}

	private static boolean isValid(int x, int y) {
		return ((x >= 0) && (y >= 0) && (x < R) && (y < C));
	}

	private static boolean checkAll(int[][] mat) {
		for (int i = 0; i < R; i++) {
			for (int j = 0; j < C; j++) {
				if (mat[i][j] == 1) {
					return true;
				}
			}
		}
		return false;
	}

	static class Element {
		int x, y;

		public Element(int x, int y) {
			this.x = x;
			this.y = y;
		}
	}
}


 ===================================================== 


PetrolPumpTour.java


package DataStructures.Queues;

public class PetrolPumpTour {
	public static void main(String[] args) {
//		int[][] arr = {{4, 6}, {6, 5}, {7, 3}, {4, 5}};
//		int[][] arr = {{6, 4}, {3, 6}, {7, 3}};
		int[][] arr = {{3, 3}, {3, 4}, {4, 4}};
		System.out.println(getTour(arr, arr.length));
	}

	private static int getTour(int[][] arr, int n) {
		int start = 0, pos;
		int petrol = 0, distance;
		while (start < n) {
			petrol = arr[start][0];
			distance = arr[start][1];
			pos = start;
			while (petrol >= distance) {
				pos = (pos + 1) % n;
				petrol = petrol - distance;
				petrol += arr[pos][0];
				distance = arr[pos][1];
				if (pos == start) {
					return pos;
				}
			}
			start = (start + 1) % n;
			if (start == 0) {
				return -1;
			}
		}
		return -1;
	}
}


 ===================================================== 


ReverseFirstKElements.java


package DataStructures.Queues;

import java.util.Queue;
import java.util.Stack;

@SuppressWarnings("Duplicates")
public class ReverseFirstKElements {
	public static void main(String[] args) {
		Queue<Integer> q = new java.util.LinkedList<>();
		q.add(11);
		q.add(12);
		q.add(13);
		q.add(14);
		q.add(15);
		q.add(16);
		q.add(17);
		q.add(18);
		q.add(19);
		q.add(20);
		int k = 3;
		reverseK(q, q.size(), k);
	}

	private static void reverseK(Queue<Integer> queue, int size, int k) {
		Stack<Integer> stack = new Stack<>();
		int i;
		for (i = 0; i < k; i++) {
			stack.push(queue.poll());
		}
		while (!stack.isEmpty()) {
			queue.add(stack.pop());
		}
		for (i = 0; i < size - k; i++) {
			queue.add(queue.poll());
		}
		while (!queue.isEmpty()) {
			System.out.print(queue.poll() + " ");
		}
	}
}


 ===================================================== 


SortQueueWithoutExtraSpace.java


package DataStructures.Queues;

import java.util.LinkedList;
import java.util.Queue;

public class SortQueueWithoutExtraSpace {

	public static void main(String[] args) {
		Queue<Integer> list = new LinkedList<>();
		list.add(4);
		list.add(3);
		list.add(2);
		list.add(1);

		//Sort Queue
		sortQueue(list);

		//print sorted Queue
		while (!list.isEmpty()) {
			System.out.print(list.poll() + " ");
		}
	}

	private static void sortQueue(Queue<Integer> queue) {
		for (int i = 1; i <= queue.size(); i++) {
			int minIndex = getMinIndex(queue, (queue.size() - i));
			insertElementToRear(queue, minIndex);
		}
	}

	private static int getMinIndex(Queue<Integer> queue, int sortIndex) {
		int minIndex = -1, minValue = Integer.MAX_VALUE, temp;
		for (int i = 0; i < queue.size(); i++) {
			temp = queue.poll();
			if (temp <= minValue && i <= sortIndex) {
				minValue = temp;
				minIndex = i;
			}
			queue.add(temp);
		}
		return minIndex;
	}

	private static void insertElementToRear(Queue<Integer> queue, int minIndex) {
		int minValue = 0, current;
		for (int i = 0; i < queue.size(); i++) {
			current = queue.poll();
			if (i != minIndex) {
				queue.add(current);
			} else {
				minValue = current;
			}
		}
		queue.add(minValue);
	}
}


 ===================================================== 


TaskScheduler.java


package DataStructures.Queues;

import java.util.Arrays;

public class TaskScheduler {
	public static void main(String[] args) {
		char[] tasks = {'A', 'A', 'A', 'A', 'A', 'A', 'B', 'C', 'D', 'E', 'F', 'G'};
//		char[] tasks = {'A', 'A', 'B', 'B', 'B', 'A'};
		int n = 2;
		System.out.println(getTime(tasks, n));
	}

	private static int getTime(char[] tasks, int n) {
		if (n == 0) {
			return tasks.length;
		}
		int[] count = new int[26];
		for (char c : tasks) {
			count[c - 'A']++;
		}
		int intervals = 0, i, index;
		Arrays.sort(count);
		while (count[25] > 0) {
			for (i = 0; i <= n; i++) {
				intervals++;
				if (i > 25) {
					continue;
				}
				index = 25 - i;
				if (count[index] > 0) {
					count[index]--;
				}
				if (count[index] == 0 && count[25] == 0) {
					break;
				}
			}
			Arrays.sort(count);
		}
		return intervals;
	}
}


 ===================================================== 


AncestorsOfABinaryTree.java


package DataStructures.Stacks;

import Commons.Node;

import java.util.Stack;

public class AncestorsOfABinaryTree {
	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(4);
		root.left.right = new Node(5);
		root.right.left = new Node(6);
		root.right.right = new Node(7);
		root.left.left.left = new Node(8);
		root.left.right.right = new Node(9);
		root.right.right.left = new Node(10);
		int key = 5;
		printAncestors(root, key);
	}

	private static void printAncestors(Node root, int key) {
		if (root == null) {
			return;
		}

		Stack<Node> stack = new Stack<>();
		while (true) {

			// Traverse the left side. While traversing, push the nodes into
			// the stack so that their right subtrees can be traversed later
			while (root != null && root.data != key) {
				stack.push(root);
				root = root.left;
			}

			if (root != null && root.data == key) {
				break;
			}

			if (stack.peek().right == null) {
				// remove the node and go up
				root = stack.pop();

				// If the popped node is right child of top, then remove the top
				// as well. Left child of the top must have processed before.
				while (!stack.isEmpty() && stack.peek().right == root) {
					root = stack.pop();
				}
			}

			root = stack.isEmpty() ? null : stack.peek().right;
		}

		while (!stack.isEmpty()) {
			System.out.print(stack.pop().data + " ");
		}
	}
}


 ===================================================== 


ArrayPermutations.java


package DataStructures.Stacks;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

public class ArrayPermutations {
	public static void main(String[] args) {
		int[] in = {1, 2, 3},
				out = {2, 1, 3};
		System.out.println(isPermuted(in, out, in.length));
	}

	private static boolean isPermuted(int[] in, int[] out, int n) {
		Queue<Integer> input = new LinkedList<>(), output = new LinkedList<>();
		for (int i : in) {
			input.add(i);
		}
		for (int i : out) {
			output.add(i);
		}

		Stack<Integer> stack = new Stack<>();
		int element;
		while (!input.isEmpty()) {
			element = input.poll();
			if (element == output.peek()) {
				output.poll();
				while (!stack.isEmpty()) {
					if (stack.peek() == output.peek()) {
						stack.pop();
						output.poll();
					} else {
						break;
					}
				}
			} else {
				stack.push(element);
			}
		}
		return stack.isEmpty() && input.isEmpty();
	}
}


 ===================================================== 


balancingBrackets.java


package DataStructures.Stacks;

import java.util.Stack;

public class balancingBrackets {
	public static void main(String[] args) {
		System.out.println(isBalanced("{[()]}"));
	}

	private static String isBalanced(String s) {
		Stack<Character> stack = new Stack<>();
		char ch;
		for (int i = 0; i < s.length(); i++) {
			ch = s.charAt(i);
			if (ch == '(' || ch == '{' || ch == '[') {
				stack.push(ch);
			}
			if ((ch == ')' && stack.peek() == '(') ||
					(ch == '}' && stack.peek() == '{') ||
					(ch == ']' && stack.peek() == '[')) {
				stack.pop();
			} else {
				return "NO";
			}
		}
		if (stack.size() != 0) {
			return "NO";
		} else {
			return "YES";
		}
	}
}


 ===================================================== 


DepthOfParenthesis.java


package DataStructures.Stacks;

public class DepthOfParenthesis {
	public static void main(String[] args) {
		String x = "(((X))(((Y))))";
		System.out.println(getDepth(x));
	}

	private static int getDepth(String x) {
		int curr = 0, max = 0;
		for (int i = 0; i < x.length(); i++) {
			if (x.charAt(i) == '(') {
				curr++;
			}

			max = Math.max(curr, max);

			if (x.charAt(i) == ')') {
				if (curr > 0)
					curr--;
				else
					return -1;
			}
		}
		if (curr != 0) {
			return -1;
		}

		return max;
	}
}


 ===================================================== 


FindCelebrity.java


package DataStructures.Stacks;

import java.util.Stack;

public class FindCelebrity {
	public static void main(String[] args) {
		int[][] mat = {
				{0, 0, 1, 0},
				{0, 0, 1, 0},
				{0, 0, 0, 0},
				{0, 0, 1, 0}
		};
		System.out.println(findCeleb(mat, mat.length));
	}

	private static int findCeleb(int[][] mat, int n) {
		Stack<Integer> stack = new Stack<>();
		int a, b, i;
		for (i = 0; i < n; i++) {
			stack.push(i);
		}

		while (stack.size() > 1) {
			a = stack.pop();
			b = stack.pop();
			if (mat[a][b] == 1) {
				stack.push(b);
			} else {
				stack.push(a);
			}
		}

		int c = stack.pop();

		for (i = 0; i < n; i++) {
			if (i != c && (mat[c][i] == 1 || mat[i][c] != 1)) {
				return -1;
			}
		}

		return c + 1;
	}
}


 ===================================================== 


FindClosingBracket.java


package DataStructures.Stacks;

import java.util.Stack;

public class FindClosingBracket {
	public static void main(String[] args) {
		String x = "[ABC[23]][89]";
		int index = 0;
		System.out.println(findClosingBracket(x, index));
	}

	private static int findClosingBracket(String x, int index) {
		if (x.charAt(index) != '[') {
			return -1;
		}

		Stack<Character> stack = new Stack<>();
		char ch;
		for (int i = index; i < x.length(); i++) {
			ch = x.charAt(i);
			if (ch == '[') {
				stack.push(ch);
			} else if (ch == ']') {
				stack.pop();
				if (stack.isEmpty()) {
					return i;
				}
			}
		}
		return -1;
	}
}


 ===================================================== 


GameOfTwoStacks.java


package DataStructures.Stacks;

@SuppressWarnings("Duplicates")
public class GameOfTwoStacks {
	public static void main(String[] args) {
		int[] a = {4, 2, 4, 6, 1};
		int[] b = {2, 1, 8, 5};
		int x = 10;
		System.out.println(twoStacks(x, a, b));
	}

	static int twoStacks(int x, int[] a, int[] b) {
		int ai = 0, bi = 0;
		int sum = 0, count = 0;
		while (sum <= x) {
			if (a[ai] <= (x - sum) && b[bi] <= (x - sum)) {
				if (a[ai] < b[bi]) {
					if (a[ai] <= (x - sum)) {
						sum += a[ai];
						ai++;
						count++;
					} else if (b[bi] <= (x - sum)) {
						sum += b[bi];
						bi++;
						count++;
					} else {
						break;
					}
				} else {
					if (b[bi] <= (x - sum)) {
						sum += b[bi];
						bi++;
						count++;
					} else if (a[ai] <= (x - sum)) {
						sum += a[ai];
						ai++;
						count++;
					} else {
						break;
					}
				}
			} else {
				break;
			}
		}
		return count;
	}
}


 ===================================================== 


GetMinInO1.java


package DataStructures.Stacks;

import java.util.Stack;

public class GetMinInO1 {
	private static Stack<Integer> stack;
	private static int minElement;

	public static void main(String[] args) {
		stack = new Stack<>();
		minElement = Integer.MAX_VALUE;
		push(3);
		push(5);
		getMin();
		push(2);
		push(1);
		getMin();
		pop();
		getMin();
	}

	private static void push(int element) {
		if (element < minElement) {
			stack.push(2 * element - minElement);
			minElement = element;
		} else {
			stack.push(element);
		}
	}

	private static int pop() {
		int y = stack.pop();
		if (y < minElement) {
			minElement = 2 * minElement - y;
		}
		return y;
	}

	private static int getMin() {
		return minElement;
	}
}


 ===================================================== 


LargestRectangleInHistogram.java


package DataStructures.Stacks;

import java.util.Stack;

public class LargestRectangleInHistogram {
	public static void main(String[] args) {
		int[] hist = {6, 2, 5, 4, 5, 1, 6};
		System.out.println("Maximum area is " + getMaxArea(hist, hist.length));
	}

	private static int getMaxArea(int[] hist, int n) {
		Stack<Integer> stack = new Stack<>();
		int maxArea = 0, currArea, top, i = 0;
		while (i < n) {
			if (stack.isEmpty() || hist[i] >= hist[stack.peek()]) {
				stack.push(i);
				i++;
			} else {
				top = stack.pop();
				currArea = hist[top] * (stack.isEmpty() ? i : i - stack.peek() - 1);
				maxArea = Math.max(maxArea, currArea);
			}
		}

		while (!stack.isEmpty()) {
			top = stack.pop();
			currArea = hist[top] * (stack.isEmpty() ? i : i - stack.peek() - 1);
			maxArea = Math.max(maxArea, currArea);
		}
		return maxArea;
	}
}


 ===================================================== 


MaxAndMinOfWindowSize.java


package DataStructures.Stacks;

import Commons.ArrayPrinter;

import java.util.Arrays;
import java.util.Stack;

public class MaxAndMinOfWindowSize {
	public static void main(String[] args) {
		int[] arr = {10, 20, 30, 50, 10, 70, 30};
		int[] ans = findMaxOfMin(arr, arr.length);
		new ArrayPrinter().printArray(ans, 1, arr.length + 1);
	}

	private static int[] findMaxOfMin(int[] arr, int n) {
		int[] left = new int[n + 1];
		int[] right = new int[n + 1];
		for (int i = 0; i < n; i++) {
			left[i] = -1;
			right[i] = n;
		}
		Stack<Integer> stack = new Stack<>();

		// Left
		for (int i = 0; i < n; i++) {
			while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
				stack.pop();
			}
			if (!stack.isEmpty()) {
				left[i] = stack.peek();
			}
			stack.push(i);
		}

		// Right
		stack.clear();
		for (int i = n - 1; i >= 0; i--) {
			while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
				stack.pop();
			}
			if (!stack.isEmpty()) {
				right[i] = stack.peek();
			}
			stack.push(i);
		}

		int[] ans = new int[n + 1];
		Arrays.fill(ans, 0);
		for (int i = 0; i < n; i++) {
			int len = right[i] - left[i] - 1;
			ans[len] = Math.max(ans[len], arr[i]);
		}
		for (int i = n - 1; i >= 1; i--) {
			ans[i] = Math.max(ans[i], ans[i + 1]);
		}

		return ans;
	}
}


 ===================================================== 


MinNumberOfBracketReversals.java


package DataStructures.Stacks;

import java.util.Stack;

public class MinNumberOfBracketReversals {
	public static void main(String[] args) {
		String[] arr = {"}{", "{{{", "{{{{", "{{{{}}", "}{{}}{{{"};
		for (String x : arr) {
			System.out.println(numberReversals(x));
		}
	}

	private static int numberReversals(String x) {
		if (x.length() % 2 == 1) {
			return -1;
		}

		Stack<Character> stack = new Stack<>();
		for (int i = 0; i < x.length(); i++) {
			if (x.charAt(i) == '}' && !stack.isEmpty()) {
				if (stack.peek() == '{') {
					stack.pop();
				} else {
					stack.push(x.charAt(i));
				}
			} else {
				stack.push(x.charAt(i));
			}
		}

		int len = stack.size(), n = 0;
		while (!stack.isEmpty()) {
			if (stack.peek() == '{') {
				n++;
			}
			stack.pop();
		}
		return len / 2 + n % 2;
	}
}


 ===================================================== 


NGEOnRight.java


package DataStructures.Stacks;

import java.util.Stack;

public class NGEOnRight {
	public static void main(String[] args) {
		int[] values = {3, 4, 2, 7, 5, 8, 10, 6};
		int[] queries = {3, 6, 1};
		findNGE(values, queries, values.length);
	}

	private static void findNGE(int[] values, int[] queries, int n) {
		int[] dp = new int[n];
		dp[n - 1] = 0;
		int[] next = fillNext(values, n);
		for (int i = n - 2; i >= 0; i--) {
			if (next[i] == -1) {
				dp[i] = 0;
			} else {
				dp[i] = dp[next[i]] + 1;
			}
		}

		for (int j : queries) {
			System.out.println(dp[j]);
		}
	}

	private static int[] fillNext(int[] values, int n) {
		int[] next = new int[n];
		Stack<Integer> stack = new Stack<>();
		stack.push(0);
		int cur;
		for (int i = 1; i < n; i++) {
			while (!stack.isEmpty()) {
				cur = stack.peek();
				if (values[cur] < values[i]) {
					next[cur] = i;
					stack.pop();
				} else {
					break;
				}
			}
			stack.push(i);
		}

		while (!stack.isEmpty()) {
			cur = stack.peek();
			next[cur] = -1;
			stack.pop();
		}

		return next;
	}
}


 ===================================================== 


PermutationsGEToN.java


package DataStructures.Stacks;

import java.util.Stack;

public class PermutationsGEToN {
	public static void main(String[] args) {
		System.out.println(getPerms(15));
		System.out.println(getPerms(100));
		System.out.println(getPerms(5));
	}

	private static int getPerms(int n) {
		if (n <= 9) {
			return n;
		}
		int result = 0, top, x;
		Stack<Integer> stack = new Stack<>();
		for (int i = 1; i <= 9; i++) {
			if (i <= n) {
				stack.push(i);
				result++;
			}

			while (!stack.isEmpty()) {
				top = stack.pop();
				for (int j = top % 10; j <= 9; j++) {
					x = top * 10 + j;
					if (x <= n) {
						stack.push(x);
						result++;
					}
				}
			}
		}
		return result;
	}
}


 ===================================================== 


RedundantBrackets.java


package DataStructures.Stacks;

import java.util.Stack;

public class RedundantBrackets {
	public static void main(String[] args) {
		String x = "((a+b)+c+d)";
		System.out.println(redundantBrackets(x));
	}

	private static boolean redundantBrackets(String x) {
		Stack<Character> stack = new Stack<>();
		int counter;
		char ch, top;
		for (int i = 0; i < x.length(); i++) {
			ch = x.charAt(i);
			if (ch == ')') {
				top = stack.pop();
				counter = 0;
				while (top != '(') {
					counter++;
					top = stack.pop();
				}
				if (counter < 1) {
					return true;
				}
			} else {
				stack.push(ch);
			}
		}
		return false;
	}
}


 ===================================================== 


ReverseStackUsingRecursion.java


package DataStructures.Stacks;

import java.util.Stack;

public class ReverseStackUsingRecursion {
	private static Stack<Integer> stack;

	public static void main(String[] args) {
		stack = new Stack<>();
		for (int i = 4; i > 0; i++) {
			stack.push(i);
		}
		System.out.println(stack);
		recursion(stack.peek());
		System.out.println(stack);
	}

	private static void recursion(int x) {
		if (stack.isEmpty()) {
			stack.push(x);
		} else {
			int a = stack.pop();
			recursion(a);
			stack.push(a);
		}
	}
}


 ===================================================== 


SpiralLevelOrder.java


package DataStructures.Stacks;

import Commons.Node;

import java.util.Stack;

@SuppressWarnings("Duplicates")
public class SpiralLevelOrder {
	public static void main(String[] args) {
		Node root = new Node(1);
		root.left = new Node(2);
		root.right = new Node(3);
		root.left.left = new Node(7);
		root.left.right = new Node(6);
		root.right.left = new Node(5);
		root.right.right = new Node(4);
		printSpiral(root);
	}

	private static void printSpiral(Node root) {
		Stack<Node> s1 = new Stack<>();
		Stack<Node> s2 = new Stack<>();
		s1.push(root);
		while (!s1.isEmpty() || !s2.isEmpty()) {
			while (!s1.isEmpty()) {
				root = s1.pop();
				System.out.print(root.data + " ");
				if (root.right != null) {
					s2.push(root.right);
				}
				if (root.left != null) {
					s2.push(root.left);
				}
			}

			while (!s2.isEmpty()) {
				root = s2.pop();
				System.out.print(root.data + " ");
				if (root.right != null) {
					s1.push(root.right);
				}
				if (root.left != null) {
					s1.push(root.left);
				}
			}
		}
	}
}


 ===================================================== 


StockSpan.java


package DataStructures.Stacks;

import java.util.Stack;

public class StockSpan {
	public static void main(String[] args) {
		int[] price = {10, 4, 5, 90, 120, 80};
		int[] span = getSpan(price, price.length);
		System.out.println(span[3 - 1]);
		System.out.println(span[4 - 1]);
		System.out.println(span[5 - 1]);
	}

	private static int[] getSpan(int[] price, int n) {
		int[] span = new int[n];
		span[0] = 1;
		Stack<Integer> stack = new Stack<>();
		stack.push(0);
		for (int i = 1; i < n; i++) {
			while (!stack.isEmpty() && price[stack.peek()] <= price[i]) {
				stack.pop();
			}

			span[i] = stack.isEmpty() ? i + 1 : i - stack.peek();

			stack.push(i);
		}
		return span;
	}
}


 ===================================================== 


Atoi.java


package DataStructures.Strings;

public class Atoi {
	private static int atoi(String s) {
		char ch;
		boolean positive = true;
		String res = "";
		for (int i = 0; i < s.length(); i++) {
			ch = s.charAt(i);
			// blank space
			if (ch == ' ') {
				continue;
			}

			// plus|minus
			if (ch == '+') {
				positive = true;
				continue;
			} else if (ch == '-') {
				positive = false;
				continue;
			}

			// if reached here.. we will have only numbers and words
			if (ch >= '0' && ch <= '9') {
				res = res + ch;
			} else {
				break;
			}
		}

		if (res.length() == 0) {
			return 0;
		}
		try {
			if (!positive) {
				res = "-" + res;
			}
			return Integer.parseInt(res);
		} catch (NumberFormatException e) {
			return Integer.MIN_VALUE;
		}
	}

	public static void main(String[] args) {
		String x = "42";
		System.out.println(atoi(x));
	}
}


 ===================================================== 


CanonicalPath.java


package DataStructures.Strings;

import java.util.Stack;

public class CanonicalPath {
	public static void main(String[] args) {
		String path = "/a//b////c/d//././/..";
//		String path = "/a/../../b/../c//.//";
		System.out.println(getPath(path));
	}

	private static String getPath(String path) {
		path = path + "/";
		Stack<String> stack = new Stack<>();
		String fr = "";
		char ch;
		for (int i = 0; i < path.length(); i++) {
			ch = path.charAt(i);
			if (ch == '/' && fr.length() > 0) {
				// Case 1 : ./
				if (fr.equals(".")) {
					fr = "";
					continue;
				}
				if (fr.equals("..")) {
					if (!stack.isEmpty())
						stack.pop();
				} else {
					stack.push(fr);
				}
				fr = "";
			} else if (ch != '/') {
				fr += ch;
			}
		}
		String cp = "/";
		while (!stack.isEmpty()) {
			cp = "/" + stack.pop() + cp;
		}
		return cp.substring(0, cp.length() - 1);
	}
}


 ===================================================== 


DuplicateFile.java


package DataStructures.Strings;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DuplicateFile {
	private static List<List<String>> findDuplicate(String[] paths) {
		List<List<String>> result = new ArrayList<>();
		HashMap<String, ArrayList<String>> map = new HashMap<>();
		int i;
		String path, fr, name, content;
		for (String x : paths) {
			i = x.indexOf(' ') + 1;
			path = x.substring(i - 1);
			fr = "";
			for (; i < x.length(); i++) {
				if (x.charAt(i) == ' ') {
					content = x.substring(x.indexOf('(') + 1, x.indexOf(')'));
					name = x.substring(0, x.indexOf('('));
					if (!map.containsKey(content)) {
						map.put(content, new ArrayList<>());
					}
					map.get(content).add(path + name);
				} else {
					fr = fr + x.charAt(i);
				}
			}
		}
		int count = 0;
		for (Map.Entry<String, ArrayList<String>> entry : map.entrySet()) {
			result.add(new ArrayList<>());
			for (String x : entry.getValue()) {
				result.get(count).add(x);
			}
			count++;
		}
		return result;
	}
}


 ===================================================== 


StringMultiplication.java


// https://leetcode.com/problems/multiply-strings/

package DataStructures.Strings;

public class StringMultiplication {
	public static void main(String[] args) {
		String num1 = "123", num2 = "456";
		System.out.println(multiply(num1, num2));
	}

	private static String multiply(String num1, String num2) {
		int[] d = new int[num1.length() + num2.length()];
		num1 = new StringBuffer(num1).reverse().toString();
		num2 = new StringBuffer(num2).reverse().toString();
		for (int i = 0; i < num1.length(); i++) {
			for (int j = 0; j < num2.length(); j++) {
				d[i + j] = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
			}
		}
		StringBuilder sb = new StringBuilder();
		int carry, mod;
		for (int i = 0; i < d.length; i++) {
			mod = d[i] % 10;
			carry = d[i] / 10;
			if (i + 1 < d.length) {
				d[i + 1] += carry;
			}
			sb.insert(0, mod);
		}

		while (sb.charAt(0) == '0'	 && sb.length() > 0) {
			sb.deleteCharAt(0);
		}

		return sb.toString();
	}
}


 ===================================================== 


ZigZag.java


// https://leetcode.com/problems/zigzag-conversion/

package DataStructures.Strings;

public class ZigZag {
	public static void main(String[] args) {
		String s = "PAYPALISHIRING";
		int numRows = 2;
		System.out.println(convert(s, numRows));
	}

	private static String convert(String s, int numRows) {
		if (numRows == 1) {
			return s;
		}
		if (numRows == 2) {
			String odd = "", even = "";
			for (int i = 0; i < s.length(); i++) {
				if (i % 2 == 0) {
					even += s.charAt(i);
				} else {
					odd += s.charAt(i);
				}
			}
			return even.concat(odd);
		}
		int[][] rows = new int[numRows][s.length()];
		int i = 0, j = 0;
		boolean goDown = true;
		for (int x = 0; x < s.length(); x++) {
			rows[i][j] = s.charAt(x);
			if (goDown) {
				i++;
			} else {
				i--;
				j++;
			}
			if (i == 0) {
				goDown = true;
			}
			if (i == numRows) {
				goDown = false;
				i -= 2;
				j++;
			}
		}
		int col = j;
		String str = "";
		for (i = 0; i < numRows; i++) {
			for (j = 0; j <= col; j++) {
				if (rows[i][j] != 0) {
					str += ((char) rows[i][j]);
				}
			}
		}
		return str;
	}
}


 ===================================================== 
